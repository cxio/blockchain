## 导读

> 去中心化的信任是一个古老的难题，Bitcoin的出现让这一难题有望解决，但Bitcoin网络运行至今已开始表现出不尽人意。本设计就是想克服Bitcoin及区块链现有技术的已知缺点，给去中心化的P2P信任网络提供一个完整并尽可能完美的解决方案。下面是设计中的一些要点。


### 共识模型

#### 基于既成历史的概率素材

交易ID是交易数据的哈希摘要，拥有无法预测的随机性。区块链上的历史交易是一些既成的事实，无法伪造。因此，借用历史交易的ID来评选区块的铸造者是一个简单有效的做法。与历史交易ID对比的是当前链末端的-9号区块，它是动态的，因此这种评选也是动态的。

详见 [共识模型-历史证明](1.共识模型-历史证明（PoH）.md)。


#### 固定出块时间的优点

Bitcoin中追逐最长链的竞争机制使得分叉需要重点防范，同时因为区块出块时间无法确定，使得基于时间的便利很难获得。

如果区块出块时间固定，会带来很多好处，比如单纯依靠时间戳就可以知道当前区块链的高度。交易的时间戳也可以用于构造某些机制（如**区块不收录未来交易**的规则，以及「适时转播」和「错时延迟」的端点约定），分叉竞争中忽略超出规定长度的支链也更容易理解。


### 公共服务

#### 节点发现是一个服务网络

传统的P2P节点信息服务器是中心化的，IP地址相对稳定，但这是一种致命弱点，因为攻击者很容易确定目标并阻断服务。

本设计中的**节点发现**服务网络是去中心化的，任何一个节点都可以成为一台服务器。之所以能如此，不仅是因为节点发现服务器的成本相当低廉（一台旧安卓手机或树莓派即可），更重要的是还有着利益的驱动：提供服务的节点可能获得区块链代币奖励。

节点发现服务网络除了提供P2P节点信息，还可以辅助节点侦测自身NAT类型（*类似stun服务器，但通过网络协作无需双IP要求*）。

**详见**：*[github.com/cxio/findings](https://github.com/cxio/findings)*。


#### 紧缺性感知机制下的开放式存储

交易中可以包含附件，但附件并不宜存储在区块链上，这些数据可交由开放的P2P全网存储。通过简单的感知机制，即可协调P2P全网存储决策。

基本原理是这样：

节点向P2P网络查询数据，其它节点响应有一个基本规则：**如果自身拥有目标数据，返回响应信息，否则将请求包跳数加一后转播**。这样就获得了一个机制：如果目标数据存储稀少，请求会被广播得很远，跳数也更高，而节点就可以根据这个情况决定是否补充存储。

这是一种开放式的感知机制，无需任何额外的技术，且简单易行。

> **参考：**
> 公共服务部分 [数据的紧缺性感知](3.公共服务.md#数据的紧缺性感知) 和 [数据心跳](3.公共服务.md#数据心跳) 。


#### UTXO指纹的末端约束

UTXO是指区块链当前未花费交易输出的集合，而UTXO指纹就是对这一集合的某种结构化布局之后的哈希汇总（类似默克尔树的哈希树根）。UTXO指纹在每一个区块中都存在，可以视为一种对**区块链当前UTXO状态**的锁定，这能带来一些重要好处：

1. 指纹的约束是链式的，攻击者无法通过单个区块的交易ID塑造来匹配UTXO指纹（假设攻击者拥有极其强大的算力）。这强化了安全。
2. 一个新的节点可以通过少量的数据就快速验证并锁定主链，然后再并发地同步其它区块数据。这提高了效率。
3. 因为最新的UTXO集合可以通过UTXO指纹验证，所以一个新的节点可以快速地开始工作：验证交易，参与铸造等。

> **参考：**
> 公共服务部分 [UTXO指纹](3.公共服务.md#UTXO指纹) 。


#### 固化存储的可能性和效率

区块链上的数据都是历史性的，它们不应当被修改（篡改），所以交易和其附件的存储实际上是一种「档案存储」的逻辑。

无需修改的存储逻辑可以简化存储系统的复杂性，而且也可以设计得更安全，效率更高。仅仅只需一次性写入实际上是一种 固化存储，这种需求的简单性可能促使廉价存储介质的开发，从而为海量存储提供更可行的成本。


### 激励机制

#### 开放式奖励的兑奖约束

公共服务需要激励才能形成开放的P2P服务网络，但开放环境下的抽奖凭证验证十分困难，因为总有办法作假。本设计简单地通过兑奖约束来完成激励，有效地避免了抽奖逻辑下安全性难于保证的问题。

规则很简单：**区块的铸造者可以任意指定获奖服务器，但兑奖需要得到后续铸造者的认可**。这就巧妙地将资格难以验证的问题转化成了可准确标记的问题。

> **注：**
> `Coinbase` 交易中有一个 `90字节` 的兑奖标记槽，里面标记了前段 `240个` 区块的奖励认可。中奖者在240个区块之后就可以提取奖金，验证条件就是兑奖槽中的标记统计。
> 详见激励机制部分的 [可能随意的局部评估](4.激励机制.md#可能随意的局部评估)。


### 脚本系统

#### 三种基本信元

代币（**币金**）是一种价值载体，但主要用于计量。单纯的计量并不能充分表达和传递信用，所以在币金之外，设计加入了**凭信**的逻辑。凭信是一种纯粹的信用表达，类似于现实世界里的证券、凭证甚至第三方Token，它们也拥有属主，可以转移。

另外在现实世界中，还有一种静态的信用事物，它们不需要转移，其存在本身就是一种表达，如合同、证书、证据等。所以设计添加了第三种信用单元：**存证**。存证只是一种存在性表达，没有转移的逻辑（但可以验证）。

所以总的来说，有三种信元被归纳了出来：**币金**、**凭信**、**存证**。脚本系统也针对这三种信元逻辑来设计。


#### 脚本指令的附属参数和实参空间

Bitcoin的脚本系统是栈结构，本设计也如此。为了让脚本指令更通用、灵活，设计添加了指令的**附属参数**逻辑（简称附参），附参不但让指令表达更简洁、清晰，语句长度类附参还天然制约了脚本的复杂度，促使脚本逻辑的扁平化。

实参空间是一个语法技巧，这让不定参数指令的支持十分简单，同时也方便局部变量的设计。


#### Each而非Loop的循环

通常来说，一个图灵完备的脚本语法需要完整的流程结构：`if/else`、`switch/case`、`loop/break` 等。但P2P开放环境下的安全需求十分严酷，以至于连Bitcoin都没有加入循环的逻辑。

但缺乏循环结构的脚本受限较多，有些逻辑很难表达。折衷考虑，设计加入了有限循环的指令（`EACH`）。Each指令是对一个已有集合的成员迭代执行相同的代码，它也是一种循环，但循环次数并不随意。


#### 校验脚本合法性的模式指令

有时候，我们需要知道将要执行的脚本是否符合预期，这样我们才能放心地构造交易。检查脚本是否符合预期有一种常见的方法就是审计，但人工审计无法融入线上的自动化流程（而且也未必可靠），因此设计添加了**模式指令**的结构。

模式指令是用于**脚本指令序列的模式匹配**，确保脚本会按照规定的逻辑执行。它有些像正则表达式，但有自己的逻辑并更简单一些。

> **注：**<br>
> 详情请参考：脚本基础指令集里的 [模式指令](6.脚本基础指令集.md#12-模式指令) 部分。


### 其它

#### 纵向分片的组队校验

P2P网络上的节点是独立的，区块链的交易验证工作实际上是「单机」的逻辑，因此节点的计算机性能就成了区块链交易规模的制约原因。

如果我们仔细观察，交易上的信用转移实际上是逻辑完整的，它们有着**独立的**可验证性。这就是单笔交易的独立验证。因此以交易为单位的验证分工就可行了：一个节点只验证少量的交易，大量的交易由不同的节点分别验证完成。配合恰当的分工管理和冗余复核，多机协作的组队式校验就是可行的。

这样的组队式校验十分自由，而实际上这种模式可以自然而然的去中心化。

> **注：**<br>
> 详情请参考：[组队校验](附1.组队校验.md#组队校验)。


-------------------------------------------------------------------------------

下一篇：[共识模型-历史证明（PoH）](1.共识模型-历史证明（PoH）.md)
