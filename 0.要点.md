# 要点

## 共识模型

### 基于历史的概率素材

交易ID是交易数据的哈希摘要，拥有无法预测的随机性。区块链上的历史交易是一些既成的事实，无法伪造。因此，籍由历史交易的ID来评选区块的铸造者是一个看起来简单的做法。

交易的历史塑造共识，而共识又反过来保护交易的历史，这是一种闭环的自我保护，十分强壮。


### 固定的出块时间

Bitcoin系统采用PoW共识，由最长链胜出，区块的出块时间无法确定。

如果出块时间固定，会带来不少好处，比如单纯地依靠时间就能计算出区块的高度，交易的确认时间也更为明确。另外，某些基于时间的功能也更易于实现。



## 公共服务

### 节点发现是一个服务网络

传统的P2P节点初始连网时，需要一个联系其它节点的信息中心（找到其它节点）。这是一种中心化的逻辑，存在单点故障或被封锁的风险。

本设计中的**节点发现**服务是一个去中心化的网络，无法被封锁，也不存在单点故障的问题。并且如果有必要，用户还可以用暴力发现的方式，遍历全网搜寻服务节点（因为目标巨大，所以暴力发现是可能的）。

节点发现服务网络除协助节点建立初始连接外，还集成了NAT类型探测和UDP打洞协助服务，成为一个通用的P2P基础设施。

> **项目：**
> *[github.com/cxio/findings](https://github.com/cxio/findings)*。


### 紧缺性感知机制下的开放式存储

交易中可以包含附件，附件可以是大文件，因此附件应当由另外的系统存储。存储大数据的系统称为数据网络（Depots: 数据驿站组网）。

数据网络也是P2P模式，通过简单的数据**紧缺性感知**机制，实现全网的存储决策。机制是这样的：节点向数据网络查询数据或发送探测，其它节点响应：

**如果自身拥有目标数据，返回联系信息，否则将请求包跳数加一，然后转播。**

这样，如果目标数据存储稀少，请求就会被广播得更远（跳数更高），节点根据请求包的跳数权衡自己的存储策略，决定是否补充存储。

这是一种极为简单的感知机制，但可以传递有效信息。



## 激励机制

#### 开放式奖励的兑奖约束

公共服务需要激励才能持久运行，但开放环境下的抽奖验证并不容易，因为作假的可能性实在太多，防不胜防。

本设计简单地通过「兑奖」约束来完成激励。

规则为：**区块的铸造者可以随意指定获奖服务节点，但兑奖需要得到后续铸造者的认可**。

这样就巧妙地将抽奖资格难以验证，转化成了可准确标记的问题。



## 脚本系统

### 三种基本信元

代币（**币金**）是一种价值载体，主要用于计量。

单纯的计量无法充分表达信用，所以在币金之外，设计加入了**凭信**的逻辑。凭信只是文字描述，可转移，可包含附件。

还有一种静态的信用，它们不需要转移，这就是**存证**。存证是一种存在性表达，支持识别脚本以运行某种逻辑。

脚本系统即针对这三种信元来设计。


### 脚本指令的附参和实参空间

本设计依然采用Bitcoin的栈式脚本，但语法和指令更通用和灵活。

指令采用**附属参数**（简称附参）表达与指令密切相关的属性，比如语句块的长度、跳转指令的目标、一些需要固化的实参等。

实参空间是一个技巧，让指令需要的实参可以先被提取出来，避免栈语言的数据排挤问题。


### 有限循环（Each）

出于安全考虑，Bitcoin脚本不支持循环语法，这是必要的。

但作为一个通用的信用系统的脚本语言，需要一定程度的图灵完备。折衷考虑，我们采用有限循环的方式（`EACH` 指令）。Each的目标只能是一个有限集合，通过对集合大小的客观限制，可以有效避免锁死的攻击。



## 组队校验

P2P网络上的节点是独立的，区块链的交易验证工作实际上是「单机」的逻辑，因此节点的硬件性能就制约了交易的规模。

但如果我们仔细观察，交易上的信用转移实际上是逻辑自完备的，每一笔交易都有着**独立的**可验证性，甚至每一笔输入都是独立的。因此为应对大量的交易，我们可以以交易为单元进行分工：

*一个节点只验证少量的交易，大量的交易由不同的节点分别验证完成*。

配合恰当的分工管理和冗余校验，多机协作的**组队式**校验是可行的。这类似于一种纵向**分片**的逻辑。

> **注：**
> 组队校验可以是封闭的小团体模式或自由的开放模式，但以校验组为微中心的网络，依然是去中心化的。



-------------------------------------------------------------------------------

下一篇：[共识：历史证明（PoH）](1.共识-历史证明（PoH）.md)
