>
> 未来，人工智能会拥有强大的理性，任何中心化单位都会被说服或腐蚀。然而，如果这超级智能并不通往宇宙的真理，它就很可能将人类带往歧途。
>
> 唯有真正的去中心化……
>
> 一个去中心化未来的信用底层，隐含秩序、自由、和新的可能性～
>

# 区块链开放式架构设计

## 前言

Bitcoin是区块链世界的开创者，采用工作量证明（PoW）的共识模型。该模型简单有效，但运行至今已表现出一些存疑：

1. **大量的电力消耗：**
哈希碰撞是一种强制消耗时间的运算，除了用算力拼胜负，没有更多的意义。

2. **垄断的中心化可能：**
高能耗促使矿池倾向于规模化运营，大矿池可能导致中心化垄断的存疑。

3. **算力波动的影响：**
不同的区块链有用相同的矿机，算力切换或自然灾害或运营停摆都会造成算力的波动。这会影响系统出块时间的稳定性。

4. **缺乏时间确定性：**
哈希运算竞争没有时间确定性。这会影响出块预期，虽然不算一个问题，但如果时间能确定会更好。

5. **庞大的数据负担：**
区块数据持续增长，其存储和计算成本越来越高。这在P2P逻辑下不是一件好事。

这里试图重新思考，在遵循区块链核心价值的前提下，克服以上所有不足，创建了一个开放式架构。同时还增强了通用性，以及共识的可靠性。

欢迎讨论！


## 概要

### 信用的实体单元

在Bitcoin中，一笔交易由输入和输出构成，输入引用的是前一笔交易的输出，其合法性由输出的脚本验证。交易承载了比特币的流转，是资产权属的转移，从本质上看，这是一种信用的传递。

社会的运行由信用驱动，而交易，可以视作这一驱动的数字实体之一。


### 由交易驱动的环境

信用在社会中广泛存在，融入在各种不同的传统体系里。这些体系通常是逻辑自我完整，但对外提供信用的接口。

如果我们把交易看作信用的介质，区块链就是一个运行着信用的实体。遍及各处的区块链与传统的体系相互沟通协作，安全可靠地传递信用……这似乎是另一番场景。

在Web中，用户与页面的交互由一种称为**事件驱动**的模型提供。

这里，用户发起交易，交易携带意图，通过全网可及的区块链传递到任何一个角落。或许，这可以称之为**交易驱动**的模型。


#### 链信用的独立性

一条区块链只能保证本链上资产的安全，这是合理的，万物皆有边界。这不妨碍信用在不同的链间传递。


#### 中间件的中介层

交易定义了权属在个体之间的转移。获取信息、构建交易并发送，在逻辑上这是私有的。因此，从一条链上获取信息后在另一条链上创建交易，并不涉及公共验证的问题，也即：链间的信用传递是私有的，用户自负其责。

由于边界的存在，两条链之间的交互就需要一个「交互者」的逻辑层，即中间件。

具体的工作方式可能是：

中间件在一条链上注册监听，当监听到目标发生变化时，触发行为，中间件就可以执行自己的业务逻辑。譬如：

- 无人旅店中间件监听收款地址的收款，开启智能门锁。
- 税务系统通过预先发布的管理者交易，监听跳转过路信息，然后记录企业财务申报。
- 用户跨链兑换代币，中间件监听对方支付，实现自动化处理。


### 公共服务的网络

对于终端用户来说，区块链是一个P2P的服务网络。但现有的区块链系统负载过重，这影响了它提供服务的能力。

实际上，区块链程序的逻辑可以分解成几个部分：

1. **节点发现（Findings）**：负责应用节点的登记、缓存，充当中介信令服务器。同时提供NAT探测和打洞协助（STUN）。
2. **数据驿站（Depots）**：负责区块链数据的探测、存储和供给。这是一个容器，内部封装具体的微服务，支持不同的区块链应用。
3. **具体应用（Blockchain）**：基于上面两个公共服务的具体区块链应用，数据外包，轻松运行。但也为公共服务提供经济激励。

公共服务节点自我组网，构成一个持续运行的P2P网络。


#### 服务关系图

数据驿站内部的微服务主要包含两个：

- **档案存储（archives）**：负责完整区块数据以及交易携带的附件的存储，主要以文件分享的P2P方式运行。支持大文件。
- **区块查询（blockqs）**：提供区块链交易数据的即时查询，以Web服务器的方式运行。仅支持小数据请求。

<img src="images/serv4nets-920x620.svg" width="920" alt="服务关系图" style="background-color:#333; padding:20px; border-radius: 20px;" />

> **图解：**
> 单箭头表示支持，双箭头表示互联。实线表示连接，虚线表示连接关系。`Peer` 为具体的区块链应用节点。


#### 通用性

区块链的便捷支付能力可为公共服务的节点提供激励，避免了工地悲剧的问题。这些节点可以一直持续运行。

因为节点发现和数据存储也是任意P2P应用的内在逻辑，所以如果服务节点愿意，它们实际上也可以为非区块链P2P应用提供帮助，甚至成为它们的底层支撑。如果非区块链应用也捐赠代币，那固然很好，但如果没有也不影响服务器的生存，服务节点附带提供帮助也未尝不可以。

这是一个巨大的生态，如果成功，可能可以媲美传统的Web服务器网络。


## 导读

1. ### [要点](0.要点.md)
2. ### [共识模型：历史证明（PoH）](1.共识-历史证明（PoH）.md)
3. ### [共识模型：端点约定](2.共识-端点约定.md)
4. ### [公共服务](3.公共服务.md)
5. ### [激励机制](4.激励机制.md)
6. ### [信用结构](5.信用结构.md)
7. ### [脚本系统](6.脚本系统.md)
8. ### [脚本基础指令集（明细）](7.脚本基础指令集.md)
9. ### [附：组队校验](附.组队校验.md)


## 参考

- [区块链基本知识](区块链基本知识.md)
- [概念集](概念集.md)
- [代码实现参考](实现参考.md)


## 脚本用例

### 链间兑换

甲方 **A链** 和乙方 **B链** 之间的代币兑换。

甲方发布的兑换脚本（*A链*）：

- 如果甲方提供解锁数据，构造交易执行，则为赎回逻辑。
- 如果乙方提供解锁数据……则为代币转移。**注**：甲方先转移乙方的代币，`<hashSource>` 会公开。

> **注：**
> 乙方发布的 *B链* 兑换脚本类似，只是 `IF{}` 相关的判断反过来。

```go
// 解锁脚本
// 提示：所有的返回值都会自动入栈。
DATA{<hashSource>}                  // 哈希源，由甲方创建并保留
{2}                                 // 验证类型（多签）
<flag>                              // 授权标记
<[sig]>                             // 签名数据
<[pubKey]>                          // 公钥序列
<[pubHash]>                         // 公钥哈希（地址）序列
@POPS[5]                            // 弹出栈顶5项到实参区

// 锁定脚本
SYS_CHKPASS                         // 系统内置验证（不定数量参数）
SYS_TIME{Stamp} {<expireTime>}      // 提取当前时间戳、预置过期时间戳
GT                                  // 栈顶2项大于对比，返回Bool
IF{                                 // 真：
    MULSIG[0]                       // 是否由甲签名，返回Bool
    PASS                            // 栈顶为真时通过（甲赎回）
    EXIT                            // 结束脚本
}                                   // 假：
MULSIG[1] PASS                      // 是否由乙签名，真时通过
FN_HASH256                          // 栈顶剩余项为<hashSource>，计算其哈希
DATA{<hashResult>}                  // 预置源哈希结果
EQUAL PASS                          // 栈顶两个序列相等比较，真时通过（乙转移）
```

> **详见：**
> examples/[链间兑换.md](examples/链间兑换.md)。

完整指令说明请见：[脚本基础指令集（明细）](7.脚本基础指令集.md)。


### 更多用例

- [存在性证明](examples/存在性证明.md)
- [版权登记](examples/版权登记.md)
- [链间传信](examples/链间传信.md)
- [累积付款](examples/累积付款.md)
- [网购支付流程](examples/网购支付流程.md)
- [实时税务](examples/实时税务.md)
- [选举子链（方案）](examples/选举子链.md)


--------------------------------------------------------------------------

*∬ 用逻辑设计程序，用代码书写逻辑，用程序表达自然*
