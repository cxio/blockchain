## 选举子链脚本集

创始区块里包含了起始交易，起始交易里包含了授权签发投票权和验证票的公钥地址清单。

客户端程序里有一个固定规则：只有创始区块里起始交易列出的公钥清单有权创建凭信资产（投票权、验证票），系统禁止凭信资产的凭空创建（即只能转移）。同时客户端会维护一个 UTXO 集，里面包含了子链自身发行的激励币金和凭信资产（投票权、验证票）。

投票权和验证票资产可以被花费（使用），使用次数被设置为 `1`。

> __注：__
> 起始交易在主链上只是一笔 __存证__ 交易。详见交易类型定义 [存证](../../5.脚本系统设计.md#存证)。


### 投票权

投票的凭信资产可以被转移，但转移次数为 `1`，使用投票权的交易应当是内容票（输入项）。

除了基础性的用户签名验证外，投票权的输出脚本中包含了对内容票提交内容的格式验证。这是必要的，它既限定了用户的类型，也避免了用户提交无效的内容。也因此，选票内容的条目和格式需要在启动子链网络前确定。

另外投票权凭证的标题也可以帮助用户辨别自己是投票权而非验证票。

> __注：__<br>
> 内容票中只对条目的内容加密而非整体加密，条目名称留待格式验证用。<br>
> 如果选票内容格式需要后期才能确定，则输出脚本的验证部分可以引入一个内容票约定标识（避免被确认票使用）。<br>

```go
// 解锁脚本
// <sig> <pubKey>               // 系统内置验证

TEXT[...]{<conNames>}           // 投票内容条目名称序列。注：...指具体的长度值，<conNames>为指代
DATA[...]{<conData>}            // 投票内容值数据（已加密）

// 锁定脚本
SOURCE[-1]                      // 提取前段源脚本字节序列
@MODEL{                         // 内容格式检测，非法则失败
    TEXT[...]{<conNames>}       // 条目名称序列严格匹配
    DATA[?]{?}                  // 匹配任意字节序列，长度不定（即加密数据）
    #[64]                       // 提取前面匹配的加密数据（开票协助）
    SOURCE[-1]                  // 原样&末尾匹配
}
OUTPUT BUFDUMP                  // 导出前面提取的数据并转储。仅开票阶段需要，空执行无害
```

> __注：__<br>
> 代码中的换行只是一种视觉友好，以便逻辑清晰（同行上的指令逻辑更紧密些）。<br>
> 转储是一个外部激发机制，节点运行脚本时需先注册处理器，数据会传递给处理器来完成外部的逻辑。<br>


### 验证票

验票凭信也可以被转移，同样的转移次数为 `1`，使用验证票的交易为内容票之后的确认票（输入项）。

除了基础性的用户签名验证外，验证票的输出脚本中包含了由登记号哈希和口令哈希的哈希屏障验证，以及内容票引用和登记号哈希数据项的导出。导出和转储是无阻塞执行的，如果运行脚本的节点先期注册了处理器，这些数据就会被传递过去（由另外的监听服务提供衔接）。这样就可以执行开票环节了。

```go
// 解锁脚本
// <sig> <pubKey>                   // 系统内置验证

{<conBlockNum>}[4]                  // 内容票所在区块号（4字节整数）
DATA[32]{<conTxID>}                 // 内容票交易ID
DATA[32]{<regNumHash>}              // 登记号哈希
DATA[32]{<passwdHash>}              // 用户口令的哈希

// 锁定脚本
TOPS[2]                             // 引用栈顶2项（<regNumHash>和<passwdHash>）
GLUE                                // 两项数据合并（登记号哈希+口令哈希）
FN_HASH256                          // 计算哈希结果
DATA{<hashResult>} EQUAL            // 压入脚本中已有的结果序列，比较两个序列是否相同
PASS                                // 前面的比较相同则通过

@POP NOP                            // 弹出栈顶1项（即口令哈希），丢弃
@POPS[3]                            // 弹出栈顶3项（区块号、交易ID、登记号哈希）到实参空间
OUTPUT BUFDUMP                      // 导出实参空间的3项值并转储（开票阶段需要）
```

> __注：__
> 脚本中值指令的值和指令计算的值都会自动压入数据栈，注释中并不特别说明。


### 内容票

内容票会花掉投票权交易的凭信，使用次数递减为 `0`，因此内容票的凭信将不能再被转移使用。输出脚本无意义（可能设置为空）。

使用投票权时，内容票需要提交预定条目格式的内容，条目的值需要被加密。注意输入项是投票权交易的输出，通常来说，如果引用错误（使用了验证票），输入脚本的验证是没法通过的（也即无效），这不会带来问题。

```go
// 输出脚本为空
NIL
```


### 确认票

确认票会花掉验证票交易的凭信，使用次数递减为 `0`，同内容票一样，确认票也是一次性使用的。输出脚本无意义。

使用验证票时，确认票需要提供领票时获得的登记号哈希、口令哈希以及内容票引用（区块号和交易ID）。前两者用于验证哈希屏障，内容票信息用于检索读取内容，另外登记号哈希还用于构造解密密码（`密码 = Hash(基码 + 登记号哈希)`）。

基码是由客户端私有导入计算环境的，验证脚本执行时会导出登记号哈希和内容票引用信息。这样客户端就可以汇集信息构造密码，检索内容票解密读取了。

```go
// 输出脚本为空
NIL
```


### 附：识别脚本

起始交易里包含的授权 __公钥地址清单__ 实际上可以用识别脚本表达，这样客户端App就可以只是简单地执行识别脚本，即可完成授权验证。

```go
// 解锁实参
<sig> <pubKey>          // 压入创建者的签名和公钥

// 识别脚本
TOP                     // 引用栈顶的公钥入栈（克隆）
FN_PUBHASH              // 取公钥副本构造公钥地址
SETVAR[0]               // 取地址值存入脚本域全局变量（[0]位置）

DATA{<pkhash_1>}        // 压入授权公钥地址1（假设共5个）
DATA{<pkhash_2>}        // 压入授权公钥地址2
DATA{<pkhash_3>}        // 压入授权公钥地址3
DATA{<pkhash_4>}        // 压入授权公钥地址4
DATA{<pkhash_5>}        // 压入授权公钥地址5

POPS[5]                 // 5个公钥打包为一个集合
EACH{                   // 对集合成员逐个执行子脚本
    @VAR[0]             // 引用全局变量值到实参空间
    &{Value}            // 引用迭代中的值到实参空间
    EQUAL               // 比较两个值是否相同，结果入栈
}
POPS[5]                 // 取出EACH{}子脚本入栈的结果序列
SOME[1]                 // 是否至少有一项为真，结果入栈
PASS                    // 真值通过
FN_CHECKSIG PASS        // 签名验证（此时栈顶剩余<sig>，<pubKey>两项数据）
```

__注：__<br>
> 存证的识别脚本也可以像凭信或币金的锁定脚本一样，包含验证的功能，但这仅仅是与识别该脚本的App有关。<br>
> 与凭信的锁定脚本不同，因为存证没有转移逻辑，所以其识别脚本的使用次数没有限制。<br>


另一个更简单的脚本实现，不使用  `EACH{}` 指令，但解锁实参需要多提供一项信息（公钥地址位置）：

```go
// 解锁实参
<index>                 // 公钥地址在授权清单中的下标位置
<sig> <pubKey>          // 签名和公钥

// 识别脚本
TOP                     // 引用栈顶的公钥入栈（克隆）
FN_PUBHASH              // 用公钥副本构造公钥地址

DATA{<pkhash_1>}        // 压入授权公钥地址1
DATA{<pkhash_2>}        // 压入授权公钥地址2
DATA{<pkhash_3>}        // 压入授权公钥地址3
DATA{<pkhash_4>}        // 压入授权公钥地址4
DATA{<pkhash_5>}        // 压入授权公钥地址5

POPS[5]                 // 栈顶5项打包为一个切片入栈
PEEK[0]                 // 引用栈底值（<index>）入栈
ITEM                    // 取目标集内特定下标位置的值入栈

EQUAL                   // 此时栈顶2项为FN_PUBHASH的结果和刚刚入栈的拣取项，相等比较
PASS                    // 比较结果为真则通过
FN_CHECKSIG PASS        // 验证签名，合法为真则通过
```

> **名词约定**<br>
> **公钥地址**：对公钥执行某种哈希运算之后的字节序列，称为公钥地址。<br>
> **账户地址**：对公钥地址进行可视化编码（`BASE32` 或 `BASE58`）之后的字符串，用于书写识读。<br>


### 附：其它

#### 开票

节点运行的客户端App先注册开票处理器，导入基码，再次执行确认票验证，提取数据并运行开票处理器。

计票原理&过程：

1. 确认票的输入验证脚本（即验证票输出脚本）会导出3项数据：内容票的 __区块号__、__交易ID__ 和选民的 __登记号哈希__。
2. 根据内容票引用信息，开票处理器请求客户端App执行内容票验证，获得内容票导出的 __加密数据__。
3. 开票处理器构造解密密码（`Hash(基码+登记号哈希)`），解密内容票数据，读取投票内容、统计、发布。


#### 安全性

选举链上的凭信转移实际上只有一次，两个层级：

1. 机构签发的选举权证（投票权、验证票）。根据起始交易里的授权公钥受限创生。
2. 选民投票用的使用权证（内容票、确认票）。花费掉上面机构签发的选举权证，自身不能再被花费。

所以客户端在开票时还可以检查 __验证票__ 的输入项是否源于起始交易。虽然在系统禁止空白来源凭信创建的情况下，这种检查并不必需。
