# 选举子链设计

在公共的主区块链上创建一条附生的子链，实现选举的功能环节，拥有开放的监督和安全性。这是一种可能理想且节省成本的线上选举方案。

大体上，选举可划分为四个阶段：

1. __领票__：选民携带有效证件到派票点获取当期选举的 __票权__ 和 __确权__。
2. __投票__：正式填写选票内容，发送到子链网络上，内容会加密。
3. __开票__：投票结束，开启点票。可自动计算并公示，通常由正式机构执行。
4. __监督__：区块链数据是开放的，只要开票机构公布密码因子，民间任何单位和个人都可以验证开票结果。

*流程示意图*

<img src="election/election.svg" width="680" alt="选举流程说明" style="background-color:#333; padding:10px 30px; border-radius: 20px;" />


## 创链

选举子链起源于主链上的一笔交易，包含了派票机构的资格。

当交易被主链的区块收录后，该区块即成为子链的创始区块，该交易就是子链的起源交易。接下来，就可以在子链上创建选举相关的交易了。

> **注：**
> 子链的客户端有自己的逻辑，并不与主链相同。

起源交易可以是一笔存证交易，无需凭信的转移逻辑。识别脚本如下（参考）：

```go
// 解锁数据
// <pubIndex>              // 公钥在授权清单中的位置
// <flag>                  // 授权标记
// <sig>                   // 签名数据
// <pubKey>                // 公钥

// 识别锁定
// 定制验证（无 SYS_CHKPASS）
TOP                     // 引用栈顶公钥（复制）
FN_PUBHASH              // 计算公钥哈希

// 授权公钥
// 下面清单中的成员有权派票
<pkHash_1>              // 公钥哈希1
<pkHash_2>              // 公钥哈希2
<pkHash_3>              // 公钥哈希3
<pkHash_4>              // 公钥哈希4
<pkHash_5>              // 公钥哈希5

SHIFT[5]                // 栈顶5项打包为一个切片
PEEK[0]                 // 引用栈底<pubIndex>
INDEX                   // 取目标位置的公钥哈希

EQUAL PASS              // 比较栈顶2项，相同时通过
FN_CHECKSIG PASS        // 验证签名，合法时（真）通过
```



## 1. 领票

选民可以凭有效的身份证件到派票点登记，领取*票权*和*确权*。

票权和确权是两个凭信输出，由起源交易里列明的公钥的私钥签发。接收者为登记选民的个人钱包的公钥地址。

选民登记时有如下事项：

- 身份核验。
- 领取 __登记号__ 和 __选票密码__。
- 用私密口令计算一个哈希屏障提交给登记机构。算法：`Hash( Hash(登记号) + Hash(口令) )`。
- 提供自己的公钥地址。

作为派票机构，需要创建两笔凭信，发送到选民的公钥地址上。

1. __票权__：未来*内容票*的凭证。
2. __确权__：未来*确认票*的凭证。

> **安全性：**
> 用户的口令隐含私有习惯，因此哈希封装是必要的。


### 登记号

登记号直接与选票关联，它是选票与选民真实身份之间的隔离保护，避免从选票追溯到真实的人。

登记号应当随机不重复，且是临时性存储（当期选举后销毁）。登记号可能需要足够长以增强安全性，比如**16**字节以上。


### 选票密码

区块链上的数据是公开的，开票之前的选票内容需要加密。

选票密码是一个对称密钥，由派票机构创建。算法：`选票密码 = Hash( 基码 + Hash(登记号) )`。其中 __基码__ 是一个长 `32` 字节的随机序列，在当期选举中固定不变。

> **注：**
> 选民在投票时会提供自己的 `Hash(登记号)`，开票方可据此实时构造密码解密*内容票*。


### 票权

选民在投票时创建的*内容票*的凭信来源，作为输入项被花费掉。

通常，选票内容有预定的格式，以便于识别和统计。这可以通过一笔预先发布的介管交易来约束。

```go
// 解锁数据
// DATA{<Content>}         // 投票内容（已加密）
// <Title>                 // 显式信息

// {1}                     // 签名方法（单签）
// <flag>                  // 授权标记
// <sig>                   // 签名数据
// <pubKey>                // 公钥
// @POPS[4]                // 提取实参

// 锁定脚本
SYS_CHKPASS             // 系统内置验证

<Title>                 // 标题预置
EQUAL PASS              // 对比解锁段的<Title>，简单验证

@POP                    // 提取加密数据<Content>
OUTPUT BUFDUMP          // 导出，开票阶段需要
```


### 确权

选民创建的内容票需要被确认。确认是对确权的花费，彼时将提供必要的信息，方便开票方解密投票的内容。

```go
// 解锁数据
// DATA{<TxID>}            // 内容票交易ID
// DATA{<serialHash>}      // 登记号哈希
// DATA{<passwdHash>}      // 用户口令哈希

// {1}                     // 签名方法（单签）
// <flag>                  // 授权标记
// <sig>                   // 签名数据
// <pubKey>                // 公钥
// @POPS[4]                // 提取实参

// 锁定脚本
SYS_CHKPASS             // 系统内置验证

CLONE[2]                // 克隆栈顶2项 [<serialHash>, <passwdHash>]
PACK                    // 两个成员串接
FN_HASH256              // 计算哈希
DATA{<hashResult>}      // 预置的哈希屏障
EQUAL PASS              // 相同对比，真时通过

@POP NOP                // 取栈顶<serialHash>，丢弃
@POPS[2]                // 取栈顶2项 [<TxID>, <serialHash>]
OUTPUT BUFDUMP          // 导出，外部开票使用
```


### 安全性措施

选民登记领票时，派票方应当有一个数据库用来存储相关信息。

考虑隐私保护，选票不应与选民的真实身份直接相关，需要避免不良行为者从选票追踪到投票者本人。因此有如下设计方案。


#### 选民ID库

算法：`选民ID = Hash( Hash(当期标识 + 身份ID) + 登记号 )`

其中：

- **当期标识**：当前选举的一个固定标识，用来区分历次不同选举。
- **身份ID**：  选民的真实身份标识，如身份证号、社会保障卡号等。
- **登记号**：  一个适当长度的随机字节序列。

选民ID库是一个*选民ID*的简单条目集，没有更多的字段和相互关系。它保存了选票和选民的关系（隐式），可用于后期的核查&管理工作。


#### 登记号库

登记号库是*登记号*的简单条目集，没有更多的字段和相互关系。如果考虑强化安全，可与选民ID库物理分开运行。


#### 重复检测库

选民是否已经领票，应当在领票前核实，避免一人多票问题。

检测库可以用 `Hash(当期标识 + 身份ID)` 的结果创建，也只是一个简单条目集。选民提供身份ID，派票方计算结果搜寻是否已经存在……


#### 攻击分析

上面的数据库中都不存储登记选民的真实身份ID。

如果攻击者想要知道某人的投票内容（已知身份ID，找到登记号），他需要同时得到*选民ID库*和*登记号库*：通过遍历登记号库，根据上面的算法计算选民ID，核实选民ID库中是否存在该条目，然后得到登记号。

如果是从选票找到其投票人（已知登记号哈希，找到身份ID），则除了同样需要得到*选民ID库*和*登记号库*外，攻击者还需要得到**身份ID库**本身，这通常只能从选举之外的政府系统中取得。这样的攻击更困难。



## 2. 投票

分前后两笔不同的交易完成：

1. __内容票__：包含具体的投票内容，用*选票密码*加密。输入为对*票权*的花费，先发送。
2. __确认票__：在内容票进入区块后，确认该内容票。输入为对*确权*的花费，提供口令哈希和登记号哈希，用于验票和解密内容票。

> **注：**
> 切分为两笔不同的交易可增强安全性，避免私钥和密码泄露带来的风险。


### 附：密文的可分辨性

选票已知，如果投票给不同的候选者需要采用不同的选票，则加密数据的长度可能透漏选举内容。这依赖于选票的设计。

如果不同的候选者都在同一张选票上（混合式），选谁只是某个标记不同，则通常不会有问题。但对于分离式选票，可能就需要采用数据补齐的措施了。

> **注：**
> 用于补齐的数据拥有确定性可能更好（相同内容在不同的设备上有相同的密文）。



## 3. 开票

当投票结束后，开票过程即可开始。

开票实际上是对区块链中的确认票重新验证一次，此时会预先导入基码，然后就可以实时构造密码解密选票内容，执行计票统计工作。



## 4. 监督

区块链的网络是P2P的，所有数据公开，因此实际上任何节点都可以执行开票过程（如果已经知道了基码）。

选举机构应当在开票后公布基码，以接收需要的公众监督。



## 附注

### 子链运行（激励）

如果选举机构有运行子链网络的预算，可以采取有经济激励的方式运行，鼓励个体节点的参与。

- 在派票机构创建*票权*和*确权*时，给每一个登记选民派发代币。
- 选民投票时，在使用票权和确权的同时，也会花费代币。这些代币会全部作为交易费贡献给矿工。
- 最终，代币通过某种方式兑现现实的利益。

当然，如果选举机构预算拮据，但民众热情，则无币的方式也能运行。极端情况下，可能仅仅一台计算机运行即可。


### 客户端App

选举子链是在每一次选举开启后创建的，选举结束后该子链就完成了任务，不再需要了。

选举子链的客户端包含了区块链网络运行的基本能力，但有一些特殊之处：**创始区块**和**来源交易**应当是可配置的。这样，在每一次选举开始后，客户端就可以通过简单的配置即可投入使用。
