## 链间兑换

一条区块链上的币如果能自动兑换为另一条链上的币，有时会非常有用。

区块链上的币流通是链局限的（仅限于本链环境），因此链间兑换并不是把一条链上的币变成另一条链上的币，只是 **兑换** 而已。即假设你有比特币，希望把一些比特币换成以太币，此时需要有一个人愿意接收你的比特币，同时他也有以太币。如果这种交换可以自动实现（无需第三方交易所），就是链间兑换。

通过链间兑换协议，你可以很安全地把你的比特币发送给他，而他也可以很安全地把以太币发送给你，双方都无法欺骗。

> **注：**
> 上面举例的比特币和以太币只是便于理解，目前它们并不支持链间自动兑换的脚本。


### 用例

甲有A链上的币金 `a1`，乙有B链上的币金 `b1`。甲向乙请求兑换B链上的币金。

**条件：**
> 甲乙共同构造A链和B链上的多重签名地址 `a2` 和 `b2`，签名模式为1/2（任一签名即可使用）。
> 构造多重签名地址的公钥地址序列假设为「甲-乙」序（即：[0] = 甲，[1] = 乙）。


### 过程

1. 甲先发送A链上的币金支付交易 `txA: a1 => a2`，设置一个哈希屏障和过期赎回分支（`IF{...}`）。
2. 乙看到交易 `txA` 后，发送B链上的币金支付交易 `txB: b1 => b2`，前置相同的哈希屏障，同时也包含过期赎回逻辑。
3. 等待两笔交易确认。
4. 甲转移 `txB` 中的币金。因为哈希屏障的存在，甲必须提供哈希源（公开）。
5. 甲的转移交易会触发哈希源导出，乙可事先注册中间件，自动转移 `txA` 中的币金。兑换完成。

**注意：**
> 双方应当在赎回期限之前尽早完成币金的转移（必要的话，可以设置一个较长的期限）。
> 两个有效期应当在相近的时间点结束，避免网络拥堵造成交易难以确认，赎回逻辑生效后一方发起不应有的赎回（双花竞争）。


### 脚本

#### 甲方创建的兑换支付脚本

**A链：`txA: a1 => a2`**

```go
// 解锁脚本
// <sig> <pubKey>                   // 系统内置验证
DATA[32]{<hashSource>}              // 哈希源，甲创建并保留

// 锁定脚本
SYS_TIME{Stamp} {<expireTime>} GT   // 是否过期
IF{                                 // 是：
    MULSIG[0] PASS                  // 由甲签名，通过（赎回）
    EXIT                            // 结束脚本
}                                   // 否：
MULSIG[1]                           // 是否由乙签名
PEEK[-2] FN_HASH256                 // 引用栈顶第2项，计算哈希
DATA{<hashResult>} EQUAL            // 哈希屏障，比较结果
BOTH PASS                           // 前两者都为真时通过（乙转移）
```

> **提示：**<br>
> 脚本代码中的指令用空格和换行符分隔，两者没有区别。逻辑上更紧密的会放在同一行而便于理解。


**兑换模型：**

甲创建的兑换支付脚本需要符合预定的格式，才能保证乙能够正常地提取币金转移。这种预定的格式由兑换模型来保证。
乙检查甲的兑换脚本是否符合格式，提取时间戳和哈希屏障数据，构建兑换支付交易。

> **注：**<br>
> 兑换模型是一段满足兑换逻辑的预定义脚本，通常会被共享发布出来。脚本是可执行的，待检测脚本是它的实参。<br>

```go
@MODEL{
    SYS_TIME{Stamp} {?} #[64] GT    //1: 提取时间戳，{?} 同 ? {}
    IF{                             // if指令，进阶匹配
        MULSIG[0] PASS              // 严格匹配
        EXIT                        // 严格匹配
    }
    MULSIG[1]                       // 严格匹配
    PEEK[-2] FN_HASH256             // 严格匹配
    DATA[32]{?} #[64] EQUAL         //2: 提取32字节的哈希结果
    BOTH PASS                       // 严格匹配
}
OUTPUT BUFDUMP                      // 导出MODEL提取的值，触发外部监听（乙构建 txB 交易）
```


#### 乙方创建的兑换支付脚本

**B链：`txB: b1 => b2`**

```go
// 解锁脚本
// <sig> <pubKey>                       // 系统内置验证
DATA[32]{<hashSource>}                  // 哈希源，甲转移时提供

// 锁定脚本
$TOP                                    // 引用栈顶哈希源存储到局部域
SYS_TIME{Stamp} {<expireTime2>} GT      // 是否过期
IF{                                     // 是：
    MULSIG[1] PASS                      // 由乙签名，通过（赎回）
    EXIT                                // 结束脚本
}                                       // 否：
MULSIG[0]                               // 是否由甲签名
$[0] FN_HASH256                         // 引用哈希源，计算哈希值
DATA{<hashResult>} EQUAL                // 哈希屏障，比较结果
BOTH PASS                               // 前两者都为真时通过（甲转移）

$[0] OUTPUT BUFDUMP                     // 导出哈希源，触发外部监听（乙对 txA 的转移）
```

> **注意：**<br>
> 甲应当先在本机私有的环境下提供解锁参数执行脚本，如果可以成功转移币金，则发布为正式的交易。<br>
> 甲在B链上的币金转移也可能是自动的，但监听 `b2` 收款地址的情况是一种外部行为。<br>


### 备注

这里并不涉及币金兑换的比率问题，只要双方预先约定即可。这里的兑换逻辑存在相互制约，双方无需事先信任。
