## 侧链微支付

### 前言

一条区块链通常会自己创生本链的币金（无中生有），但这并非绝对，以另一条链上的币金为依据，通过某个汇率转换而来也是可行的。如果我们把转换来源的链称为主链，则转换生成币金的链可称为侧链。主链上通过充值提供侧链币金生产的依据，这就是侧链微支付的原理（有点类似第三方支付）。

与传统的法币用于购买商品不同，侧链微支付的粒度是任意的，它可以表达非常宽泛的支付逻辑。实际上，只要涉及价值或信用的传递，粒度任意的微支付就可以有用武之地，比如将阅读量进行价值量化，一个超大的汇率如 `1:1,000,000` 也是可能的。


### 微支付的侧链

微支付系统通常需要足够快的确认时间，一个拥有大量用户的微支付系统会产生规模庞大的数据，因此它可能很难成为一个广域范围的通用系统。这里假定微支付的侧链用于一个局部的微网，比如一个商场、连锁酒店、爱好者俱乐部或者是一个App内容平台。

微支付的侧链可能并不需要是广域的，因为广域的逻辑已经由主链来担当了。主链与侧链之间是一个「充值-铸币」和「提现-销毁」的逻辑。也正因如此，作为优化，一种定期清转历史数据，让侧链轻松上线的「重启」模式是可能的。

#### 区块铸造与铸币的分离

微支付的侧链由主链上的一笔创始交易开启，交易里定义了铸币者身份，由一个不可修改的凭信表达（可能包含汇率配置）。侧链的创始区块里包含了这笔主链上的创始交易，侧链上也有凭信的逻辑，铸币凭信转移可以让铸币者产生变化，所以安全性可以保证。不可变凭信采用引用传递，对铸币者的验证可以定位到创始区块里的创始交易，因此非法的铸币可以很容易辨别。

与普通的区块链不同，侧链里的铸币交易（CoinMake）由铸币者创建而不是由区块的铸造者创建，因此这里的区块铸造和铸币需要分离。当然，区块铸造者（Coinbase）依然拥有收取交易费的权利，而铸币交易就只是一笔特别的交易而已。

逻辑上，微支付的侧链不是去中心化的，因为它存在一个兑换主体，同时也需要担负责任。但侧链的运行可以是去中心化的，激励自由的参与者，可以大幅地节省成本并提高安全性。


### 用例

> **注：**<br>
> 这里不涉及侧链本身的实现细节，只是假定它与主链有相似的能力。<br>

假设存在一个微支付实体MPC，他们用一种代币 `RC` 来鼓励用户对阅读作笔记。当用户发布的笔记被其他用户点赞后，MPC会对赞的情况进行评估和打赏，打赏的介质就是 `RC`。

因为 `RC` 是一种区块链代币，流通是它的基本能力，因此拥有 `RC` 的用户也可以参与到游戏中来，或者打赏，或者用 `RC` 在系统内购买小商品小礼品等。于是，这个阅读系统里便创建出了一个小生态。

为了简化 `RC` 与外部世界的价值沟通，MPC决定采用某流行主链的币金 `PC` 为自己的代币转换源。任何一位用户通过充值 `PC` 兑换成 `RC`，即可进入到这个「互动阅读」微系统里来，而如果想要离开，简单地将 `RC` 提现为主链币金 `PC` 即可。

这里假设 `PC` 与 `RC` 的兑换比率是固定的 `1:10000`。采用标准的「链间兑换」模式实施。

#### 兑换主体

即经营该微系统的实体MPC，他们在主链上拥有接收充值的地址或地址集，在侧链上则为铸币者，以及接收 `RC` 提现并返还主链币金 `PC` 的管理者。这里假设MPC有一个收款地址 `Maddr`，用于收集各充值地址的币金转移。


### 充值兑换

用户充值的目标地址并不是 `Maddr`，每个用户的充值地址都可能不一样，但充值会被转移到目标收款地址。充值用户实际上也可以限定收款地址（通过 `OUT` 指令），但这只能是一种象征性的说明（因为很难同时限定金额）。


#### 主链充值

示意：{UserAddrA} => tmpAddr >> {Maddr}

```go
// 解锁脚本
// <sig> <pubKey>
{<outIndex>}                        // 收款地址所在输出项下标，MPC提供
DATA{<hashSource>}                  // 哈希源，由用户创建

// 锁定脚本
SYS_TIME{Stamp} {<expireTime>} GT   // 是否过期
IF{                                 // 是：
    MULSIG[0] PASS                  // 由用户签名，赎回通过
    EXIT                            // 成功结束
}                                   // 否：
MULSIG[1]                           // 是否由MPC签名
@PEEK[-2] FN_HASH256                // 引用栈顶第2项，计算哈希
DATA{<hashResult>} EQUAL            // 哈希屏障，比较结果
OUT{Receiver} DATA{<Maddr>} EQUAL   // 限定收款地址（OUT实参为栈顶项<outIndex>）

@POPS[3] EVERY PASS                 // 前3项判断都为真时通过（MPC转移）
```

**说明：**
- 哈希结果（hashResult）通过模式匹配提取，侧链兑换中转地址和充值金额通过脚本外方式获取。
- 限定收款地址可以表达一种公开性，但脚本无法提供强制约束力。

**充值模型：**

充值脚本的格式应当符合固定模型，这样中间件才能确定充值最终能够转移出去。这是一个通用结构，可以发布为一笔管理者交易共享。

```go
MODEL<PRINT>{
    SYS_TIME{Stamp} {?} #4 GT           //1: 提取时间戳，用于检查时间长度是否足够
    IF{                                 // if指令，进阶匹配
        MULSIG[0] PASS                  // 严格匹配
        EXIT                            // 严格匹配
    }
    MULSIG[1]                           // 严格匹配
    @PEEK[-2] FN_HASH256                // 严格匹配
    DATA[32]{?} #4 EQUAL                //2: 提取32字节的哈希结果，用于构造侧链兑换交易的相同设置
    OUT{Receiver} DATA[?]{?} #4 EQUAL   //3: 提取收款地址，用于判断地址是否属于自己公布的地址集成员。
    @POPS[3] EVERY PASS                 // 严格匹配
}
@POPS[3] OUTPUT BUFDUMP                 // 导出MODEL提取的值，触发外部逻辑
```

**附：连接和执行**

将充值脚本封装为一个脚本类型数据，连接在模型代码之前运行即可。

```go
CODE{...}   // 充值脚本字节序列前置CODE指令即可作为数据入栈
@POP        // 弹出栈顶项（指令序列）
// 连接模型
// MODEL<>...
```

或者如果充值脚本较长（超出256字节），则可以仅仅只是用一个 `@POPS[]` 连接模型代码即可。

```go
// ...      // 充值脚本
@POPS[]     // 弹出栈内全部条目
// ...      // 模型代码
```


#### 侧链兑换

示意：{铸币者} => tmpAddrB >> {UserAddrB}

```go
// 解锁参数
// <sig> <pubKey>                       // 系统内置验证
<hashSource>                            // 哈希源，用户转移时提供

// 锁定脚本
&TOP                                    // 栈顶哈希源添加到变量域
SYS_TIME{Stamp} {<expireTime2>} GT      // 是否过期
IF{                                     // 是：
    MULSIG[1] PASS                      // 由MPC签名，赎回到一个销毁地址（UTXO友好）
    EXIT                                // 成功结束
}                                       // 否：
MULSIG[0]                               // 是否由用户签名
&{TOP} FN_HASH256                       // 引用哈希源，计算哈希值
DATA{<hashResult>} EQUAL                // 哈希屏障比较结果
BOTH PASS                               // 前两者都为真时通过（用户兑换转移）

&{TOP} OUTPUT BUFDUMP                   // 导出哈希源，便于MPC转移用户的充值
```

> **说明：**
> 侧链用户的兑换脚本无需兑换模型，用户事前预执行成功即可发布交易。


### 提现兑换

用户在侧链中向提现管理者发送侧链币金，同时传递主链提现地址 `withdrawAddr`。因为目标明确，提现交易通常无需赎回，这是一个链间授信的逻辑。管理者接收到提现的币金后，原则上应当销毁它们，转移到销毁地址的交易会触发主链的回兑流程。


#### 侧链提现

示意：{UserAddrB} => adminAddrB

**提现脚本1：**

简单的提现发送。管理者销毁该提现币金时触发主链的返还兑现，币金数量从脚本外获取。

```go
// 解锁参数
// <sig> <pubKey>...    // 系统内置验证，略

// 锁定脚本
DATA{<withdrawAddr>}    // 主链的提现地址
@POP OUTPUT BUFDUMP     // 导出主链地址并触发外部逻辑
```

**提现脚本2：**

提现币金从脚本内获取，这需要脚本匹配一个合格的提现模型，验证币金数量的真实性。

```go
// 解锁参数
// <sig> <pubKey>...    // 系统内置验证，略

// 锁定脚本
IN{Amount}              // 提现的侧链币金数量
DATA{<withdrawAddr>}    // 主链的提现地址

@POPS[2] OUTPUT BUFDUMP // 导出数据并触发外部逻辑
```

**提现模型：**

```go
MODEL<>{                    // 无忽略指令
    IN{Amount}              // 严格匹配，保证数额真实
    DATA[?]{?}              // 主链的提现地址
    @POPS[2] OUTPUT BUFDUMP // 严格匹配
}
// 这里无需采集数据
// 当进行销毁转移时，脚本作为输入被执行。
```


#### 主链兑回

无特别要求，MPC用一笔普通的转账交易发送按汇率计算的主链币金即可。


### 固定汇率下的铸币平衡

理论上，如果按照固定的汇率，用户充值后得到了数额准确的侧链币金，提现时反之亦然。但铸币交易通常也需要支付交易费，而提现后的销毁交易也同样如此。因此，这个微系统实际上会慢慢变相地增发币金。

要解决这个问题，要么对系统进行微调修改，设计铸币和销毁交易无需支付交易费，要么把增发的交易费也同时销毁。通常，后者的解决方式可能更好。


### 浮动汇率下的借贷逻辑

如果不保持固定的兑换汇率，侧链代币可能成为一种股票或私人债券：兑换人实际上是出借主链币金给经营者，并持有其侧链上的凭证，当约定的期限到达后，凭证提现为主链的币金，完成借贷（和获利）的返还。因为代币可以在侧链上流通，这能够带来更多的灵活性。

从长远角度来看，借贷双方实际上都期望主链币价值稳定，如果贷方借出主链币后主链币升值，实际上贷方是不乐意回兑的，这样可以消减主链币的买盘。如果这样的借贷关系大量存在，就会对主链币的价值稳定有正向回馈。

借贷经营的实体通常是中心化的，身份公开已知，会受到现实世界里的监管或约束。
