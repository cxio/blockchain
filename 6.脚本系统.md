# 脚本系统

从更宽泛的意义上看，脚本就是合约，而合约是自由的。

本设计包含了完整的流程控制语法，如：`IF`、`ELSE`、`SWITCH`、`CASE`、`EACH`（有限循环），运算操作符如：`+`、`-`、`*`、`/`，数据类型如：`Bool`、`Int`、`Bytes`、`String`、`Float` 等。总体上，这是一个基本图灵完备的**栈脚本**语言。

在栈脚本中，所有的操作都基于已明确定义指令，没有自定义函数。所以相比于其它语言，栈脚本风险更小，且结构简单，便于审计。


## 基本概念

### 数据栈

存放脚本指令*实参*和*返回值*的一个栈式空间，遵循后进先出（LIFO）的逻辑。脚本指令从数据栈获取实参，返回值则自动入栈。

但这样的栈逻辑存在一个问题：*指令的实参取值严格受到前一指令返回值的约束！*

这使得指令的实参安排十分窘迫，排挤效应严重。指令之间的耦合度要求太高，以至于语言的灵活性很差。所以，下面设计了**实参空间**的机制。

> **实现：**
> 数据栈是一个简单 `[]any` 结构，进入数据栈的具体类型都会自动封装为 `any`。


### 实参空间

实参空间也叫**实参区**，是栈脚本指令实参的腾挪区域，临时存值：*如果指令需要实参，系统会先从该实参区取值，如果无值，再从数据栈取值*。

实参区是一个队列，可以*持续地*向里面添加条目，但取出则是*一次性*的，且保有添加时的顺序。


#### 指令的参数配置

- **`0`**： 无需实参。系统不会读取实参区。
- **`n`**： 固定数量。从实参区取值，如果无值则从数据栈取值。实参区里的条目必须刚好为`n`，一次性取出。
- **`-1`**：不定数量。仅取出实参区条目，不访问数据栈。实参区为空视为零条目，有效。


### 附属参数

对指令本身的描述，紧跟在指令之后。有时也称为**附参**。

比如描述 `IF` 指令的代码块长度：在该指令之后跟随一个整数值，明确说明子代码块长为多少字节。

附参是一种基础设计，它能帮助完整表达指令，类似于指令的*属性*。


#### 附参vs实参

对于部分指令，其需要的参数可能并不那么像*属性*而更像*实参*，但最终它被设计成了附参。

这是因为附参是静态的，它必须跟随在指令之后，不能由解锁数据段动态提供。

为了静态化这些数据，设计为附参是一个更简单和容易的办法。比如 `GOTO`，跳转的目标应当是预设的，不支持由用户动态指定。


### 关联数据

指令关联的内容，比如 `IF{}` 指令的子语句块，值指令 `""` 的字符串，`DATA{}` 所携带的字节序列等。

关联数据是指令除了附参和实参之外，直接拥有或控制的数据。

> **注：**
> 部分值指令的附参即是其关联数据，如整数 `{}(~)`、符文 `''(4)` 等。


### 局部域

一个有限的储值空间。存在于每一个语法块内，与普通的编程语言不同，它只能在当前域访问（块级私有）。

> **附：**
> 另外也有一个全局的储值空间，即全局域。可以从任何一个层级访问。


### 自动展开

部分指令会返回多个值，并且需要系统将它们自动展开到目标位置：栈、实参区、局域等。

这样的指令并不多，主要是为完成特定的功能（如栈操作）。


### 缓存区和外部监听

脚本支持与外部的交互（`INPUT`、`OUTPUT`），导出和导入通过两个缓存区完成，各自独立，互不影响。

交互是非阻塞的：外部注册监听，指令触发驱动，然后中间件处理，完成链外事务。监听是私有的，只有需要的节点才会部署。



## 脚本指令集

### 指令码

每个命名指令都有一个值对应（指令码），脚本就是指令及其数据的**值序列**。

指令码用**1**个字节来表达，因此基础指令集最多不超过**255**个指令。但基础指令里包含了扩展指令本身，逻辑上，它可以扩展出无限的更多可能。

指令集分为如下四个块段：

1. **基础指令段**：包含如流程控制、数学运算、栈操作、模式匹配等功能指令集。码位 `[0-169]`，共 **170** 个。
2. **函数指令段**：包含高频和常用的基础功能函数，以及1个自扩展指令。码位 `[170-209]`，共 **40** 个。
3. **模块指令段**：定义一些基本和标准的模块，以及1个自扩展指令。码位 `[210-249]`，共 **40** 个。
4. **扩展指令段**：专用于指令的扩展引用，包括2个基础扩展和2个私有扩展。码位：`[250-254]`，共 **5** 个。


### 指令命名

根据指令的特性（是什么），划分出如下5大类别：

1. 基础功能。指令名无前缀，视觉简洁。如：`PASS`、`IF`、`TRUE` 等。
2. 系统调用。指令名有前缀 `SYS_`，如：`SYS_TIME{}`、`SYS_AWARD` 等。
3. 功能函数。指令名有前缀 `FN_`，如：`FN_CHECKSIG`、`FN_PUBHASH` 等。
4. 模块引用。指令名有前缀 `MO_`，如：`MO_MATH{}`、`MO_MATH{Abs}`（即 `math.Abs()`）等。
5. 扩展定制。指令名有前缀 `EX_`，如：`EX_INST`、`EX_FN` 等。


### 书写约定

脚本在人工编码或阅读时，需要遵循友好并合理的格式以便于理解。

以下是一些约定：

- `{}` 包围指令的关联数据，比如IF语句的子语句块、值指令的值等。
- `[]` 包含指令附参的值，非必需时可省略。如：`DATA[20]{...}` 可简写为 `DATA{...}`。
- `()` 文档说明中表达指令附参的长度（字节数）。如 `DATA{}(1)` 表示指令的附参为**1**个字节。
- `<>` 表示命名数据，如：`<pubKey>` 指一个公钥，`<sig>` 表示签名数据。

> **注：**
> 链上的脚本已经被编译为指令码值序列，文本只是一种解译。


### 指令类别

从指令的属性（是什么）上看，有如下大的类别区分：

1. **值指令**。脚本中的一个实际的值，会自动入栈。如：`TRUE`、`DATA{...}`。
2. **截取指令**。拦截跟随指令的返回值，将它们放到目标位置。如：`@`、`$`。
3. **栈操作指令**。直接操作数据栈中的条目，如：`PUSH`、`POP`。
4. **集合指令**。对值集合的简单操作，如：`SLICE`、`MERGE`、`SPREAD`、`FILTER`。
5. **交互指令**。与外部的交互，通过两个独立的缓存区完成。指令如：`OUTPUT`、`INPUT`。
6. **结果指令**。表达确定的结果，如通关指令 `PASS`，或跳转指令 `GOTO`，以及 `RETURN` 等。
7. **流程控制**。控制执行流，包含：`IF{}`、`ELSE{}`、`EACH{}`、`BREAK` 等。
8. **转换指令**。值类型转换，包含：`BOOL`、`FLOAT`、`STRING` 等。
9. **运算指令**。简单的数学运算（`+-*/%`），以及其它计算，如：`REP`、`DEL` 等。
10. **比较指令**。比较操作支持，如：`EQUAL`、`GT`、`WITHIN` 等。
11. **逻辑指令**。逻辑操作支持，如：`BOTH`、`EITHER`、`SOME` 等。
12. **模式指令**。检查脚本自身的能力，主要是一些模式匹配测试：`MODEL{...}`、`#`、`_`、`?`、`...` 等。
13. **环境指令**。从环境中获取信息的支持，如：`IN{}`、`OUT{}`、`VAR`。
14. **工具指令**。实用功能的简单支持，如：`EVAL`、`COPY`、`MATCH`、`RANGE`。
15. **系统指令**。系统级的功能支持，如：`SYS_TIME`、`SYS_CHKPASS`。
16. **函数指令**。常用的基础功能函数,如：`FN_PUBHASH`、`FN_CHECKSIG`、`FN_BASE32`。
17. **模块指令**。用于基础模块的扩展，如：`MO_RE`、`MO_TIME`、`MO_MATH`。
18. **扩展指令**。宽泛的通用扩展机制，如：`EX_FN`、`EX_INST` 等。



## 示例

### 币金支付验证

这是一笔标准的单签名币金支付：输入引用资金来源的锁定脚本，自己则提供解锁脚本。

```go
// 解锁脚本：
{1}         // 签名方法（1|2）
<flag>      // 授权标记
<sig>       // 签名数据
<pubKey>    // 公钥

// 锁定脚本：
SYS_CHKPASS // 调用：SYS_CHKPASS(1, <flag>, <sig>, <pubKey>, <Receiver>)
```

**解释：**

1. `{1}`：入栈值 `1`，指明当前为单签名。**栈状态**：`[1]`
2. `<sig>`：入栈签名。**栈状态**：`[1, <sig>]`
3. `<pubKey>`：入栈公钥。**栈状态**：`[1, <sig> <pubKey>]`
4. `SYS_CHKPASS`：系统内置验证：取栈顶3项，另取接收者，执行验证。**栈状态**：`[]`

也即，锁定脚本实际上只需要一个指令：`SYS_CHKPASS`。


### 定制验证

如果用户想要将验证逻辑书写在脚本里，可以像下面这样：

```go
// 解锁脚本：用户即时提供
<sig>       // 签名
<pubKey>    // 公钥

// 锁定脚本：源交易的输出，已固化
TOP FN_PUBHASH DATA{46af3fb4...} EQUAL PASS FN_CHECKSIG PASS
```

**解释：**

1. `<sig>`：签名入栈。**栈状态**：`[<sig>]`
2. `<pubKey>`：公钥入栈。**栈状态**：`[<sig> <pubKey>]`
3. `TOP`：引用栈顶项（不弹出）返回入栈。**栈状态**：`[<sig> <pubKey> <pubKey>]`
4. `FN_PUBHASH`：取栈顶项计算公钥哈希后入栈。**栈状态**：`[<sig> <pubKey> <pubHash>]`
5. `DATA{46af3fb4...}`：预置的公钥哈希序列入栈。**栈状态**：`[<sig> <pubKey> <pubHash> <{46af3fb4...}>]`
6. `EQUAL`：取栈顶2项相等比较，结果（TRUE|FALSE）入栈。**栈状态**：`[<sig> <pubKey> <true|false>]`
7. `PASS`：取栈顶项检查，TRUE时则通过，否则失败。**栈状态**：`[<sig> <pubKey>]`
8. `FN_CHECKSIG`：取栈顶2项（即最初的 `<sig>`, `<pubKey>`），验证签名。结果（TRUE|FALSE）入栈。**栈状态**：`[<true|false>]`
9. `PASS`：取栈顶项检查，TRUE时则通过，否则失败。**栈状态**：`[]`

此时源输出中的的接收者没有验证逻辑，通常用于友好展示。



## 安全性

### 参数限定

区块链是一个开放的系统，恶意的攻击者可能构建十分消耗资源的交易来拖累系统，因此这里需要设置一些限制：

- 数据栈高度：`< 256`。脚本在运行过程中，数据栈内的数据大多会被即时使用，所以容量不需太大。
- 栈数据项大小：`< 1KB`。
- 锁定脚本长度：`< 1KB`。
- 解锁脚本长度：`< 4KB`。
- 单笔交易大小：`< 8KB`。不含解锁部分。
- 输出项数量：`< 2048`。即1字节表达的字节数总位数（256*8）。
- EMBED嵌入次数：`<= 5次`。运行时计数，包括子脚本中的嵌入。
- GOTO跳转深度：`<= 3次`。运行时计数。**参考**：管理者+审计者+第三方。
- GOTO跳转次数：`<= 2次`。运行时计数（仅主脚本中）。
- 区块大小：详见《实现参考》的[*区块限定*](实现参考#区块限定)部分。

脚本的指令序列是顺序执行，不可回退的（没有返回到前端位置的指令），因此一个固定长度的脚本所消耗的资源应当有限。


### 解锁脚本

解锁脚本中可使用的指令是有限制的。不然一个 `TRUE PASS EXIT` 序列就可以花费掉任何一笔输出。

通常可以将解锁脚本描述为解锁数据，因为它们主要由**值**构成。

解锁段可用的指令仅为 *值指令 ~ 交互指令* 区段，即指令码值：`[0 - 49]`。

> **提醒：**
> 考虑效率并避免攻击，在解锁段导入外部脚本（`SCRIPT` 指令）的处理优先级可能较低。



--------------------------------------------------------------------------

上一篇：[信用结构](5.信用结构.md)<br>
下一篇：[脚本基础指令集](7.脚本基础指令集.md)<br>
