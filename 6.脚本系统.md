# 脚本系统

从更宽泛的意义上看，脚本就是合约，而合约是自由的。

本设计包含了完整的流程控制语法，如：`IF`、`ELSE`、`SWITCH`、`CASE`、`EACH`（有限循环），运算操作符如：`+`、`-`、`*`、`/`，数据类型如：`Bool`、`Int`、`Bytes`、`String`、`Float` 等。总体上，这是一个基本图灵完备的**栈脚本**语言。

在栈脚本中，所有的操作都基于已明确定义指令，没有自定义函数。所以相比于其它语言，栈脚本风险更小，且结构简单，便于审计。


## 基本概念

### 数据栈

存放脚本指令入栈数据和*返回值*的一个栈式空间，遵循后进先出（LIFO）的逻辑。脚本指令从数据栈获取*实参*，返回值则可能入栈。

这是常规的栈语言逻辑，实际上存在一个问题：*指令的实参取值严格受到前一指令返回值的约束！*

这让指令的实参安排十分窘迫，严格的顺序导致指令排挤，要求较高的耦合性，让栈脚本的灵活性很差。所以有了**实参空间**的设计。

> **实现：**
> 数据栈是一个简单 `[]any` 结构，进入数据栈的具体类型都会自动转为 `any`。


### 实参空间

实参空间也叫**实参区**，是临时存放指令实参的一个腾挪区域，规则是这样：

*如果指令需要实参，系统会先从该实参区取值，如果无值，再从数据栈取值。*

这样，指令的实参就可以提前取出，让出栈条目位置，避免栈顺序对后续指令的排挤。并且由于实参可以从栈的任意位置获取，指令的安排就可以很灵活了。它解耦了指令的顺序关系。

实参区是一个队列，可以持续地向里面添加条目，但取出则是*一次性*的（简单性考虑）。


#### 指令的参数配置

每个指令需要配置其实参的取值数量：

- **`0`**： 无需实参。系统不会读取实参区。
- **`n`**： 固定数量。从实参区取值，如果无值则从数据栈获取。实参区里的条目数必须匹配（一次性取出）。
- **`-1`**：不定数量。如果实参区有值，则取出，否则取空值。因此不会访问数据栈。


### 附属参数

简称**附参**，主要是对指令本身的描述（静态，类似于属性），紧跟在指令之后。比 `IF` 指令，附参定义了其代码块的长度。

附参是一种基础设计，它能更完整地表达指令（也可能提升效率）。


#### 附参vs实参

对于部分指令，其需要的参数可能并不那么像*属性*而更像*实参*，但最终它被设计成了附参。

这是源于附参静态特性的优势，如果这个参数静态化更好，比如 `GOTO` 指令的跳转目标不应当动态化（安全风险），就需要把它设计为附参。


### 关联数据

指令关联的内容，比如 `IF{}` 指令的子语句块，值指令 `DATA{}` 所携带的字节序列等。

关联数据是指令除了附参和实参之外，直接拥有或控制的数据。


### 局部域

一个有限的储值空间。存在于每一个语法块内，与普通的编程语言不同，它只能在当前域访问（块级私有）。

> **附：**
> 另外也有一个全局域的储值空间，可以从任何位置访问。


### 自动展开

部分指令会有多个返回值，系统会将它们自动展开到目标位置（数据栈、实参区或局部域等）。

> **注：**
> 这样的指令并不多，主要是完成一些特殊操作（如栈操作）。


### 缓存区和外部监听

脚本支持与外部的交互（`INPUT`、`OUTPUT`），导出和导入通过两个缓存区完成，各自独立。

**导出**是非阻塞的：外部注册监听，导出触发驱动，然后中间件负责处理。通常用于完成链外事务。

> **注：**
> 监听是私有的，只有需要的节点才需要去部署。

**导入**是阻塞的：如果缓存区无数据或数据不足，导入会失败但正常退出。这通常用于私有逻辑，因为公共验证节点不会导入任何数据。

> **注：**
> 导入是一个特殊指令，对于公共验证节点是一个隐式的 `END`。



## 脚本指令集

### 指令码

每个指令都有一个值对应（指令码），脚本就是指令及其数据的**值序列**。

指令码用**1**个字节来表达，因此基础指令集最多不超过**255**个指令。但指令集里包含了扩展指令本身，因此逻辑上可以无限扩展。

指令集分为如下四个块段：

1. **基础指令段**：包含如流程控制、数学运算、栈操作、模式匹配等功能指令集。码位 `[0-169]`，共 **170** 个。
2. **函数指令段**：包含高频和常用的基础功能函数，以及1个自扩展指令。码位 `[170-209]`，共 **40** 个。
3. **模块指令段**：定义一些基本和标准的模块，以及1个自扩展指令。码位 `[210-249]`，共 **40** 个。
4. **扩展指令段**：专用于指令的扩展引用，包括2个基础扩展和2个私有扩展。码位：`[250-253]`，共 **4** 个。


### 指令命名

根据指令的特性，划分出了如下5个大类别：

1. 基础功能。指令名无前缀，视觉简洁。如：`PASS`、`IF`、`TRUE` 等。
2. 系统调用。指令名有前缀 `SYS_`，如：`SYS_TIME{}`、`SYS_AWARD` 等。
3. 功能函数。指令名有前缀 `FN_`，如：`FN_CHECKSIG`、`FN_PUBHASH` 等。
4. 模块引用。指令名有前缀 `MO_`，如：`MO_MATH{}`、`MO_MATH{Abs}`（即 `math.Abs()`）等。
5. 扩展定制。指令名有前缀 `EX_`，如：`EX_FN`、`EX_INST` 等。


### 书写约定

脚本在人工编码或阅读时，需要遵循友好的格式。以下是一些约定：

- `{}` 包围指令的关联数据，比如IF语句的子语句块。
- `[]` 包含指令附参的值，非必要时可省略。如：`DATA[20]{...}` 可简写为 `DATA{...}`。
- `()` 文档说明中表达指令附参的长度。如 `DATA{}(1)` 表示指令的附参为1字节。**注**：花括号表示指令有关联数据。
- `<>` 表示命名数据，如：`<pubKey>` 指一个公钥，`<sig>` 表示签名数据。

> **注：**
> 链上的脚本已经被编译为指令值序列，文本是解译后的显示。


### 指令类别

从指令的属性（干什么）上看，有如下的类别区分：

1. **值指令**。脚本中的一个实际的值，会自动入栈。如：`TRUE`、`DATA{...}`。
2. **截取指令**。拦截跟随指令的返回值，将它们放到目标位置。如：`@`、`$`。
3. **栈操作指令**。直接操作数据栈中的条目，如：`PUSH`、`POP`。
4. **集合指令**。对值集合的简单操作，如：`SLICE`、`MERGE`、`SPREAD`、`FILTER`。
5. **交互指令**。与外部的交互，通过两个独立的缓存区完成。指令如：`OUTPUT`、`INPUT`。
6. **结果指令**。表达确定的结果，如通关指令 `PASS`，或跳转指令 `GOTO`，以及 `RETURN` 等。
7. **流程控制**。控制执行流，包含：`IF{}`、`ELSE{}`、`EACH{}`、`BREAK` 等。
8. **转换指令**。值类型转换，包含：`BOOL`、`FLOAT`、`STRING` 等。
9. **运算指令**。简单的数学运算（`+-*/%`），以及其它计算，如：`REP`、`DEL` 等。
10. **比较指令**。比较操作支持，如：`EQUAL`、`GT`、`WITHIN` 等。
11. **逻辑指令**。逻辑操作支持，如：`BOTH`、`EITHER`、`SOME` 等。
12. **模式指令**。检查脚本自身的能力，主要是一些模式匹配测试：`MODEL{...}`、`#`、`_`、`?`、`...` 等。
13. **环境指令**。从环境中获取信息的支持，如：`IN{}`、`OUT{}`、`VAR`。
14. **工具指令**。实用功能的简单支持，如：`EVAL`、`COPY`、`MATCH`、`RANGE`。
15. **系统指令**。系统级的功能支持，如：`SYS_TIME`、`SYS_CHKPASS`。
16. **函数指令**。常用的基础功能函数,如：`FN_PUBHASH`、`FN_CHECKSIG`、`FN_BASE32`。
17. **模块指令**。用于基础模块的扩展，如：`MO_RE`、`MO_TIME`、`MO_MATH`。
18. **扩展指令**。宽泛的通用扩展机制，如：`EX_FN`、`EX_INST` 等。



## 脚本的执行

脚本的执行是一个线性的过程，从脚本的起始位置开始，逐条解释指令并执行，直到脚本结束或遇到终止指令（如 `EXIT`）。

在执行的过程中，脚本本身是只读的，不能被修改。


### 例：币金支付验证

这是一笔标准的单签名币金支付。

输入引用资金来源的锁定脚本，用户（花费者）需要提供解锁脚本。

```go
// 解锁脚本：
{1}         // 签名方法（1|2）
<flag>      // 授权标记
<sig>       // 签名数据
<pubKey>    // 公钥

// 锁定脚本：
SYS_CHKPASS // 实际会调用：SYS_CHKPASS(1, <flag>, <sig>, <pubKey>, <Receiver>)
```

**解释：**
1. `{1}`：自动入栈值1，指明当前为单签名。**栈状态**：`[1]`
2. `<sig>`：自动入栈签名。**栈状态**：`[1, <sig>]`
3. `<pubKey>`：自动入栈公钥。**栈状态**：`[1, <sig> <pubKey>]`
4. `SYS_CHKPASS`：系统内置验证：取栈顶3项，另取接收者，执行验证。**栈状态**：`[]`

> **注：**
> 与Bitcoin中的脚本不同，本设计便捷的内置验证。


### 例：定制验证

如果用户想要将验证逻辑书写在脚本里，也可以像下面这样：

```go
// 解锁脚本：
<sig>               // 签名入栈
<pubKey>            // 公钥入栈

// 锁定脚本：
TOP                 // 引用栈顶项（不弹出）返回入栈
FN_PUBHASH          // 取栈顶项计算公钥哈希后入栈
DATA{46af3fb4...}   // 预置的公钥哈希序列入栈
EQUAL               // 取栈顶2项相等比较，结果（TRUE|FALSE）入栈
PASS                // 取栈顶项检查，TRUE时则通过，否则失败
FN_CHECKSIG         // 取栈顶2项（即最初的 <sig>, <pubKey>），验证签名。结果（TRUE|FALSE）入栈
PASS                // 取栈顶项检查，TRUE时则通过，否则失败
```

> **注：**
> 此时来源输出中的的接收者被忽略，但可用于友好展示。



## 安全性

### 参数限定

区块链是一个开放的系统，恶意的攻击者可能构建十分消耗资源的交易，因此这里需要设置一些限制：

- 数据栈高度：`< 256`。脚本在运行过程中，数据栈内的数据大多会被即时使用，所以容量不需太大。
- 栈数据项大小：`< 1KB`。
- 锁定脚本长度：`< 1KB`。
- 解锁脚本长度：`< 4KB`。不含标准签名数据。
- 单笔交易大小：`< 400KB`。不含解锁部分。
- 输出项数量：`< 1024`。即单字节7位表达的字节数总位数（128*8）。
- EMBED嵌入次数：`<= 4次`。运行时计数。
- EMBED嵌入深度：`== 0`。即嵌入的脚本不可再有嵌入（`EMBED`）和跳转（`GOTO`）。
- GOTO跳转次数：`<= 2次`。顶层主脚本，运行时计数。
- GOTO跳转深度：`<= 3次`。运行时计数。**参考**：管理者+审计者+第三方。
- 区块大小：详见「实现参考.md」的 *区块限定* 部分。

脚本的指令序列是顺序执行的，不可回退（没有返回到前端位置的指令），因此一个固定长度的脚本所消耗的资源应当有限。


### 解锁脚本

解锁脚本中可以使用的指令是有限制的，它被严格限制在指令码值 `[0-49]` 的区段，即：值指令、截取指令、栈操作指令、集合指令和交互指令等。这是为了保证解锁脚本的安全性和可审计性，避免过于复杂的逻辑导致安全风险。

> **注：**
> 如果没有限制，一个 `TRUE PASS EXIT` 序列能做任何事。

通常，解锁脚本会被描述为解锁数据，因为它们主要由*值*构成。但解锁数据还包括载入环境而非数据栈的签名相关数据（使用系统内置验证时）。

> **提醒：**
> 在解锁段导入外部脚本（`SCRIPT`）的逻辑，可能导致交易校验优先级降低。



--------------------------------------------------------------------------

上一篇：[信用结构](5.信用结构.md)<br>
下一篇：[脚本基础指令集](7.脚本基础指令集.md)<br>
