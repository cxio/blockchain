# 信用结构

交易是信用表达和转移的一个封装，主要包含输入和输出两个部分。输入为信用的来源，由另一笔交易的输出定义，输出为信用的内容和受体。

输出内容里有一个锁定脚本。如果要使用该输出，用户需要提供该脚本的解锁数据。

> **注：**
> 下文中的代码仅借用Go语言代码的友好显示。


## 三种基本信元

本设计中，信用由三个概念表达：**币金**、**凭信**、**存证**。它们统称为「信元」。

1. **币金**：可拆分的数值，类似货币。也称为代币。
2. **凭信**：不可拆分的数据，可以是文本或二进制私有格式。表达契约、债券或数字凭证的逻辑。可转移。
3. **存证**：一种存在性表达。不可拆分，也不可转移。

如果一笔交易里全是币金，就是一笔纯粹的转账交易。如果还包含有凭信或存证，则是一笔混合交易。

仅仅包含凭信或存证的交易逻辑上没有问题，但交易上链需要交易费，因此币金输入是不可避免的。


### 币金

表达具体的价值额度，如货币或金钱，有时也被称为代币。

币金可以分割、合并或算术运算，其原始创建（无中生有）由区块的铸造者完成，即铸币。


#### 接收者

接收币金的主体，有时也称为区块链账号。

如果脚本采用系统内置的验证，接收者需要是标准格式地址，这由固定的规则构造而来：

- **单签名** 的公钥哈希地址。
- **多签名** 的复合哈希地址（见后详述）。

> **注：**
> 出于隐私保护，两种地址在外观上没有区别。

系统支持一个特殊的 `null` 地址，表示支付到null（空），即销毁。null地址的输出不再进入UTXO集。

用户也可以在脚本中自行设计验证逻辑，此时接收者任意（<256字节）。


#### 金额

一个变长整数值，表达币金的数量，最小币金单位（`chx`）。


#### 附言

支持简短的附言表达对转账的描述，最多 `255` 字节，可选。


#### 锁定脚本

控制当前输出对应的币金。如果用户提供的解锁脚本正确，则该输出可以被花费。

> **说明：**
> 锁定脚本其实表达了交易构造者对未来花费者的约束。
> 脚本可以很灵活，因此约束功能会很丰富。下面凭信和存证的脚本同样如此。


### 凭信

表达一种信用和凭证，可以转让。文本或二进制数据，不可拆分，但转移时可能允许修订。

凭信的转移类似于币金的**花费**逻辑，未转移的凭信也存在于 `UTXO` 集中。任何人都可以创建凭信，就像普通的交易一样。


#### 接收者

与币金的接收者逻辑相同，通常为一个可验证的目标。


#### 创建者

凭信的创建者（<256字节）或创建者引用。

创建者**引用**可方便地追溯最初的创建者，这也是检索初始凭信本身的依据。


#### 配置

包含2字节的配置。

```go
15] 新建标记。初始的凭空创建。
14] 可否修改。允许修订描述。创建者、标题和附件ID不可变。
13] 是否修改。如果输入源可修改且被修改，此位置位。
12] （未用）
11] 转移计次。表示后面跟随转移次数限定。2字节长，递减。
10] 有效期限。表示后面跟随有效期限定。4字节长，单位：秒，从交易时间戳开始。
[10] 低10位定义描述内容长度（<1k）。
```

转移次数和有效期可同时存在，以先到为准。到期后凭信会从UTXO集中移除，逻辑上类似于下面的存证。


#### 标题

凭信的标题，通常应当是人类可阅读的文本（<256字节）。


#### 描述

凭信的简要描述，通常可阅读。最长支持到 `1k` 字节量。


#### 附件ID（可选）

凭信支持附件，不限制大小。

附件将由数据网络存储和提供检索，交易中只包含一个附件ID（<256字节，包含结构）。这是对区块链空间局限的解耦。


#### 锁定脚本

限制凭信转移的一段代码。与币金相似，用户转移时需提供正确的解锁脚本。


### 存证

表达一种存在性。可引用但不可转移，任何人都可创建。

存证用途可能很多，如原始版权声明、证书存储（供公开检索）、子链存根、话题索引……或作为第三方应用的起始凭证等。


#### 创建者

存证的创建者（<256字节），可以为空。


#### 标题

存证的标题（<256字节）。表达存证是什么，通常人类可读。


#### 内容

存证的具体内容，通常为文本格式。由前置的 `2` 字节指定内容长度。

```go
 15] （未定义）
 14] （未定义）
 13] （未定义）
 12] （未定义）
 11] （未定义）
[11] 低11位记录内容长度（字节数），最大支持到2KB。
```

#### 附件ID（可选）

复杂的存证通常需要附件增强说明。与凭信相同，附件数据存储于外部数据网络。


#### 识别脚本

用于程序化识别和处理。

因为存证不可转移，所以不能作为新交易的输入项。但可以成为输出脚本的一部分，供第三方识别客户端使用。



## 输入项

输入项是交易信用的来源。

一笔交易中可以包含多个输入项，每一个输入项是另一笔交易未花费的输出（UTXO）。输入项需要被验证，以证明交易的构造者拥有它。

验证采用解锁脚本的方式：*解锁脚本 + 锁定脚本 => 如果整个脚本执行成功，则验证通过*。

> **提示：**
> 作为一个轻客户端，节点需要先获取区块链的当前UTXO集。
> 当前UTXO集可以通过UTXO指纹验证，而UTXO指纹则通过区块头链来验证。


### 输入项定位

输入项由**3~4**个字段完成定位：`年度`、`交易ID`、`输出序位`，以及凭信转移专有的 `转出序位`。

- **年度**：一个大尺度的分区。主要为方便管理，由区块的时间戳计算而来。
- **交易ID**：交易数据的哈希结果。完整交易ID全长48字节，考虑空间利用率，仅首笔输入需用全长，其余20字节即可。
- **输出序位**：来源交易中输出项在输出集里的序位（从0开始）。

另外，如果是凭信输入，**转出序位**引用其转移条目所在的位置（本交易输出集里），用于合法性检查。


### UTXO集合

所有已确认交易的未花费输出构成了UTXO集合，它确定于上一个区块。

在本设计中，一个未确认交易的输出不属于UTXO，即便它合法，因为未确认的交易可能被替换或过期失效。同时，这也是组队校验对交易独立性的要求。

试图构建一个*链式的*未确认支付序列是不可能的，只有头部第一笔交易会被验证和广播，其余被丢弃。



## 输出项

接受币金支付或凭信转移的目标（目的地）。

一笔交易中可以有多个输出项。对于币金交易来说，可能包含一个收款者和一个找零地址。对于凭信转移交易，则逻辑上只有一个接收者。

每一笔*输出*包含该信元类型的相关条目（见前信元定义）。


### 配置

输出项包含**1**字节的配置。高4位为位标记，低4位为类型值。

```go
 7] 自定义类：置位时余下7位为类ID长度计数。
 6] 包含附件：声明是否携带附件，如果自定义类置位，此位变义。
 5] 销毁标记：主要用于币金和凭信。
 4] （未用）
[4] 类型说明：低4位值。
    0) 预留：无意义。
    1) 币金：输出为币金支付。可以作为输入源。
    2) 凭信：输出为凭信（新建或转移）。可以作为输入源。
    3) 存证：输出为存证，不能作为输入源。
    4) 介管：声明为接收前阶脚本跳转或嵌入的中间脚本。
```

如果希望销毁币金，或终止凭信的转移能力，可以设置销毁标记。此时输出的币金或凭信会从UTXO集中移除。**注**：币金的差额部分依然作为交易费。


#### 介管脚本

脚本允许在交易间跳转。因此这创建了一个*中介*的逻辑。

接收跳转的目标交易的输出脚本就是介管脚本，这是一种特定的类型，不能作为交易里的输入项，只能在脚本中通过跳转指令（如 `GOTO`）引用。

介管的存在，使得可以插入监管逻辑，比如一笔先期建立的财务监听脚本，可以接收企业支付脚本的*途经*路过……获取必要的信息，然后……

> **注：**
> 出于性能和安全考虑，一个脚本中连续跳转的行为有次数限制。


#### 自定义类

用户可以创建专属的私有脚本，此即自定义类。

自定义类输出脚本中通常会包含私有的扩展指令，它们无法被公共的客户端理解，因此也不能作为输入源（UTXO）。自定义类是私有应用借助于公共网络传递信息的机制，这也是通用公共网络携带更多价值的体现之一。

最长127字节的私有标识ID，为这些专属客户端识别自己提供锚定。



## 签名

对输出项的*拥有权*通常通过签名来证明。这也是系统内置验证的标准方式。

签名可以是简单的**单签名**模式，仅由一个私钥对应。也可以是汇合多个私钥证明的复合**多重签名**结构。


### 单签名

仅需由单一私钥对交易进行的签名。

这是大多数输入项验证的实际情况，转账或凭信转移只是个体与个体之间的事，或者仅需由单个私钥去控制。


### 多重签名

需由多个私钥共同对交易进行的签名，有时简称为*多签*。

多签支持 `M-Of-N` 的工作机制，以增强社会化的安全性和灵活性。

- N：总共需要的私钥数量（参与方的公钥总数）。
- M：实际需要签名授权的最少私钥数量（M ≤ N）。如：`2-of-3` 多签地址表示有3个私钥，任何2个私钥签名即可。

> **注：**
> 内置验证对单签名或多重签名的判断由解锁数据指明。


#### 多重签名的地址

构造流程：

1. 对N个公钥各自执行哈希运算得到N个公钥哈希：`PKH1 = Hash( pubKey1 )`, `PKH2 = Hash( pubKey2 )`, ……
2. 各公钥哈希有序串连，再前置 `m/N` 配比，计算复合公钥哈希：`PKHs = Hash( <m/N> + PKH1 + PKH2 + ... )`。
3. 复合公钥哈希（`PKHs`）编码为文本形式，即为多重签名的账户地址。

> **说明：**
> `m/N` 配比为 `1+1` 两个字节，因此最多支持 `255/255` 的组合规模。

每一位参与者只需提供自己的公钥哈希（而非公钥），这会更安全。在外观上，多签地址与普通地址也没有区别（隐私安全）。

另外，这种安全性可能让参与者更自由，比如匿名参与会更容易。


#### 多重签名的验证

解锁数据：

- **签名集**：`m/N` 中 `m` 个私钥对交易的签名。
- **公钥集**：上面 `m` 个签名对应的公钥序列。
- **补全集**：未参与签名的公钥的哈希（`N-m` 个）。

> **注：**
> 组合配比 `m/N` 可由公钥集大小和补全集大小计算而来。

验证过程：

0. 计算 `m/N` 配比。
1. 计算公钥集里各个公钥的哈希。
2. 结果集与补全集里的哈希混合排序、串连，前置 `m/N` 配比，计算复合公钥哈希。
3. 对比接收者的公钥哈希与上面计算的结果，相同时有效。
4. 验证签名集里的各个签名。


### 签名消息

通过对签名消息的不同约束，签名授权可以有多种模式。


#### 授权种类

由**1**个字节配置签名消息的约束针对：

```go
// 独项：
7] SIGIN_ALL    全部输入项
6] SIGIN_SELF   当前输入项（自身）
// 主项：
5] SIGOUT_ALL   全部输出项：币金、凭信、存证
4] SIGOUT_SELF  与当前输入项同序位的输出项
// 辅项：
// 需配合 SIGOUT_SELF | SIGOUT_ALL 使用。
0] SIGRECEIVER  输出的接收者。
1] SIGCONTENT   输出项的内容：币金「数量/附言」；凭信「创建者/配置/标题/描述/附件ID」。
2] SIGSCRIPT    输出项的脚本。
3] SIGOUTPUT    输出项完整条目（接收者+内容+脚本）。
```

**说明：**

- 「独项」逻辑自完整。可独立设置，也可与其它设置合并使用，如：`SIGIN_ALL|SIGOUT_SELF|SIGOUTPUT`，全部输入项和当前同序位输出项完整条目。
- 「主项」不能独立设置，需与辅项配合。如：`SIGOUT_ALL|SIGRECEIVER`，针对全部输出项的接收者（仅输出部分）。
- 「辅项」需与主项配合使用。如：`SIGIN_SELF|SIGOUT_SELF|SIGOUTPUT`，针对当前输入项和同序位输出项的完整条目。

> **提示：**
> 最常见的配置：`SIGIN_ALL|SIGOUT_ALL|SIGOUTPUT`，全部输入项和全部输出项完整数据。



## 附：公钥哈希的地址编码

将公钥哈希采用某种规则编码为可读的文本形式，即为公钥地址。


### 编码

0. 公钥哈希添加识别前缀，即“前缀 + 公钥哈希”。
1. 执行哈希运算，取末尾4字节为 **校验码**。
2. 在公钥哈希之后附上校验码（*此时无前缀*），编码为文本序列。
3. 附上识别前缀，即“前缀 + 文本序列”即为公钥地址。

> **注：**
> 文本编码可能采用高效的 `Base32` 编码算法（有修改）。


### 校验

0. 提取前缀和文本序列。
1. 将文本序列解码为字节序列。截取末尾4字节校验码，前段即为公钥哈希。
2. 公钥哈希前置识别前缀（即“前缀 + 公钥哈希”），执行哈希运算取末尾4字节为校验码。
3. 比较两个校验码，相同则通过。



--------------------------------------------------------------------------

上一篇：[激励机制](4.激励机制.md)<br>
下一篇：[脚本系统](6.脚本系统.md)<br>
