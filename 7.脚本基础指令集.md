# 脚本基础指令集

**原则**：脚本在执行过程中应当是只读的，这需要在实现中注意！

> 下面的代码并非Go语言，仅为高亮友好借鉴。


## 1. 值指令

作为一个具体的值存在，直接自动入栈。

区间：`[0-19]`，20个。

```go
码值    指令字      说明
-----------------------------------------------------------
0       NIL         空：nil
        // 通用的nil项，表示无值。

// 以下为基本类型。

1       TRUE        真值：true
2       FALSE       假值：false
        // 类型：Bool
        // TRUE：编译时解码为1，运行时为true。
        // FALSE: 编译时解码为2，运行时为false。
        // 提示：
        // 交易中的脚本为编译后的码值&数据序列。

// 以下指令包含附参。

3       ''(1)       字节：byte [0, 255]
        // 类型：Byte
        // 附参：关联的字节值。
        // 即uint8的别名，可用于小正整数计算。
        // 例：
        // 'A'      单引号包围字符（A，值65）。
        // '\n'     支持转义表达（换行符，值10）。
        // '\x41'   支持16进制转义（A）。
        //
        // 支持花括号创建值集：
        // {'A', 'B'}   一个字母集 ['A', 'B'] // []Byte

4       ''(4)       符文：rune [0, 0x10FFFF]
        // 类型：Rune
        // 附参：关联的Unicode码点值。
        // 例：
        // '嗨'     单引号包围的Unicode字符。
        // '\u4e16' 支持'\uhhhh'或'\Uhhhhhhhh'转义（世）。
        // '\u0041' 字符A用Rune类型存储。
        //
        // 创建值集：
        // {'你', '好'} 一个符文集 ['你', '好'] // []Rune
        // 注：
        // 序列中有任何一个值不能用字节表示，即全为符文。

5       {}(~)       整数：int64 [-1<<63, 1<<63 - 1]
        // 类型：Int
        // 附参：关联的整数值。变长存储。
        // 支持值序列构造为值集。
        // 例：
        // {12345}  整数值 12345
        // {123_45} 同上，支持单下划线友好分割。
        // 例：
        // {10, 30} 一个整数集：[10, 20] // []Int
        // {100, }  一个单成员值集：[100]，注意跟随的逗号。
        //
        // 设计：
        // 不是采用直接的数字而是用一个花括号来包围，
        // 是希望指令有明确的边界，体现栈脚本「指令序列」的观感。

6       {}(~)       大整数：big.Int
        // 类型：BigInt
        // 附参：关联的大整数占用的字节数。
        // 也即Go语言中 math/big 包里的Int类型。
        // 例：
        // {0x8000ffff_8000ffff_8001}
        // 超出了int64的表示范围，即被解析为大整数。
        // 例：
        // {0x8000ffff_8000ffff_8001, 0xffff}
        // 一个大整数集：[0x8000ffff_8000ffff_8001, 0xffff] // []*big.Int
        // 注：
        // 通常用十六进制书写，依然支持下划线友好分隔。
        // 值序列中，只要有一个是大整数，就会构造为大整数值集。

7       {}(8)       浮点数：float64
        // 类型：Float
        // 附参：关联的浮点数值。
        // 例：
        // {3.14159}    浮点数值 3.14159
        // {2.16e10}    支持科学计数法。
        // {123.}       浮点数值 123.0，注意末尾的点。
        // 例：
        // {3.14, 5}    一个浮点数集：[3.14, 5.0] // []Float
        // 注：
        // 需包含小数点以与整数区分，支持科学记数法。
        // 值序列中，只要有一个是浮点数，就都会视为浮点数。

8       ""(1)       小文本：string [0, 255]
9       ""(2)       长文本：string [256, 65535]
        // 类型：String
        // 附参：字符串的字节数（UTF-8）。
        // 文本为UTF-8编码，依长度自动决定使用哪个指令。
        // 例：
        // "Hello world"    双引号包围的简单字符串。
        // "Hello\nWorld"   支持转义表达（同Go语言）。
        // `Hello\nworld`    反引号包含，字符串原始表达，无转义（同Go）。
        // 提示：
        // 附参的大小自动计算，不需要人为指定。
        //
        // 创建字符串集：
        // {"Hello", "World"}   一个字符串集 ["Hello", "World"] // []String

// 以下为复合类型。

10      {...}(~)    值集：[...]
        // 创建值集。
        // 即上面通过 {1, 2, 3} 形式创建的序列。
        // 附参：值成员序列的长度。
        // 支持的类型：
        // - Bool
        // - Byte
        // - Rune
        // - Int
        // - *BigInt
        // - Float
        // - String
        // 注意：
        // 值序列需要类型一致，或至少是可提升的，
        // 运行时会将所有的值成员统一为最大的类型：
        // - Byte => Rune => Int => BigInt
        // - Byte => Rune => Int => Float
        // 其中：
        // 浮点数和字符串之上没有更大的类型，因此不可再提升。
        // 例：
        // {2, 4, 8}    // 创建一个整数值集
        // {}           // 错误，缺乏类型表达
        //
        // 设计：
        // 值类型的提升在运行时发生而不是编译为指令码时。

11      DATA{}(1)   小数据：[]byte [0, 255]
12      DATA{}(2)   长数据：[]byte [256, 65535]
        // 类型：Bytes
        // 附参：数据的长度（字节数）。
        // 默认为十六进制（无前置0x）表达，数据长度自动决定对应哪个指令。
        // 例：
        // DATA{46af3fb4}       自动计算为4字节数据。
        // DATA[8]{46af3fb4}    明确8字节长，后续空位以0填充。

13      /.../(1)    正则表达式：RE2
        // 类型：RegExp
        // 附参：内容字节数（<256）。
        // 双斜线之内即为正则表达式的内容。
        // RE2: github.com/google/re2/wiki/Syntax
        // 例：
        // /(?i)[a-z0-9]+/  匹配ASCII字母和数字，忽略大小写
        // /(?i)Zip-(\d+)/  忽略大小写，包含一个子匹配（捕获组）
        //
        // 设计：
        // 仅支持最长255字节的表达式，应已足够。

14       DATE{}(~)   时间对象
        // 类型：Time
        // 附参：UNIX时间戳（毫秒数），有符号变长整数。
        // 支持花括号内书写时间表达式（RFC3339）。
        // 例：
        // DATE{2020-11-24T15:04:05Z}
        // DATE{2020-11-24T15:04:05.456+08:00}
        // 注：
        // 仅支持RFC3339标准格式（更多参考 MO_TIME）。

15-16   （未用）


17      CODE{}(~)   代码/指令序列
        // 类型：Script
        // 附参：所包含序列的长度。
        // 实际的序列为已编译的脚本「指令码+附参+关联数据」。
        // 例：
        // CODE{
        //      TOP FN_HASH256 DATA{<hashResult>} EQUAL PASS
        // }
        // 这是一段哈希屏障的验证序列。
        //
        // 安全性：
        // 序列中的指令仅为字面值数据，不会被执行。
        // 主要用于配合EVAL使用，为第三方扩展提供一种执行逻辑。

18      SCRIPT(~,48,~)  脚本嵌入
        // 类型：Script
        // 附参1：交易年度（按所在区块）。
        // 附参2：交易ID
        // 附参3：脚本所在输出项序位
        // 引入交易的输出脚本。
        // 与CODE类似，应当配合EVAL的第三方使用。
        // 例：
        //      SCRIPT[2025, 0xab93cf..., 0] FN_HASH256 ...
        // 引入2025年的 0xab93cf...交易的第一项输出脚本入栈，
        // 计算脚本的哈希……
        //
        // 提示：
        // 可能主要用于引用存证交易的识别脚本。

19      GETVAL{}(1)     获取某值
        // 通用的取值指令。
        // 附参：值标识/索引。
        // 可用于某些环境信息（与ENV有重叠）或其它信息的获取。
        // 花括号内可使用值名称书写。
        //
        // 设计：
        // 为了在解锁区使用某些必要的值，单列设计出来。
        // 它是通用的，也可用于未来（量子计算）可能需要的前置求值。
```



## 2. 截取指令

拦截指令的返回值，或从目标位置取值或赋值。

这是栈脚本的基础功能指令，指令名用特殊符号表达以方便与目标指令结合。作为一种友好，符号与后面的目标指令无需空格分开。

本系列指令功能独特，取值时直接放入实参区（而非自动入栈）。

区间：`[20-24]`，5个。

```go
码值    指令字      说明
-----------------------------------------------------------
20      @           实参捕获
        // 拦截后一个指令的返回值，放入实参区。
        // 例：
        // @PEEKS[2]    获取栈底2个值展开到实参区。
        // @{1234}      将整数 1234 放入实参区（本来会自动入栈）。

21      ~           实参直取
        // 指示后一个指令的实参将从数据栈直接提取（跳过实参区）。
        // 这是一种主动的取值渠道切换。
        // 如果目标指令同时也前置了拦截（@|$），则本指令应当在拦截指令之后，目标指令之前。
        // 例：
        // ~EQUAL   直接取栈顶两个值作相等比较。
        // @~EQUAL  同上取栈顶两个值比较，结果放入实参区。
        // $~EQUAL  同上，但结果放入局部域。
        //
        // 设计：
        // 支持跳过实参空间直取，可为数据的腾挪增添更多灵活。

22      $           局域存值
        // 截取后一个指令的返回值，添加到当前局部域中。
        // 局部域是一个当前块的静态堆叠空间（只添加），容量128。
        // 例：
        // $TOP         引用栈顶项添加到当前局部域（引用复制）。
        // $POPS[3]     弹出栈顶3项展开到局部域中（添加了3项）。
        // ${100}       将值 100 直接添加到局部域。
        // $SHIFT[3]    取出栈顶3项打包为一个切片，添加到局部域（共1项）。
        // 注意：
        // 局部域是语法块私有的。
        // 不同局部域之间无法互通，只有同级指令才共享其局部域。

23      $(1)        局域取值（引用）
        // 引用局部域的值，放入实参区。
        // 需与上面的存值指令配合使用。
        // 附参：成员位置下标。
        // 下标范围：[-128, 127]，支持负数从末尾算起。
        // 例：
        // $[0]     引用第1个添加进局部域中的值。
        // $[-1]    引用最后一个添加到局部的值。
        //
        // 实现：
        // 可能支持用存值时所截取指令的名称来引用（有重名覆盖问题）。
        // 如：
        // ${POP}   引用 $POP 存入的值。

24      $X(1)       循环域变量引用
        // 用于循环体内，可跨语法块层级（与局域不同）。
        // 引用的变量值依然放入实参区，这与 @ 和 $[n] 的行为一致。
        // 附参：变量标识 [0-3]。
        // 用名称引用：
        // $Value       当前条目值 [0]
        // $Index|$Key  当前循环键（整数下标或字符串键） [1]
        // $Slice|$Dict 目标集本身 [2]
        // $Size        集合大小（成员数） [3]
        // 注：
        // 名称大小写敏感，前置$字符。
        // 提示：
        // 循环目标包括切片（$Slice）和字典（$Dict），
        // 前者的键为数值（$Index），后者的键为字符串（$Key）。
```

> **小结：**
> 除了局域存值（`$`）和实参直取（`~`）外，另3个指令都为取值。



## 3. 栈操作指令

对数据栈中的条目直接进行操作：入栈、出栈、引用、转移等。通常会配合截取指令（`@`、`$`）使用。

区间：`[25-35]`，11个。

```go
码值    指令字      说明
-----------------------------------------------------------
25      NOP         无操作
        // 实参：不定数量。
        // 无任何操作，但会读取实参区（清空）。
        // 返回值：无。
        // 例：
        // @SHIFT[] NOP 提取数据栈全部，然后读取（清空）。
        // @SHIFT NOP   同上。零值附参可省略中括号。
        // @POP NOP     移除栈顶项。
        //
        // 设计：
        // 不定数量实参包含0个，因此无需访问数据栈。

26      PUSH        数据入栈
        // 把实参区成员顺序压入数据栈。
        // 如果实参区为空，这就只是一个空操作（无意义）。
        // 实参：不定数量。
        // 返回值：无。
        // 例：
        // $[0] $[1] $[2] PUSH  将局部域3个值压入到数据栈。
        // @PEEK @INPUT PUSH    提取栈底项和输入缓冲区数据，压入数据栈。


// 以下指令返回多项时，原样展开。

27      POP         弹出栈顶项
        // 返回值：栈顶项。
        // 通常前置截取指令使用，否则返回值重新入栈无意义。
        // 例：
        // @POP     弹出栈顶项到实参区。
        // $POP     弹出栈顶项添加到当前局部域。
        // POP      无意义。

28      POPS(1)     弹出栈顶多项
        // 附参：弹出的条目数（<256）。0表示全部。
        // 如果条目数超出栈高度，执行会失败（严格约束）。
        // 返回值：原始序列。
        // 例：
        // @POPS[4] 弹出栈顶4项添加到实参区。
        // $POPS    弹出栈内全部条目添加到当前局部域。
        // POPS[4]  无意义。

29      TOP         引用栈顶项
        // 返回值：栈顶项。
        // 类似POP，通常结合截取指令使用，但无前置截取也有意义。
        // 例：
        // @TOP 引用栈顶项到实参区（浅复制）。
        // $TOP 引用栈顶项添加到当前局部域。
        // TOP  引用栈顶项，返回值自动入栈（复制了一份）。

30      TOPS(1)     引用栈顶多项
        // 附参：引用条目数（<256）。0表示全部。
        // 如果条目数超出栈高度，执行会失败（严格约束）。
        // 返回值：原始序列。
        // 例：
        // $TOPS[3] 引用栈顶3项，逐一添加到当前局部域。
        // @TOPS[]  引用栈内全部条目，添加到实参区。
        // @TOPS    同上。
        //
        // 提示：
        // 与后面运算指令 REP 的区别：
        // REP[n]   取出栈顶1项复制n次，展开入栈。
        // TOP[n]   引用栈顶n项（原样复制1次），展开入栈。


// 以下2指令由实参指定位置。
// 注：自动展开能力依旧。

31      PEEK        引用栈内任意位置条目
        // 实参：目标位置。可选，默认0值（栈底）。
        // 返回值：目标项。
        // 说明：
        // 从栈底开始计算，支持负数从栈顶算起。
        // 例：
        // PEEK         引用栈底项，自动入栈（克隆栈底项到栈顶）。
        // @{0} PEEK    同上引用，明确位置。
        // @PEEK        同上引用，添加到实参区。
        // @{-1} PEEK   引用栈顶项，自动入栈（同 TOP）。

32      PEEKS(1)    引用栈内任意位置段条目
        // 附参：引用条目数。0表示目标位置之后全部。
        // 实参：起始位置。可选，默认0值。
        // 返回值：条目序列。
        // 说明：
        // 从栈底开始计数，支持负值从栈顶算起。
        // 如果位置下标超出栈高度，或实际数量不足，执行会失败。
        // 例：
        // @PEEKS[5]        引用栈底5项数据展开到实参区。
        // @{1} @PEEKS[2]   从第二项开始引用栈底2项，展开到实参区。
        // PEEKS[5]         引用栈底5项展开入栈（克隆栈底5项到栈顶）。


// 以下指令返回一个切片（无自动展开）。

33      SHIFT(1)    移出栈顶条目
        // 移出栈顶目标数量的条目。
        // 附参：条目数（<256），0表示全部。
        // 如果条目数超出栈高度，执行会失败（严格）。
        // 返回值：一个切片。
        // 例：
        // @SHIFT[4]    移出栈顶4项，打包为一个切片放入实参区。
        // $SHIFT[4]    同上但添加到当前局部域。
        // SHIFT[0]     移出栈内全部条目，封装为一个切片入栈。
        // SHIFT        同上。

34      CLONE(1)    克隆栈顶条目
        // 克隆栈顶目标数量的条目（浅复制）。
        // 附参：条目数（<256），0表示全部。
        // 返回值：一个切片。
        // 例：
        // @CLONE[3]    克隆栈顶3项，打包为一个切片放到实参区。
        // $CLONE[3]    同上克隆，但添加到当前局部域。
        // CLONE[3]     克隆栈顶3项打包为一个切片入栈。
        // CLONE        克隆栈内全部条目，打包为一个切片入栈。


// 以下指令由实参指定位置。

35      VIEW(1)     引用栈条目
        // 附参：引用条目数。0值表示目标位置之后全部。
        // 实参：起始位置。可选，默认0值。
        // 返回值：一个Any切片。
        // 说明：
        // 从栈底开始计算，支持负值从栈顶算起。
        // 如果位置下标超出栈高度，或实际数量不足，执行会失败。
        // 例：
        // @VIEW[5]     引用栈底5项打包为一个切片，放入实参区。
        // VIEW[5]      引用栈底5项打包为一个切片入栈。
        // @{-5} VIEW   引用栈顶5项打包为一个切片入栈，同 CLONE[5]
```



## 4. 集合指令

支持可迭代集合（切片或字典）的一些基本操作。

> **安全性：**
> 源脚本应当只读，所以需要注意有写入逻辑的指令应当在一个副本上操作。

区间：`[36-45]`，10个。

```go
码值    指令字      说明
-----------------------------------------------------------
36      SLICE(1)    子切片
        // 从目标切片创建一个子切片。
        // 注意是在原切片上截取引用，创建副本应使用COPY。
        // 附参：子切片大小（<256），0表示目标位置后全部。
        // 实参1：目标切片。
        // 实参2：起始下标（从0开始），支持负数从末尾算起。
        // 返回值：一个子切片。
        // 例：
        // 假设目标集：[1, 2, 3, 4, 5, 6, 7, 8]
        //      {2} SILCE[3]    // [3, 4, 5]
        //      {-4} SLICE[2]   // [5, 6]
        //      {-3} SLICE      // [6, 7, 8]
        //      {8} SLICE       // [] 空切片
        // 注意：
        // 指令遵循严格模式，如果位置或数量溢出，执行会失败。

37      REVERSE     反转（切片）
        // 将切片内的成员反转排列。
        // 实参：目标切片。
        // 返回值：反转后的新切片。
        // 例：
        // {1, 2, 3, 4, 5}
        // REVERSE  // [5, 4, 3, 2, 1]

38      MERGE       合并（切片）
        // 将多个切片合并为一个切片。
        // 实参：不定数量。
        // 返回值：一个新切片。
        // 例：
        // {1, 2, 3}
        // {10, 20}
        // @POP @POP MERGE  // [10, 20, 1, 2, 3]

39      EXTEND      扩充（切片）
        // 向目标切片内添加成员。
        // 实参：不定数量，首个为目标集，其余为待添加成员。
        // 返回值： 一个新切片。
        // 例：
        // {1, 2, 3}
        // {10} {20}
        // @POPS[3] EXTEND  // [1, 2, 3, 10, 20]

40      PACK        封装（压实打包）
        // 将切片成员解码串接在一起。
        // 压实打包，成员之间底层数据紧密集成。
        // 实参：一个切片。
        // 返回值：一个字节序列。
        // 例：
        // POPS[3] PACK 将栈顶3项数据解码打包为一体。
        // 注：
        // 成员可以是多种类型混杂，会解码到基础类型串接。

41      SPREAD      展开（切片）
        // 将目标切片展开，成员提升。
        // 如果前置取值指令，会展开添加到目标空间。
        // 实参：一个切片。
        // 返回值：不定数量成员。
        // 例：
        // $SPREAD  将目标集展开添加到当前局部域。
        // @SPREAD  将目标集展开添加到实参区。
        // SPREAD   将栈顶项展开后逐个入栈（维持原顺序）。
        // 提示：
        // 连续的 @~SPREAD 可将栈内多个切片逐一展开到实参区。

42      SET         设置（字典）
        // 设置字典（map[string]any）的键值对应。
        // 实参1：目标字典。
        // 实参2：键名或键名集（[]string）。
        // 实参3：目标值或值集。
        // 返回值：原目标字典。
        // 说明：
        // 如果键为一个字符串（键名），则值任意。
        // 如果键为一个清单，同时值也是一个清单，则一一对应赋值，
        // 否则同一个值对应全部键名。
        //
        // 设计：
        // 字典并不是栈脚本中的主要集合类型，
        // 但在转换指令系中，支持由两个切片创建字典，以提供某些方便。

43      ITEM        条目（字典）
        // 获取集合中的成员或成员集。
        // 实参1：目标字典。
        // 实参2：成员键或键集。
        // 返回值：值或值集。
        // 说明：
        // 如果键名对应的条目不存在，会取到一个默认零值（nil）。
        // 如果键名是一个集合，则返回一个值集。
        // 例：
        // "AAA" ITEM           获取目标集内 AAA 对应的值。
        // {"AA", "BB"} ITEM    获取目标集内 AA 和 BB 的值。

44      INDEX       成员（切片）
        // 获取目标切片的成员或成员集。
        // 实参1：目标切片。
        // 实参2：位置下标或下标集。
        // 返回值：值或值集。
        // 说明：
        // 切片的数值下标支持负数从末尾算起。
        // 如果位置是一个下标集，则返回一个值集。
        // 例：
        // {1} INDEX    取切片中的第二个成员
        // {1, 3} INDEX 取切片中第二和第四个成员。
        //
        // 设计：
        // 主要用于取切片中单个值或不连续位置的值。

45      SIZE        大小（切片|字典）
        // 获取集合的大小。
        // 实参：一个集合。
        // 返回值：一个整数。
```



## 5. 交互指令

脚本与外部的交互通过「缓存区」实现。

缓存区是一个先进先出（FIFO）的队列，从头部取数据。导入和导出各自独立。

区间：`[46-49]`，4个。

```go
码值    指令字      说明
-----------------------------------------------------------
46      INPUT(1)    导入
        // 从缓存区导入数据。
        // 如果缓存区无值或数量不足，执行失败但正常退出。
        // 附参：读取的条目数，0值表示全部。
        // 实参：无。
        // 返回值：不定数量。自动展开到目标位置。
        // 例：
        // @INPUT       导入缓存区全部数据展开到实参区。
        // INPUT[3]     导入缓存取头部3项数据，展开入栈。
        // @INPUT NOP   清空缓存区。
        //
        // 设计：
        // 导入失败按正常退出对待，通关状态有效。
        // 因此前面若已正常通关，此处的失败并不影响通过性。
        //
        // 这种宽容友好公共验证，因为公共验证节点不会导入任何数据。
        // 这是隐式的包含了前置的END逻辑。
        //
        // 这是失败但正常退出的唯一特例。

47      OUTPUT      导出
        // 把实参区的数据导出到缓存区，维持原始顺序。
        // 实参：不定数量。
        // 例：
        // @POPS OUTPUT 数据栈全部内容导出
        // ... OUTPUT   若实参区为空，导出0项数据

48      BUFDUMP(1)  数据转出
        // 将OUTPUT的缓存区内容转出（清空），无阻塞操作。
        // 附参：标识值。
        // 标识由用户定义，可用于标记数据转出点的位置。
        // 接收者可能需要这样的信息。
        // 实参：无。
        // 例：
        // @POPS[3] OUTPUT BUFDUMP
        // 弹出栈顶3项数据到实参区 => 导出到缓存区 => 转出清空
        //
        // 注：
        // 外部需要注册处理器。
        // 处理器是第三方私有逻辑，只有需要的节点才用部署。

49      PRINT       打印（控制台）
        // 输出实参区的内容到控制台。
        // 实参：不定数量。
        // 例：
        // @TOP PRINT       打印栈顶项
        // @POPS[3] PRINT   打印栈顶3项数据
        // 注：
        // 即调用 fmt.Println()，用默认的格式打印。
```



## 6. 结果指令

会产生决定性的结果，比如*通关*检查、脚本*跳转*或函数*返回*等。

区间：`[50-56]`，7个。

```go
码值    指令字      说明
----------------------------------------------------------
50      PASS        通关（安检）
        // 实参为true时通过，设置通关状态，继续。
        // 实参为false时通关失败，结束脚本。
        // 实参：布尔值。
        // 返回值：无。
        // 提示：
        // 多个PASS类似于“And" 的逻辑，每一个都需成功。
        //
        // 实现：
        // 通关失败可能触发某种通知机制，以便外部了解情况。

51      CHECK       检查（安检）
        // 实参为true时通过，为false时标记失败。
        // 与PASS相同的通关检查，但失败不会退出。
        // 实参：布尔值。
        // 返回值：无。
        // 注意：
        // 通关状态会被后续的CHECK覆盖，因此实际上取决于最后一个CHECK。
        // 这有点类似于“Or”的逻辑。
        //
        // 设计：
        // 在正常结束脚本时，系统会检查通关状态来判定是否通过。

52      GOTO(~,48,~)    跳转（独立）
        // 跳转到某个交易的输出脚本。
        // - 实参区数据传递到新脚本作为数据栈初始内容。
        // - 新脚本延续当前的校验，但有其自身的环境（数据栈、实参区、全局变量区），
        //   但共享导入/导出缓存区。
        // - 新脚本中的通关状态也为当前脚本的通过状态。
        // 附参1：交易年度（按所在区块）
        // 附参2：交易ID
        // 附参3：输出项序位。
        // 实参：不定数量。
        // 返回值：无。
        // 例：
        //      @POPS[5] GOTO[2025, 0xab93cf..., 1]
        // 提取栈顶5项数据，
        // 跳转到2025年的 0xab93cf...交易的第2项输出，传递实参为其数据栈初始内容。

53      EMBED(~,48,~)   嵌入（合并）
        // 嵌入某个交易的输出脚本。
        // 目标脚本为合并逻辑，共享当前的脚本域（数据栈、实参区、全局变量区）。
        // 附参1：交易年度（按所在区块）
        // 附参2：交易ID
        // 附参3：输出项序位。
        // 实参：无。
        // 返回值：无。
        // 例：
        //      EMBED[2030, 0xab93cf..., 0] FN_HASH256 DATA{...} ...
        // 嵌入并执行目标脚本，
        // 之后取栈顶值计算哈希摘要（FN_HASH256）……
        // 注意：
        // 是取脚本执行，而不是取脚本作为数据。
        // 因此目标脚本可能已向当前数据栈中添加了内容。

54      EXIT        结束脚本
        // 脚本至此被终止执行并退出。
        // 退出前，系统会检查通关状态以判断验证是否通过。
        // 实参：任意单值，可选。
        // 返回值：即实参值。
        // 如果实参区有值，返回该值（到系统，可能会被处理）。
        // 如果实参区无值，则仅简单结束。
        // 注：
        // 本指令通常出现在IF语句块内，但在顶层也可使用。

55      RETURN      函数返回
        // 从函数子块中退出，并返回一个值。
        // 仅用于函数式语句块 MAP{} 和 FILTER{} 中，退出当前迭代。
        // 实参：任意单值，可选。
        // 返回值：即实参值，无实参时返回nil。

56      END         公共验证结束
        // 公共验证逻辑结束，脚本退出。
        // 仅限于公共验证节点，其它私有用途的节点会忽略它。
        // 通常，后续会有OUTPUT，导出数据触发私有业务。
        // 注：
        // 对公共验证节点来说，该指令类似于EXIT（会检查通关状态）。
        //
        // 例：定向加密：
        // - 交易者A先发布自己的公钥到链上。
        // - 交易者B用A的公钥创建共享密钥，加密数据后连同自己的公钥一并发布。
        // - 交易者A用B的公钥重构共享密钥，解密数据。
        // 解释：
        // 这种数据仅对交易者A有意义，因此需及时结束公共验证。
        //
        // 设计：
        // 私有处理需要借助于公共发布（开放式监听），才能触及自由的私有节点。
        // 私有处理需要包含公共验证的逻辑，然后进阶处理自己的业务。
```



## 7. 流程控制

指令的子语句块即为指令的关联数据。本系列指令无返回值。

区间：`[57-66]`，10个。

```go
码值    指令字      说明
-----------------------------------------------------------
57      IF{}(~)     如果
        // 如果实参为true，则子语句块执行。
        // 附参：子语句块长度。
        // 实参：布尔值。
        // 例：
        // IF {
        //      @POP PRINT  // 提取栈顶项并打印
        // }
        // 说明：
        // IF的条件由实参表达，在指令之前已经就绪。
        // 同一层级中，后来的IF会覆盖先前的IF（的状态）。

58      ELSE{}(~)   如果不满足
        // 检查本层级IF状态，如果IF为假则执行。
        // 附参：子语句块长度。
        // 实参：无。
        // 提示：
        // ELSE只匹配最近的一个IF。
        // IF和ELSE并不需要紧邻，中间可有其它指令序列。
        // 例：
        // IF {
        //      ...
        // }
        // @POP PRINT   // 不影响 IF/ELSE 的关系
        // ELSE {
        //      ...
        // }
        // 例：
        // IF {...}
        // IF {...}     // 覆盖前一个IF的状态
        // ELSE {       // 匹配第二个IF
        //      ...
        // }

59      SWITCH{}(~) 分支选择区
        // 创建 switch 语法块。
        // 附参：语句块长度。
        // 实参1：标的值。将与CASE分支值对比，任意可比较类型。
        // 实参2：CASE分支值列表，长度应与CASE数量相同。
        // 提示：
        // 若标的值为true，可模拟 if/elseif/else 的逻辑。
        //
        // 设计：
        // 一次性给出对比目标和全部分支的候选值序列，
        // 可以使得CASE分支简洁清晰。

60      CASE{}(~)   条件分支
        // 附参：子语句块长度。
        // 实参：无。
        // 实参已被预先提取，按位置顺序对比：
        // - 真：执行子语句块。
        // - 假：跳过子语句块。
        // 说明：
        // 只有最先匹配的CASE块会被执行，之后SWITCH结束。
        // CASE块中也可以用BREAK主动退出。
        // 例：
        // {10}             // SWITCH 标的值
        // {3, 10, 20}      // CASE 分支对比值序列
        // SWITCH {
        //      CASE{       // [0] 与标的值比较，相等则执行
        //          ...
        //      }
        //      CASE{...}   // [1] 与标的值比较……此例中相等、执行
        //      CASE{...}   // 不会到此，上一CASE已经执行并退出
        //      DEFAULT{    // 默认分支：
        //          ...     // 所有CASE比较为假时执行
        //      }
        // }
        // 提示：
        // CASE之间实际上也可以有其它指令，但不常用。

61      DEFAULT{}(~)    默认分支
        // 所有CASE比较为假时执行，作为最后一个语句块，可选。
        // 附参：子语句块长度。
        // 实参：无。

62      EACH{}(~)   迭代（有限循环）
        // 对集合成员逐一迭代、执行子语句块。
        // 与集合指令中的 MAP/FILTER 不同，这里没有私有数据栈逻辑。
        // 附参：子语句块长度。
        // 实参：目标集（切片|字典）。
        // 循环变量：
        // 参考前截取指令 $X
        // - $Value
        // - $Index|$Key
        // - $Slice|$Dict
        // - $Size
        // 注：
        // 如果要中断当前循环，应执行 BREAK 而不是 RETURN。
        // 例：
        // {1, 3, 5}
        // EACH{
        //      ($Value * 10)   // 表达式运算，结果入栈
        // }
        // @SHIFT[3] PRINT      // [10, 30, 50]
        //
        // 例：
        // {10, 20, 30}
        // EACH {
        //      $Value PUSH     // 入栈当前条目值
        // }
        // 这相当于将一个整数序列展开入栈，
        // 即：
        // {10, 20, 30} SPREAD  // {10} {20} {30}

63      CONTINUE    继续
        // 终止当前EACH{}循环并开始下一迭代。
        // 实参：布尔值，可选。
        // 如果实参有值，则真值执行。否则直接执行。

64      BREAK       中断
        // 退出EACH循环或SWITCH分支选择区。
        // 实参：布尔值，可选。
        // 如果实参有值，则真值执行。否则直接执行。
        // 例：
        // {1, 3, 30, 5}        // 迭代目标集
        // EACH{
        //      $Value {10} GT  // 入栈当前值和10，比较两者
        //      @POP BREAK      // 取比较结果，真时退出
        //      @$Index PRINT   // 打印当前序号
        // }
        // @"Done!" PRINT
        //
        // 结果：
        // 0        // $Value = 1
        // 1        // $Value = 3
        // Done!

65      （未用）

66      BLOCK{}(~)  块域
        // 创建一个子块。
        // 主要是为了创建局部域或分离出一个指令序列的范围，
        // 比如规划局部变量使用，或用 SOURCE 提取脚本的局部片段等。
        // 附参：子语句块长度。
        // 实参：无。
        // 例：
        // BLOCK{
        //      ......      // 正常执行
        //      SOURCE      // 提取当前块指令序列（含SOURCE）入栈
        // }
        // @POP PRINT       // 打印 BLOCK 区隔出的指令序列
        //
        // 提示：
        // 如果不是因为需要，在脚本中使用和不使用BLOCK没有区别。
```

> #### 关于 EACH
> EACH主要表达一种循环而非集合，因此块内支持 `BREAK` 而非 `RETURN`。



## 8. 转换指令

将数据转换为不同的*类型*和*值*。注意不只是类型的变化，底层的值也可能会改变。

> **设计：**
> 考虑安全性，不提供转换到脚本类型（`Script`）。
> 基本类型之间可互为转换，与复合类型之间部分可互为转换。

区间：`[67-79]`，13个。

```go
码值    指令字      说明
-----------------------------------------------------------
67      BOOL        转为布尔值：Bool
        // 实参：
        // - 空值：     nil => false
        // - 字节：     0   => false
        // - 符文：     0   => false
        // - 整数：     0   => false
        // - 大整数：   0   => false
        // - 浮点数：   x <= math.SmallestNonzeroFloat64 => false
        // - 字符串：   ""  => false
        // 以上非转换到假值的，即为真。如 1 => true
        // 提示：
        // 测试字典或切片是否非空："SIZE BOOL"。

68      BYTE        转为字节：Byte
        // 实参：
        // - 空值：     nil => 0
        // - 布尔值：   false => 0, true => 1
        // - 符文：     Unicode码值小于256的正常转换，否则出错
        // - 整数：     小于256的值正常转换，否则出错
        // - 大整数：   同上规则
        // - 浮点数：   取整，小于256的值可转换，否则出错
        // 注：
        // 不支持和字符串之间的转换。

69      RUNE        转为符文：Rune
        // 实参：
        // - 空值：     nil => 0
        // - 布尔值：   false => 0, true => 1
        // - 字节：     直接类型转换，值不变
        // - 整数：     不大于 0x10FFFF 时正常转换，否则出错
        // - 大整数：   同上规则
        // - 浮点数：   先取整，同上整数转换规则。
        // 注：
        // 不支持和字符串之间的转换。

70      INT         转为整数：Int
        // 实参：
        // - 空值：     nil => 0
        // - 布尔值：   false => 0, true => 1
        // - 字节：     简单类型转换，值不变
        // - 符文：     简单类型转换，值不变
        // - 大整数：   不大于 1<<63-1 的值正常转换，否则出错
        // - 浮点数：   截断小数部分，同上规则转换
        //
        // 便捷支持：
        // - 时间：     提取Unix时间戳（毫秒数）。
        // - 字符串：   支持Golang合法的整数表示：
        //              普通十进制
        //              0b|0B 二进制
        //              0o|0O 八进制
        //              0x|0X 十六进制
        //              数字之间支持单下划线友好分隔。
        // 注：
        // 字符串按字面意义理解（strconv规则）。

71      BIGINT      转为大整数：BigInt
        // 实参：
        // - 空值：     nil => BigInt(0)
        // - 布尔值：   false => 0, true => 1
        // - 字节：     简单类型转换，值不变
        // - 符文：     简单类型转换，值不变
        // - 整数：     简单类型转换，值不变
        //
        // 便捷支持：
        // - 字节序列： 按大端序转换（math/big）

72      FLOAT       转为浮点数：Float
        // 实参：
        // - 空值：     nil => 0.0
        // - 布尔值：   false => 0.0, true => 1.0
        // - 字节：     简单类型整数
        // - 符文：     简单类型整数
        // - 整数：     简单类型转换
        //
        // 便捷支持：
        // - 字符串：   合法的浮点数或科学记数法表示。

73      STRING(1){} 转为字符串：String
        // 附参：进制或格式标识。
        // 2 ~ 36
        // 进制数，适用于整数类型：
        // 如 STRING[16]，转换为16进制字符串表示。注：方括号包围。
        //
        // b, e, E, f, g, G, x, X
        // 浮点格式，适用于浮点数：
        // 如 STRING{E}，转换为带指数的字符串表示。注：花括号包围。
        //
        // 实参：
        // - 空值：     nil => ""
        // - 布尔值：   true => "true"; false => "false"
        // - 字节：     视为UTF-8编码字节，显示合法字符或16进制表示
        // - 符文：     视为Unicode码点值，显示合法字符或 \uhhhh|\Uhhhhhhhh 形式
        // - 整数：     由附参进制标识转换（strconv）
        // - 大整数：   由附参进制标识转换
        // - 浮点数：   由附参格式标识转换
        //
        // 便捷支持：
        // - 字节序列： 视为UTF-8编码的字节序列，显示结果
        // - 符文序列： 自动UTF-8编码（[]rune => string）

74      BYTES       转为字节序列：Bytes
        // 实参：
        // - 空值：     nil => []byte（空切片）
        // - 符文：     按UTF-8编码转换
        // - 整数：     按大端序转换，固定为8字节长
        // - 大整数：   按大端序转换，长度不定
        //
        // 便捷支持：
        // - 字符串：   即字符串按UTF-8编码
        // - 符文序列： 同上按UTF-8编码
        // - 脚本：     克隆源字节序列，类型转换
        // 注：
        // 考虑安全性，不支持反向的字节序列转脚本。

75      RUNES       转为符文序列：[]Rune
        // 特例：转为符文切片可方便某些处理。
        // 实参：
        // - 空值：     nil => []rune（空切片）
        // - 符文：     封装为一个符文的切片
        // - 字符串：   视为UTF-8解码为 []rune
        // - 字节序列： 视为UTF-8解码，无效码解为\uFFFD

76      TIME        转为时间对象：Time
        // 实参：
        // - 整数：     视为UNIX时间戳（毫秒数）
        // - 字符串：   需为 RFC3339 的标准格式
        // 例：
        // {1608883593536} TIME
        // 即 DATE{2020-12-25T08:06:33.536Z}
        // 例：
        // "2020-12-25T08:06:33.536+08:00" TIME
        // 即 DATE{2020-12-25T08:06:33.536+08:00}

77      REGEXP      转为正则表达式：RegExp
        // 即用实参值构造一个正则表达式对象。
        // 实参：字符串。
        // 仅支持从字符串转换，且字符串需形式合法。

78      DICT        构造字典：Dict（map[string]any）
        // 实参1：键序列（[]string）
        // 实参2：值序列（[]any）
        // 两个实参序列的成员按顺序对应创建一个字典：
        // - 键序列大于值序列时，不足部分为nil值。
        // - 键序列小于值序列时，多出的部分被忽略。
        // 例：
        // {"one", "two" "123"}
        // {100} {200} NIL {1.0}
        // DICT
        // 创建为：{
        //      "one": 100,
        //      "two": 200,
        //      "123": <nil>,   // 多余的 1.0 被忽略
        // }
        //
        // 设计：
        // 字典不是栈脚本的基础类型，因此不支持通过值指令创建。、
        // 但作为一个有效的工具，在此简单支持。

79      ANYS(1){}   切片间转换（[]any <=> []T）
        // 具体类型的切片转换为 []any，或反之。
        // 附参：转换标识。
        // 实参：目标切片或一个nil。
        // 标识：
        // => []any
        // 0:   NIL|[]xxx   => []any
        // []any =>
        // 1|2  NIL|[]any   => []Bool
        // 3:   NIL|[]any   => []Byte   // 同 Bytes
        // 4:   NIL|[]any   => []Rune
        // 5:   NIL|[]any   => []Int
        // 6:   NIL|[]any   => []*big.Int
        // 7:   NIL|[]any   => []Float
        // 8|9: NIL|[]any   => []String
        // 提示：
        // 一个NIL可以转换为任意一种空切片。
        // 一个空的any切片可以转为任意一种具体类型的空切片。
        // 友好：
        // 除零外，标识值实际上是该类型值指令的码值。
        // 支持用花括号包围成员类型名表达标识。
        // 例：
        // NIL ANYS     // 创建一个Any空切片。
        // {1,3,5} ANYS // []Int => []any
        // 例：
        // "AB" "XY" SHIFT[2] ANYS[8]       // []any => []String
        // "AB" "XY" SHIFT[2] ANYS{String}  // []any => []String
        // 提示：
        // 压入栈的每个成员都为any类型。
        // 例：
        // {0} NIL TRUE SHIFT[3] ANYS{Bool}
        // => [false, false, true]
        // 三个成员会自动转为布尔类型。
        //
        // 注记：
        // DICT的成员为any，因此有时需要把具体类型的值集转为[]any。
```



## 9. 运算指令

有两种形式的运算指令：

1. 符号指令。用符号表达，操作数在符号两侧，如：`(POP + 100)`。
2. 命名指令。有名称的指令，操作数作为实参在指令之前，如：`{100} {10} ADD`。

其中符号指令用于表达式内，命名指令则在表达式内外皆可用。

区间：`[80-103]`，24个。

```go
码值    指令字      说明
-----------------------------------------------------------
80      ()(1)       表达式封装、分组
        // 构造一个独立的运算单元，内部可含子表达式和普通指令。
        // - 普通指令可正常地取值和计算，但返回值是一个操作数，不会自动入栈也不能被截取（@, $）。
        // - 子表达式是一个优先级分组，返回值也只是一个操作数，参与运算。
        // 附参：表达式长度。
        // 实参：无。
        // 返回值：一个浮点数。
        // 规则：
        // - 数值类指令书写时无需包围花括号，就像在其它语言中的形式一样。
        // - 内部的数值会被转换到Float(float64)统一计算。
        // - 顶层表达式的返回值会自动入栈或被截取，就像一个普通指令。
        // 例：
        // ( POP + 100 )        取栈顶值，加 100
        // ((POP + $[0]) * 10)  可含子表达式，从栈顶和局域取值
        // @( POP + 100 )       顶层表达式的结果被捕获到实参区
        //
        // 设计：
        // 附参为1字节长而非变长整数，是为了限制表达式的复杂性。
        // 表达式内只有“取值+运算”的逻辑，而没有存入（栈|局域）逻辑。


// 符号指令：
// 单/双操作数，仅用于表达式内部。
81      *           乘
82      /           除
83      %           模
84      +           加，单/双操作数
85      -           减，单/双操作数
        // 例：
        // 单操作数：( -100 )
        // 双操作数：( 100 + POP * 1.5 )


// 命名指令

// 双实参：
// 支持 Int/Float 类型，返回同类型。
86      MUL         乘：MUL(x, y) => x*y
87      DIV         除：DIV(x, y) => x/y
88      ADD         加：ADD(x, y) => x+y
        // 增强：
        // - 支持 String、Bytes 的连接。
        // - 支持 Dict（map[string]any）的合并。
        // 例：
        // "Hello" "World" ADD  // "HelloWorld"

89      SUB         减：SUB(x, y) => x-y
90      MOD         模：MOD(x, y) => x%y, math.Mod(x, y)
91      POW         幂：POW(x, y) => math.Pow(x, y)
        // 例：
        // {2} {8} POW      // 256
        // {2.0} {8} POW    // 256.0
        // ( 100 + POW )    // 其中 POW 从表达式外取实参（不直观）

// 双实参：
// 支持 Int 类型，返回同类型。
92      LMOV        左移位：LMOV(x, y)  => x<<y
93      RMOV        右移位：RMOV(x, y)  => x>>y
94      AND         位与：AND(x, y)     => x&y
95      ANDX        位清空：ANDX(x, y)  => x&^y
96      OR          位或：OR(x, y)      => x|y
97      XOR         位异或：XOR(x, y)   => x^y

// 单实参：
98      NEG         取负：-x    // Int, Float
99      NOT         取反：!v    // Bool
        // 例：
        // PEEK NEG     // 取栈底项，返回其负数


// 准计算指令
// 以下指令非为严格的计算逻辑，但归入简单运算。
// 注：不可用于表达式内。

100     DIVMOD      除并求余：DIVMOD(x, y) => x/y, x%y
        // 实参1：支持 Int/Float
        // 实参2：支持 Int/Float
        // 返回值：2个，自动展开到目标空间。

101     REP(1)      重复
        // 复制目标数据为多项（重复）。
        // 附参：重复的份数。
        // 实参：目标项。
        // 返回值：重复的条目序列。
        // 会自动展开到接受域（数据栈|实参区|局部域）。
        // 例：
        // REP[1]   取出栈顶项重复1份，没有意义。
        // REP[2]   取出栈顶项重复2份。效果同 TOP。
        // REP      取出栈顶项，但零重复。
        //          相当于移除栈顶项，外观上违反直觉，需留意！
        // REP[3]   这才开始有意义……
        // 注：
        // 适用任意类型，但仅为浅复制。

102     DEL         删除
        // 删除字典（map[string]any）内的某个条目。
        // 实参1：目标集。
        // 实参2：键名（字符串）或键名序列。
        // 返回值：原目标集引用。
        // 例：
        // "abc" DEL        // 移除目标字典内的 abc 项
        // {"A", "B"} DEL   // 移除目标字典内的 A、B 两项

103     CLEAR       清空
        // 将字典内容清空。
        // 实参：目标字典。
        // 返回值：原目标（已空）。
```



## 10. 比较指令

两个或多个值执行比较，返回一个布尔值。

注意：相等比较也适用于浮点数，但应慎用。请参考后面工具指令里的 `COMFLO`。

区间：`[104-111]`，8个。

```go
码值    指令字      说明
-----------------------------------------------------------
104     EQUAL       相等（a == b）
105     NEQUAL      不相等（a != b）
106     LT          小于（a < b）
107     LTE         小于等于（a <= b）
108     GT          大于（a > b）
109     GTE         大于等于（a >= b）
        // 实参1：可比较的值。
        // 实参2：可比较的值。
        // 返回值：布尔值（true|false）。
        // 注：
        // 特别支持字节序列，按从左到右逐字节对比。
        // 布尔类型比较仅适用于 `EQUAL, NEQUAL`。

110     ISNAN       是否非数字
        // 实参：任意值。
        // 仅适用浮点类型，由 math.IsNaN(...) 判断。
        // 注记：
        // 因为浮点数计算中可能出现 NaN，故此支持。

111     WITHIN      范围判断（min <= x < max）
        // 实参1：待比较值。
        // 实参2：范围定义（2成员切片）。
        // 例：
        // ENV{Height} {0, 240} WITHIN
        // 交易所在区块是否为首日创建（每天创建·240个区块）
        // 支持类型：
        // - 字节（Byte）
        // - 符文（Rune）
        // - 整数（Int）
        // - 大整数（BigInt）
        // - 浮点数（Float）
        // 注意：
        // 如果是浮点数，下边界的相等判断可能不精确。
```


## 11. 逻辑指令

实参为布尔类型，返回值也是一个布尔值（`true|false`）。

区间：`[112-115]`，4个。

```go
码值    指令字      说明
-----------------------------------------------------------
112     BOTH        两个都为真（&&）
        // 逻辑AND，是否两个值都为true。
        // 实参1：一个布尔值。
        // 实参2：一个布尔值。
        // 返回值：布尔值。
        // 例：
        // BOTH PASS    取栈顶两个值，都为真时通过。

113     EITHER      两个中任一为真（||）
        // 逻辑OR，两者中是否其一为true。
        // 实参1：一个布尔值。
        // 实参2：一个布尔值。
        // 返回值：布尔值。
        // 例：
        // EITHER PASS  取栈顶两个值，任一为真即通过。

114     EVERY       全部为真（&&）
        // 逻辑AND，是否全部成员都为true。
        // 实参：一个布尔值集合。
        // 集合成员可以是布尔值或其any封装，否则应先调用ANYS{Bool}。
        // 返回值：布尔值。
        // 例：
        // SHIFT[3] ANYS[1] EVERY
        // 栈顶3项打包，转换为布尔值集，检查是否都为true。
        // 例：
        // NIL ANYS[1] EVERY            // 空集返回true
        // TRUE FALSE SHIFT[2] EVERY    // 可直接判断（无需先转换）

115     SOME(1)     部分为真（||, &&）
        // 逻辑OR，全部成员中至少n个为true。
        // 附参：n，为真的最低数量。
        // 实参：一个布尔值集合。
        // 返回值：布尔值。
        // 例：
        // SHIFT[3] SOME[2]     // 至少2个为真即为真
        // ... SOME[1]          // 至少1个为真即为真，常用
        // ... SOME[0]          // 无条件为真
        // NIL ANYS[1] SOME[1]  // 空集返回false
```


## 12. 模式指令

对脚本进行模式匹配，以验证其是否符合特定的逻辑（形式化验证）。在匹配的过程中，可以提取信息。

模式匹配很有用，比如在链间兑换时确认对方的预支付脚本是否有效，或者中间件匹配测试提取信息，完成某些无人审核的自动化流程等。

模式匹配可以让你在具体的行动前得到某种预期性的确认。

> **注：**
> 拥有广泛共识的脚本（逻辑流）可以被预先发布作为 `GOTO` 或 `EMBED` 的目标。

区间：`[116-127]`，12个。

```go
码值    指令字          说明
-----------------------------------------------------------
116     MODEL{}(2)      创建模式匹配区
        // 开启一个解析子环境，对目标脚本执行模式匹配。
        // 附参：子块代码长度。
        // 实参：待测试的目标序列（Script|Bytes）。
        // 返回值：有两种情况：
        // - 无取值时：布尔值。表达模式是否成功匹配。
        // - 有取值时：切片, 布尔值。返回两个值，首个成员为取值的值集。
        // 说明：
        // 返回两个值时会自动展开到目标区。
        // 模式内是否有取值，在代码中很明确，因此并无不确定。
        // 实现：
        // 作为一种优化，模式内是否有取值的状态会标记在附参最高位，
        // 因此子块代码最大仅支持32kb（15位）。
        // 例：
        // CODE {
        //      TOP FN_PUBHASH
        //      DATA{<hashResult>}
        //      EQUAL PASS
        //      FN_CHECKSIG PASS
        // }
        //
        // 有取值时：
        // MODEL{
        //      TOP FN_PUBHASH      // 严格匹配
        //      DATA[32]{?}         // 内容任意，但长度32字节
        //      #[64]               // 取 DATA{} 关联数据
        //      EQUAL PASS          // 严格匹配
        //      FN_CHECKSIG PASS    // 严格匹配
        // }                        //=> ([<hashResult>], true)
        // @POPS[2] OUTPUT          // 导出返回的两个值
        //
        // 无取值时：
        // MODEL{
        //      TOP FN_PUBHASH      // 严格匹配
        //      DATA[32]{?}         // 长度固定，内容任意
        //      EQUAL PASS          // 严格匹配
        //      FN_CHECKSIG PASS    // 严格匹配
        // }                        //=> true
        // PASS                     // 通关检查
        //
        // 说明：
        // 如果一个未知脚本匹配这个模型，说明其支付逻辑正常。
        //
        // 设计：
        // 普通指令在模式区内表示与目标严格相同（全匹配）。
        // 如果目标脚本包含 MODEL 块本身，其内容作为普通关联数据对待。
        // 提示：
        // 长的数据可用哈希测试相等性，这样就不必书写相同的内容。


// 以下指令仅在 MODEL{} 内有效。

117     _           指令通配
        // 目标指令可为任意指令，含附参和关联数据。
        // 但目标位置必须有指令。
        //
        // 注记：
        // 静态的指令包含指令码及其附参和关联数据。

118     _(~)        指令段通配
        // 目标可为任意指令段。
        // 附参：指令个数。
        // 例：
        // _[3]     通配目标脚本当前位置及之后共3个指令。
        // _[1]     与前面 _ 指令效果相同。
        // _[0]     没有意义。
        // 注：
        // 指令段仅指同级关系，含结构块的指令本身只是一个指令（子代码块是它的关联数据）。
        // 这是上面“_”指令的复数形式，也是后面“...”指令的高效版。

119     ?{}(~)      指令序列可选
        // 花括号包围的指令序列与目标段相同或不存在。
        // 附参：本序列长度。
        // 规则：
        // 这是一种全等测试，包含指令的附参和关联数据。
        // 如果是不存在（不同），目标位置的原指令会延续到后续的测试。
        // 例：
        // ?{ @TOP PRINT }  目标位置可包含该打印序列
        // ?{ POPS[3] }     目标位置可为一个 POPS[3] 指令
        // ?POPS[3]         同上，单个指令可无花括号
        // ?POPS            注意！这由下面的指令负责
        // ?{1, 3, 5}       匹配一个值集（单指令），可选

120     ?(1)        通配指示
        // 指示跟随指令的哪个部分可通配（与目标作比较时）。
        // 附参：位置标识。
        // 0000 0001    第1个附参任意。(1)
        // 0000 0010    第2个附参任意。(2)
        // 0000 0100    第3个附参任意。(4)
        // 0000 1000    第4个附参任意。(8)
        // 0001 0000    第5个附参任意。(16)
        // 0010 0000    关联数据任意。(32)
        // 0100 0000    指令本身可选。(64)
        // 1000 0000    关联数据的哈希匹配。(128)
        // 提示：
        // 如果附参和关联数据是同一个值（如部分值指令），用数据表达通配。
        // 可选设定时，可参看另2个“可选”模式指令。
        // 例：
        // ?[32] DATA[20]   目标为一个DATA指令，数据长度20字节，但内容任意
        // DATA[20]{?}      同上。更直观
        //
        // DATA[?]{?}       目标为一个DATA，附参和数据任意
        // ?[1|32] DATA     同上。支持位或表达，通配部分（[]{}）省略
        // ?[33] DATA       同上。33 = 1|32
        //
        // ?[1|32|64]DATA   目标为一个DATA，附参和数据任意，整体可选
        // ?[97] DATA       同上。97 = 1|32|64
        // ?DATA[?]{?}      同上。直观完整表达，首个?表达可选
        // ?DATA            同上。直观简化，未明确部分视为任意
        // ?POPS            同 ?POPS[?]，注意与 ?POPS[3] 的区别（不同模式指令）
        //
        // ""[50]{?}        匹配50字节长任意文本。
        // ?[32] ""[50]     同上，规范表达
        // ?{123}           目标是一个整数值 123，可选
        // ?{123.}          目标是一个浮点数 123.0，可选
        // ?Int             目标是一个整数，值任意，可选
        // ?Float           目标是一个浮点数，值任意，可选
        // ?Number          目标是一个数值（Int|Float），值任意，可选
        //
        // ?'A'             目标是一个A字节或符文，可选
        // !Byte            目标是一个字节，值任意
        // ?Byte            目标是一个字节，值任意，可选
        //
        // ?$               匹配局域存值指令 $，可选
        // $[?]             匹配局域取值指令 $(1)，任意位置值
        // ?$[?]            同上匹配，但可选。注意不能简化为 ?$，有冲突
        // ${?}             匹配循环变量 $X(1)，任意取值。
        //
        // 深匹配：
        // 包含子语句块的指令如果无前置通配指示，正常进入子语句块进阶测试。
        // 此时附参表达当前子块长度，而非匹配。
        // IF{...}          递进到子块内进一步测试。
        //
        // 单匹配：
        // 如果块指令有匹配指示，则视为单指令测试，子块作为关联数据对待。
        // ?[32] IF[60]     匹配if指令，子块长60字节，内容任意
        // IF[60]{?}        同上。更直观
        // IF[?]{?}         匹配if指令，长度和内容都任意。即目标位置必须为一个IF
        // ?IF              目标位置有一个IF，但可选
        //
        // ()[30]{?}        目标表达式占用30字节，内容任意
        // ()[?]{?}         目标是一个任意表达式，必须存在
        // (?)              同上。简化格式
        // ?()              目标位置有一个表达式，内容任意，可选
        // ?Expr            同上。参考下面类型匹配指令
        //
        // 哈希匹配：
        // 仅适用关联数据的严格相等测试（忽略附参）。
        // ?[128] DATA{0x4f262ae8...}   目标是一个 DATA，其内容的哈希为 4f262ae8...
        // ?[128] {0x4f262ae8...}       目标的关联数据的哈希为 0x4f262ae8...

121     #(1)        指令取值
        // 针对前一个指令匹配的目标，取目标的不同部分的值。
        // 目标需先由“通配指示”指令配置。
        // 附参：目标值标识。
        // 0000 0001 - 第1个附参。(1)
        // 0000 0010 - 第2个附参。(2)
        // 0000 0100 - 第3个附参。(4)
        // 0000 1000 - 第4个附参。(8)
        // 0001 0000 - 第5个附参。(16)
        // 0010 0000 - 关联数据。(32)
        // 0100 0000 - 单纯指令码。(64)
        // 1000 0000 - 完整指令（含附参和关联数据）。(128)
        // 说明：
        // 同一指令可取多个部分，所有的取值会按顺序展开暂存。
        // 取完整指令时，取值包含独立的附参和关联数据。
        // 本指令需紧跟在目标指令之后。
        // 例：
        // DATA[20]{?} #[32]    // 提取 DATA 目标的数据段
        // GOTO[?,?,?] #[1|2|4] // 提取 GOTO 目标的三个附参（自动展开）
        // GOTO[?,?,?] #[7]     // 同上，7 = 1|2|4
        // 提示：
        // 提取的值会放入一个内部队列，作为MODEL的第二个返回值。

122     ?!(1){Type}  类型匹配|可选
        // 目标为特定类型的指令。
        // - 匹配测试：前置!，如果失败则结束Model块。
        // - 可选测试：前置?，不会失败。
        // 附参：类型标识。
        // 类型名：
        // - Bool   布尔值（2个值指令）
        // - Byte   字节
        // - Rune   符文
        // - Int    整数
        // - BigInt 大整数（BigInt|*BigInt）
        // - Float  浮点数
        // - String 字符串（2个）
        // - Bytes  字节序列（2个）
        // - RegExp 正则表达式（RegExp|*RegExp）
        // - Time   时间类型（DATE{}）
        // - Script 脚本（Script|*Script）
        // 另支持：
        // - Dict   字典
        // - Number 整数或浮点数
        // - Expr   表达式
        // - Model  模式块（整体对待）
        // - Values 值集。如：{1, 3, 5}，由 {...}(~) 创建
        // 例：
        // !{Bool}  匹配布尔类型（true|false）
        // !Bool    同上，可省略花括号
        // ?Bool    目标是一个布尔值，可选
        //
        // !Bytes   匹配两个 DATA 指令
        // ?Bytes   同上，但可选
        // !String  匹配两个字符串指令
        // !Script  匹配 Script 或 *Script
        //
        // !Number  匹配任意整数和浮点数
        // !Model   匹配一个模式块。同：MODEL[?]{?}
        // !Expr    目标是一个表达式。同：(?)
        //
        // 实现：
        // 指令执行的是可选还是匹配，由附参的高位标记。

123     !{}(~,~)    整数值范围匹配
        // 目标值在范围之内则匹配，否则失败。
        // 附参1：下边界值，包含。
        // 附参2：上边界值，不包含。
        // 例：
        // !{0, 1024} 限定目标值：0 ≦ n < 1024
        // 注：
        // 暂不支持大整数（BigInt）的范围测试。

124     !{}(8,8,4)  浮点数值范围匹配
        // 目标值在范围之内则匹配，否则失败。
        // 附参1：下边界值，包含。
        // 附参2：上边界值，不包含。
        // 附参3：相等比较误差（不超过即视为相等）。
        // 例：
        // !{0, 1.0, 0}         目标为0或小于1.0的任意浮点数。
        // !{0.1, 10, 1e-10}    目标在0.1~10之间，下边界相等误差不超过1e-10。
        //
        // 设计：
        // 仅用4字节的浮点数表达误差，最小值：1.4013e-45。

125     RE{/.../gG}(1,1)    正则查找
        // 对文本或字节序列目标执行正则表达式匹配。
        // 附参1：查找方式（g|G|s）。
        // 附参2：正则式内容长度（<256）。
        // 附参值：
        // g：查找所有，但仅限于完整匹配（re.FindAll）。
        // G：查找所有，包括捕获组（re.FindAllSubmatch）。
        // s：查找首个匹配，包括捕获组（re.FindSubmatch）。
        // 提示：
        // 匹配的结果可由下面的 & 指令获取。
        // 注意与值指令里的正则式创建指令的不同（/.../）。
        // 例：
        // RE{/(?i)[a-z]+/s}    查找首个单词，结果为一个单成员切片
        // RE{/(?i)[a-z]+/g}    查找全部单词，结果为一个全匹配的切片

126     &(1)        正则查找取值
        // 配合上面的 RE{/.../} 指令使用，获取其匹配值成员。
        // 附参：取值序位（<256）。
        // 说明：
        // - 这是 MODEL{} 内除 #(1) 之外的另一个取值指令（共2个）。
        // - 应当紧随其属主指令 RE{/.../} 使用，但在下一个RE{}之前，可以多次取值。
        // - 如果目标没有匹配或序位超出结果集，取值为nil。
        // 例：
        // RE{/(?i)[a-z]+/s} &[0]       取匹配结果中的首个成员
        // RE{/Ver-(\d+)/s} &[1]        取首个子表达式的匹配项（主版本号）
        // RE{/(?i)[a-z]+/g} &[3] &[1]  取全局匹配的第四个和第二个结果
        // RE{/(?i)[a-z]+/}
        //
        // 设计：
        // 最多支持256个匹配结果取值，更多的匹配将无法取到。
        // 这对栈脚本来说，可能已经足够。

127     ...         指令段任意通配
        // 匹配任意连续指令序列（含零长度）。
        // - 各层级独立，块指令视为单一实体。
        // - 非贪婪模式：最小化完整匹配。
        // 例：
        // 目标脚本：
        //      SYS_TIME{Stamp} {<expireTime>} GT
        //      @TOP PRINT          // 1
        //      IF{
        //          @POP NIL
        //      }
        //      TRUE
        //      IF{
        //          "Hello"         // 2
        //          @TOP PRINT      // A
        //      }
        //      "Done!"
        //      @TOP PRINT          // B
        //      @POPS[] NOP         // End
        // 模型1：
        // MODEL{
        //      SYS_TIME{Stamp} {<expireTime>} GT
        //      ...                 // 1 => TRUE
        //      IF{
        //          ...             // 2 "Hello"
        //          @TOP PRINT      // A
        //      }
        //      "Done!"
        //      @TOP PRINT          // B
        //      @POPS NOP           // 必须抵达终点，完整结束
        // }
        //
        // 模型2：
        // MODEL{
        //      SYS_TIME{Stamp} {<expireTime>} GT
        //      ...
        //      IF{?}               // 匹配第一个IF（非贪婪）
        //      ...                 // 剩余匹配，必需！
        // }
        // 注意：
        // 最后的...是必须的，这是匹配完整性要求（匹配到脚本结束）。
        //
        // 模型3：
        // MODEL{
        //      SYS_TIME{Stamp} {<expireTime>} GT
        //      ...
        //      IF{?}           // 匹配第二个IF，
        //      "Done!"         // 因为此处与IF共为一个约束
        //      ...             // 抵达末尾
        // }
        //
        // 警告：
        // 本指令可能较为消耗资源！如果可能，尽量使用明确的段通配。
```


### 小结：模式匹配的方式

- **位置匹配**：模式指令与目标指令按位置对比匹配。
- **指令匹配**：指令相同即为匹配。如果指令为值指令，则也隐含了类型逻辑。
- **附参匹配**：在指令匹配的前提下，附参参与匹配。
- **数据匹配**：在指令匹配的前提下，指令关联的数据也参与匹配。
- **类型匹配**：对目标的数据类型进行匹配，值任意。
- **范围限定**：对整数和浮点数按值的范围匹配。
- **正则匹配**：`RE{/../}` 可对文本和字节序列进行匹配测试和取值。
- **片段匹配**：连续的指令片段的匹配或通配（`_(1)`, `...`）。



## 13. 环境指令

脚本的运行处在一个逐层嵌套的环境：`系统域 > 交易域 > 校验域 > 脚本域 > 块域`，其中前者是后者的父域。

1. **系统域**。节点的运行时环境。包含节点能提供的一些系统级信息。
2. **交易域**。一笔交易可包含多个输入和输出，以及输入的来源输出部分。
3. **校验域**。当前输出的校验环境，包含 `GOTO` 跳转引入的脚本的验证。
4. **脚本域**。脚本的环境。包含顶层脚本和 `GOTO` 跳转或 `SCRIPT` 引入的子脚本等。
5. **块  域**。即语法块的局部域，包含顶层和嵌套子块。局部域无法互访。

该类指令大多不需要实参，除了设置脚本全局变量的 `SETVAR`。

> **附注：**
> 数据栈和实参空间属于脚本域。脚本域可以嵌套，因此子脚本也有自己的数据栈和实参区。

区间：`[128-137]`，10个。

```go
码值    指令字      说明
-----------------------------------------------------------
128     ENV(1){}    环境变量取值
        // 附参：目标标识。
        // 返回值：目标条目的值。
        // 提示：
        // 以下定义的名称并不全面，详情请参考具体实现。
        //
        // 系统域：
        // 即整个区块链环境。
        // - Timestamp   当前实际时间戳（秒数）
        // - ChainHeight 区块链当前高度（按交易时间戳算）
        // - BlockTime   当前区块的时间戳（同上推算，即理想块时间戳）
        //
        // 交易域：
        // 脚本所在的交易。
        // - Height     交易所在区块的高度
        // - TxTime     交易时间戳
        // - TxID       交易ID
        // 例：
        // ENV{Height}  获取脚本所在区块的高度
        // 注意：
        // 当脚本作为输入项被引用时，针对的是源交易所在区块。
        //
        // 校验域：
        // 特定于当前脚本。
        // - InGoto     是否在 GOTO 的脚本中
        // - InEmbed    是否在 EMBED 的脚本中
        // - InScript   是否在 SCRIPT 引入的脚本中
        // - InCode     是否在 CODE 定义的脚本中
        // - Gotos      当前 GOTO 跳转计数
        // - Embeds     当前 Embed 嵌入计数
        // - Source0    主脚本源码（不含解锁部分）
        // - Source1    第1个外部引入（SCRIPT|EMBED|GOTO）的脚本源码
        // - ...        第2~8个……
        // - Source9    第9个外部引入的脚本源码
        // - Sources    截止当前，引入的外部脚本数量（<10）
        // 注：
        // 外部脚本及其计数按运行时计算（与执行流相关）。
        // SourceN 系列变量主要为方便模式验证。

129     IN(1){}     输入项取值（校验域）
        // 对于脚本来说，即未来被花费时输入部分的信息。
        // 附参:目标标识。
        // 返回值：目标条目的值。
        // 条目：
        // - Index      当前输入在输入集内的序位
        // - Amount     当前输入的币金数量（同 INOUT:Amount）
        // - Account    当前输入的账户（公钥哈希，即 INOUT:Receiver）
        // - Remarks    当前输入的付款附言
        // - Sigs       当前输入已签名数量（>= 0）
        // - CanSigs    当前输入能够签名的数量（多重签名时）
        // - SigType    当前输入的签名类型
        // - Script     当前输入脚本（含解锁部分）
        // - Source     当前输入脚本（不含解锁部分）

130     OUT(~,1){}  输出项取值（交易域）
        // 针对当前待验证交易的输出集。
        // 即未来花费者的转账目标部分，可用于定向约束（如遗嘱，有预定的规则）。
        // 附参1：输出项序位（起始值0）。
        // 附参2：目标标识。
        // 返回值：目标条目的值。
        // 条目：
        // - Amount         币金数量
        // - Receiver       接收者
        // - Remarks        付款附言
        // - Creator        凭信/存证创建者
        // - Title          凭信/存证标题
        // - Description    凭信描述
        // - Content        存证内容
        // - Count          凭信转移计数
        // - Attachment     附件ID
        // - Source         输出脚本（字节序列）
        // 例：
        // OUT[0]{Amount}   当前交易首项输出的币金数量

131     INOUT(~,1){}    源输出项取值（交易域）
        // 输入项来源交易的输出集（兄弟条目）成员取值。
        // 附参1：输出项序位（起始值0）。
        // 附参2：目标标识。
        // 返回值：目标条目的值。
        // 条目：
        // - ....       同前 OUT 部分
        // - Timestamp  源交易的创建时间戳
        //
        // 注记：
        // 逻辑上 IN 即是 INOUT 中的当前项，但这里仅针对源码逻辑。
        // 注意这是一条消耗资源的指令，
        // 因为这需要系统载入输入源的兄弟输出项集。

132     XFROM(1){}  获取源脚本信息（交易域）
        // 外部脚本对跳转来源交易的信息检索（GOTO, EMBED）。
        // 附参：目标标识。
        // 返回值：目标条目的值。
        // 条目：
        // - InSize     源交易输入集大小（项数）
        // - InAmount   源交易输入总金额
        // - OutSize    源交易输出集大小（项数）
        // - OutAmount  源交易输出总金额
        // - Timestamp  源交易的创建时间戳
        // - Amount     源脚本关联币金数量
        // - Account    源脚本关联账户（公钥哈希）
        // - PayType    源脚本关联的类型（币金|凭信|存证）
        // - Source     源脚本指令序列（从开头到跳转点）
        // 注：
        // 来源交易指花费输出时，当前正在验证的交易，
        // 而非输入项源脚本所在的交易。

133     VAR(1)      全局变量取值（脚本域）
        // 附参：目标变量位置 [0-255]。
        // 返回值：目标置位的值，单值。
        // 注意：
        // 与局部域不同，此为变量逻辑，可被赋值覆盖。
        // 例：
        // @VAR[0]  取全局变量集0号位置的值，添加到实参区。
        // VAR[10]  取全局变量集10号位置的值入栈。
        // 提示：
        // 本指令属于脚本域，不跨GOTO。
        // 但EMBED嵌入的脚本共享相同环境，因此会相互影响。

134     SETVAR(1)   全局变量赋值（脚本域）
        // 对当前脚本域的全局变量区设置值，配合 VAR 使用。
        // 附参：变量位置 [0-255]。
        // 实参：任意类型，单值。
        // 返回值：无。
        // 例：
        // {123} SETVAR[1]      将栈顶的值 123 存入全局变量域的1号位置。
        // {1.5} SETVAR[255]    将浮点数 1.5 存入全局变量域的255号位置。
        // $VAR[1]              读取上面存入的 123 添加到当前局部域。

135     SOURCE(1)   源脚本序列提取（脚本域）
        // 获取源脚本的指令码序列，受指令所在层级限制。
        // 附参：取值标识。
        // 返回值：字节序列（副本）。
        // 注意，返回的是字节序列而非Script类型。
        // 标识：
        // > 0  当前块完整代码（含 SOURCE）。
        // > 1  当前块前阶已执行代码段（含 SOURCE）。
        // > 11 同上，但不含 SOURCE。
        // > 2  当前块前阶已执行代码段，从最近的 NULL 点开始（不含 NULL，含 SOURCE）。
        // > 12 同上，但不含 SOURCE。
        // > -1 当前块后阶未执行代码段，直到块末尾。注：已不含 SOURCE，下同。
        // > -2 当前块后阶未执行代码段，直到最近的 NULL 点（不含 NULL）。
        // 提示：
        // NULL 点由系统指令 SYS_NULL 标记。
        // 只有在顶层的 SOURCE 才能获取到完整的脚本（含解锁段）。
        //
        // 记忆：
        // 可以把 11/12 中前置的1视为增强（移除 SOURCE）。

136     MULSIG(1)   多重签名序位确认（校验域）
        // 检查目标序位的账户是否有签名。
        // 附参：目标序位。
        // 返回值：布尔值。
        // 序位指多重签名公钥哈希清单中的序位，从0开始。
        // 仅用于多重签名的输入项。
        // 例：
        // MULSIG[1] PASS   // 如果多重签名中的第2位签了名，通过。
        // 例：
        // 确认3个参与者中至少有2个签名。
        // MULSIG[0] MULSIG[1] MULSIG[2] SHIFT[3] SOME[2] PASS
        //
        // 提示：
        // 属于校验域，在GOTO到的目标脚本中也可见。

137     （未用）
```

> **参考：**
> 重要的环境信息应当对中间件开放，让它们可以感知系统状态，获取确定的值。
> 如：`ENV{}`、`IN{}`、`OUT{}`、`INOUT{}` 中部分的成员值。


## 14. 工具指令

包含一些基础并常用的功能性指令。另外还有一个保留区（量子安全）。

区间：`[138-163]`，26个。

```go
码值    指令字      说明
-----------------------------------------------------------
138     EVAL        执行脚本
        // 将实参视为脚本指令序列执行。
        // 拥有独立的执行域（环境），与外部隔绝，
        // 但内部数据栈的遗留项会作为一个切片返回到调用层。
        // 实参：Script。
        // 返回值：一个切片。
        // 注意：
        // 实参是有类型的，仅能由 CODE、SCRIPT 创建。
        //
        // 安全性：
        // 该指令通常不应当用于公共验证，但封闭的环境可保证安全。
        // 即：脚本内的通关状态与调用层无关。

139     COPY        复制（切片）
        // 将切片成员复制到一个新的空间。这是一个浅复制。
        // 实参：一个切片。
        // 返回值：一个包含成员副本的新切片。
        // 提示：
        // 如果需要切片成员的递归式深复制，可用 DCOPY。

140     DCOPY       深层复制（切片）
        // 切片成员递归式深复制到一个新的空间。
        // 实参：一个切片。
        // 返回值：一个全新的切片。
        // 注：
        // 子切片会递归复制，直到成员为非切片类型，any成员也会递进检查。

141     KEYVAL(1)   字典键值切取
        // 附参：切取类型。
        // - 0: 键和值。两个切片。
        // - 1: 仅键。一个切片。
        // - 2: 仅值。一个切片。
        // 实参：一个字典。
        // 返回值：1~2个切片。
        // 返回两个切片时，两者的成员会一一对应。
        // 两个结果会自动展开到接收域。
        // 例：
        // @KEYVAL  键值两个切片展开到实参区。此时实参区有两个切片

142     MATCH(1)    正则匹配
        // 对字符串或字节序列进行正则匹配，取匹配值或子匹配的值。
        // 附参：匹配方式（g|G|o|s|_）。
        // 实参1：目标字符串或字节序列。
        // 实参2：正则表达式（*RegExp）。
        // 返回值：布尔值|单值|切片。
        // 附参值：
        // _：零值，匹配测试（re.Match），返回Bool。
        // g：查找所有，但仅限于完整匹配（re.FindAll）。
        // G：查找所有，包括捕获组（re.FindAllSubmatch）。
        // o：查找首个匹配（re.Find），返回单值
        // s：查找首个匹配，包括捕获组（re.FindSubmatch）。
        // 注意：
        // 如果正则式不含子匹配式，想要获取全部匹配应当使用 g 标记，
        // 因为 G 标记确定会返回一个二维切片。
        // 例：
        // /(?i)[a-z]+/ MATCH{g}        获取全部完整匹配，结果是一个切片
        // /(?i)[a-z]+/ MATCH[103]      同上，用 g 的码值表示
        // /(?i)Ver-(\d+)/ MATCH{G}     获取全部匹配，包含子匹配，结果是一个二维切片
        // /(?i)Ver-(\d+)/ MATCH{s}     获取首个匹配。返回的切片包含了两个成员
        // /(?i)[a-z]+/ MATCH{o}        获取首个匹配。返回一个单值
        // /(?i)\b[0-9a-f]+\b/ MATCH    是否包含一个十六进制数，默认0值省略

143     SUBSTR(~)   字串截取
        // 附参：符文（Rune）数量。
        // 实参1：一个字符串（UTF-8）。
        // 实参2：起始字符位置。按字符计数，从0开始。支持负数从末尾算起。
        // 返回值：一个子字符串。
        // 注意：
        // 目标字符串应当是合法的UTF-8编码序列。
        // 如果截取的子字符串长度不足，返回一个空串（出错）。
        //
        // 设计：
        // 作为栈脚本，使用静态的附参定义字符数量可能更安全，
        // 比如用户可以明确地检查是否为出错。

144     REPLACE(1)  字串替换
        // 对目标字符串中匹配的部分进行替换。
        // 附参：替换次数，0值表示全部。
        // 实参1：目标字符串。
        // 实参2：替换匹配式（子串或正则表达式）。
        // 实参3：替换串，可包含特殊标识（当匹配式为正则表达式时）。
        // 返回值：一个新的字符串。
        // 说明：
        // 仅支持字符串目标。
        // 匹配式为正则表达式时会替换全部，不能指定次数。

145     RANDOM      创建一个随机数
        // 返回的随机数是安全的（crypto/rand）。
        // 实参：上限边界，可选。
        // 返回值：一个小于实参的非负随机数，类型与实参同。
        // 注意：
        // 上限可选，Int|BigInt类型，如果提供则需大于零。
        // 默认int64类型，上限为其可表达的最大值。

146     QRAND       创建一个随机数（快速）
        // 快速获取一个随机数（不安全）。
        // 实参：上限值，可选。Int类型。
        // 返回值：一个小于实参的非负随机数。
        // 注意：
        // 上限值可选，默认为int64可表达的最大值。不能为负。
        // 应当仅用于要求效率而非安全的场合。

147     SLRAND      成员顺序打乱（切片）
        // 实参：一个切片。
        // 返回值：成员顺序随机重排的一个新切片。
        // 注意：
        // 随机数的种子是安全的，但不保证随机性的安全。

148     CMPFLO(1)   浮点数比较
        // 附参：比较类型标识。
        // > 0  相等比较（==）
        // > -1 小于等于（<=）
        // > 1  大于等于（>=）
        // 实参1：待比较值。
        // 实参2：待比较值。
        // 实参3：误差值，实参1-2间的差值不超过该值时即视为相等。
        // 返回值：一个布尔值。
        //
        // 设计：
        // 主要用于弥补比较指令中对浮点数相等测试的不足。
        // 如果只是不涉及相等的大于或小于对比，请用比较指令。

149-150 （未用）

151     RANGE(1)    创建数值序列
        // 附参：序列长度（成员数量）。
        // 实参1：起始值，Int|Float。
        // 实参2：步进值，Int|Float。
        // 返回值：一个数值切片。
        // 说明：
        // 返回数值类型由实参表达，以实参1为基准。
        // 附参0值会创建一个空切片，此时的实参1仅表达类型。
        // 例：
        // {10} {1} RANGE[5]    // [10, 11, 12, 13, 14]
        // {1.} {1.1} RANGE[5]  // [1.0, 2.1, 3.2, 4.3, 5.4]
        //
        // 设计：
        // 附参仅由1字节表达，因此仅用于创建小数值序列。
        // 这是基于性能和安全性的考虑。
        // 如果需要较大的集合，可以考虑合并多个结果（MERGE）。
        // 例：
        // {0, 250, 500, 750}
        // EACH{
        //      $Value {1} RANGE[250]
        // }
        // @POPS[4] MERGE   // [0, 1, 2, ...999]

152     MAP{}(~)    映射迭代
        // 针对目标集，迭代每一个成员执行子语句块，
        // 返回值构造为一个最终切片。
        // 附参：子语句块长度。
        // 实参：不定数量。
        // 首个成员为目标集，后续作为私有数据栈初始成员。
        // 返回值：一个切片。
        // 语法：
        // 内部语句块视为一个独立的脚本域，拥有自己的私有数据栈和实参区。
        // 各个迭代之间共享数据栈和实参区。
        // 局部变量：
        // - $Value         // 当前条目数据
        // - $Index|$Key    // 当前循环键（整数下标或字符串）
        // - $Slice|$Dict   // 迭代集本身
        // - $Size          // 集合大小（迭代次数）
        // 注意：
        // 返回的 nil 值会被忽略，这让指令也有了筛选的能力。
        // 目标集可以是切片或字典，如果是后者，迭代的顺序不确定。
        // 例：
        // @{1, 2, 3, 4}    // 目标集
        // @{20}            // 私有数据栈初始成员
        // MAP{
        //      @( $Value * TOP ) RETURN
        //      // TOP无前置@，这是表达式内的规则
        // }
        // 返回集：[20, 40, 60, 80]

153     FILTER{}(~)   成员过滤
        // 针对目标集，迭代每一个成员执行子语句块
        // 返回真时该成员被选取（不影响原集合）。
        // 附参：子语句块长度。
        // 实参：不定数量。
        // 首个成员为目标集，后续作为私有数据栈初始成员。
        // 返回值：一个切片或字典。
        // 语法：
        // 同上MAP指令。
        // 说明：
        // 支持字典的过滤，返回真的条目构建为一个新的字典。
        // 返回值类型同目标集，切片=>切片，字典=>字典。
        // 例：
        // @{1, 2, 3, 4, 7}     // 目标集
        // @FILTER{
        //      ( $Value % 2 )  // 奇数值为1
        //      @BOOL RETURN    // 转为布尔值返回
        // }
        // PRINT    // 打印 [1, 3, 7]

154     EGO{}(~)    嵌入扩展（Go 语言）
        // 嵌入原生Go代码。
        // 子块内容视为字节数据（类似于值指令）。
        // 附参：内容长度。
        // 返回值：无。
        // 说明：
        // 应当只在存证的识别脚本中有效。
        // 可以在币金或凭信的脚本中出现，但会被校验节点忽略。
        // 参考：
        // 如果出现在锁定脚本中，通常是为了某种传递（OUTPUT）。
        // 代码可由解释器（如 Yaegi）在必要时执行。

155     SHELL{}(~)  嵌入扩展（Shell 脚本）
        // 不限定语言，首行标记解释器（Shebang）即可。
        // 附参：内容长度。
        // 返回值：无。
        // 注意事项同上 EGO 指令说明。
```


### 保留区

主要用于未来可能需要的基础性安全支持，比如抗量子能力。共计 8 个。

```go
156-163 （未用）
```


## 15. 系统指令

少量执行系统级功能的指令。

区间：`[164-169]`，6个。

```go
码值    指令字          说明
-----------------------------------------------------------
164     SYS_TIME(1){}   全局时间取值
        // 全局时间对象是客户端真实的当前时间，只读。
        // 附参：条目标识。
        // 实参：无。
        // 返回值：目标条目的值。
        // 条目：
        // - 默认           当前时间（Time）
        // - Stamp          时间戳（秒数）
        // - Year           年次（4位）
        // - Month          月次/年（1-12）
        // - YearDay        日次/年（1-365|366）
        // - Day            日次/月（1-31）
        // - WeekDay        日次/周（0-6）
        // - Hour           时数/日（0-23）
        // - Minute         分钟数/时（0-59）
        // - Second         秒数/分钟（0-59）
        // - Millisecond    毫秒数/秒（0-999）
        // - Microsecond    微秒数/秒（0-999999）
        // 注：
        // 返回的数值统一为Int类型。
        // 例：
        // SYS_TIME{Stamp}  获取系统当前的时间戳。
        // SYS_TIME[0]      获取当前时间对象（Time）。
        // SYS_TIME         同上

165     SYS_AWARD(1)    兑奖验算
        // 按设计规则检查兑奖是否满足要求。
        // 附参：兑奖比率（10 => 10%），不大于100。
        // 实参：奖励块高度。
        // 返回值：兑奖金额（已减去截留部分）。
        // 规则：
        // 仅可使用在Coinbase交易的输出脚本中。
        // 检查由系统内部完成，详见设计文档。
        // 注记：
        // 是检查兑奖区块之后的链段，需满足长度限定。

166     SYS_CHKPASS     系统验证
        // 即内置的交易验证，包含单签和多签。
        // 本指令也是通关指令（如PASS），验证失败会退出。
        // 实参：不定数量。
        // 返回值：无。
        // 说明：
        // 当前输出属于单签还是多签，由解锁数据项表达。
        // 当前验证属于币金还是凭信，由输出项配置决定（类型值）。
        // 单签：
        //      实参1：验证类型（1）
        //      实参2：授权标记
        //      实参3：签名
        //      实参4：公钥
        // 多签：
        //      实参1：验证类型（2）
        //      实参2：授权标记
        //      实参3：签名序列
        //      实参4：公钥序列
        //      实参5：公钥哈希序列
        // 注意：
        // 接收者地址必须是标准格式。
        // 提示：
        // 如果用户需要验证失败后依然执行后续脚本，
        // 应当使用 CHECK 且自行验证。
        //
        // 设计：
        // 币金和凭信遵循不同的验证逻辑，但二者都由本指令启动执行。
        // 参考：
        // - 币金：需提取币金数量。
        // - 凭信：需检查转移逻辑（计次、有效期、修改性等）。

167-168 （未用）

169     SYS_NULL        源码零点标识
        // 在脚本的当前位置设置一个NULL点，作为片段提取时的起点。
        // 主要对 SOURCE 指令有用。
        // 例：
        // SYS_NULL     // 设置起点
        // "Hai"        // 入栈字符串 Hai
        // ...          // 除了 SYS_NULL 的任意指令序列
        // SOURCE[2]    // 提取从 Hai 开始到本指令的源码（包含）
```


## 16.函数指令

在语言基础性逻辑之外，看着应该像函数的指令。它们开始包含命名前缀（`FN_`），以与基础性指令区分。

大部分函数指令没有附参，由动态的实参提供信息输入。

区间：`[170-209]`，40个。


### 基础函数集

数量不多的一些常用的基础性函数。

这里的书写已略作调整，按函数定义的形式表达。实参可从括号内的声明体现出来。

```go
码值    函数名（参数序列） => 返回值类型
-----------------------------------------------------------
170     FN_BASE58( data Bytes|String ) => String|Bytes
        // 将目标字节序列为编码为 Base58 字符串，或反向解码。
        // 实参：字节序列或字符串。
        // 返回值：字符串或字节序列。
        // 提示：
        // 执行解码或编码，视实参类型而定。

171     FN_BASE32( data Bytes|String ) => String|Bytes
        // 将目标字节序列编码为 Base32 字符串，或反向解码。
        // 实参：字节序列或字符串。
        // 返回值：字符串或字节序列。
        // 规范：
        // RFC4648：大写 + 234567。
        // 提示：
        // 编码或解码时实参类型而定，字符串没有填充字符。

172     FN_BASE64( data Bytes|String ) => String|Bytes
        // 将目标字节序列编码为 Base64 字符串，或反向解码。
        // 实参：字节序列或字符串。
        // 返回值：字符串或字节序列。
        // 提示：
        // 编码或解码由实参类型自动决定。
        // 无填充字符，增补字符采用URL友好类型（-_）。

173     FN_ADDRESS( pbHash Bytes, prefix String ) => String
        // 将公钥哈希编码为账户地址（Base32:[4-9A-Z]）。
        // 实参1：公钥哈希。
        // 实参2：识别前缀。
        // 返回值：账户地址（字符串）。
        // 提示：
        // 文本形式的账户地址主要用于UI展示和识别。
        // 与简单的BASE32不同，这里包含了前缀组合以及可验证性。
        // 编码：
        // 0. 公钥哈希添加识别前缀：[前缀][公钥哈希]。
        // 1. 对结果执行2次哈希运算，取末尾4字节为校验码。
        // 2. 公钥哈希附上校验码：[公钥哈希][校验码]。
        // 3. 将结果编码为文本，附上前缀：[前缀][编码文本] >> 账户地址
        //
        // 校验：
        // 0. 分离识别前缀（长度已知）和编码文本。
        // 1. 将编码文本解码为字节序列并切分：[公钥哈希][校验码1]。
        // 2. 公钥哈希前置识别前缀：[前缀][公钥哈希]，
        // 3. 对结果执行2次哈希运算，取末尾4字节为校验码2。
        // 4. 两个校验码对比，相同即为合法。
        //
        // 参考：
        // 文本形式的账户地址仅用于人类可读展示，
        // 以及当用户构造交易解码地址时，验证输入的的地址是否合法。

174     FN_PUBHASH( data Bytes|String, ?pfsize int ) => Bytes
        // 创建单签名公钥哈希，或解码账户地址。
        // 实参1：公钥或账户地址。
        // 实参2：地址前缀长度，可选。
        // 返回值：公钥哈希。
        // 提示：
        // - 是创建还是解码地址，由实参的类型判断，
        //   如果是新创建，前缀长度参数无意义。
        // - 当为解码地址时，并不能区分结果是属于单签名还是多签名。
        //   此为上面 FN_ADDRESS 的逆行为。

175     FN_MPUBHASH( pubHash []Bytes, m, n int ) => Bytes
        // 创建多重签名的总公钥哈希。
        // 实参1：所有参与者的公钥哈希。
        // 实参2：m/N 配比中的 m。
        // 实参3：m/N 配比中的 N（m ≤ N）。
        // 返回值：复合公钥哈希。
        // 提示：
        // 与上面的 FN_PUBHASH 不同，这里仅有创建行为。
        // 且专门针对多重签名的地址。

176     FN_CHECKSIG( flag byte, sig, pubKey Bytes ) => Bool
        // 单签名验证。
        // 实参1：授权标识。
        // 实参2：签名数据。
        // 实参3：签名用公钥。
        // 返回值：成功与否。

177     FN_MCHECKSIG( flag byte, sigs, pubKeys, pubHashs []Bytes ) => Bool
        // 多重签名验证。
        // 实参1：授权标识。
        // 实参2：签名数据集。
        // 实参3：签名公钥集。与实参2成员一一对应。
        // 实参4：剩余公钥哈希集。
        // 返回值：成功与否。
        // 注记：
        // []Bytes类型在数据栈中并不存在，实际上为 []any。

178     FN_HASH224(1)( data Bytes ) => Bytes
        // 对实参数据执行哈希运算，224位长。
        // 附参：算法标识（sha3|sha2|blake2），默认 sha3。
        // 实参：任意字节序列。
        // 返回值：字节序列（28字节）。
        // 设计：
        // 支持算法标识可能是一个必要的机制，更灵活。

179     FN_HASH256(1)( data Bytes ) => Bytes
        // 256位哈希运算。
        // 附参：算法标识（sha3|sha2|blake2），默认 sha3。
        // 实参：任意字节序列。
        // 返回值：字节序列（32字节）。
        // 例：
        // DATA{...} FN_HASH256{sha3}   // 采用 sha3.Sum256（FIPS-202）
        // DATA{...} FN_HASH256         // 同上，默认算法
        //
        // 参考：
        // 这里的 blake2 实为 BLAKE2b 算法。
        // 在安全性上，BLAKE2b 比 SHA2 好，在 64位 x86 和 ARM 架构上也比 SHA2/SHA3 快。

180     FN_HASH384(1)( data Bytes ) => Bytes
        // 384位哈希运算。
        // 附参：算法标识（sha3|sha2|blake2），默认 sha3。
        // 实参：任意字节序列。
        // 返回值：字节序列（48字节）。

181     FN_HASH512(1)( data Bytes ) => Bytes
        // 512位哈希运算。
        // 附参：算法标识（sha3|sha2|blake2），默认 sha3。
        // 实参：任意字节序列。
        // 返回值：字节序列（64字节）。

182-207 （未用）

208     FN_PRINTF( fmt string, val ...any ) => nil
        // 向控制台打印消息，即 fmt.Printf。
        // 实参1：格式字符串。
        // 实参n：不定数量目标变量。
        // 提示：
        // 注意与标准打印指令 PRINT 的不同。
```


### 基础函数扩展

```go
码值    指令字          说明
-----------------------------------------------------------
209     FN_X(1){}       扩展函数引用
        // 调用目标位置的扩展函数。
        // 附参：目标索引。
        // 实参：……
        // 实参视具体情况而不同，由目标指令及其配置决定。
        // 说明：
        // 基础扩展仅支持1字节空间，最多可扩展256个函数指令。
        // 如果需要更多功能性函数，可使用正式的扩展指令 EX_FN（见后）。
        // 友好：
        // 花括号内可用目标名称书写。
```


## 17.模块指令

模块用于引入分门别类的功能。每一个模块都有一个1字节附参，用于索引其成员。

通常，如果模块需要创建一个表示自身的对象，应由首个成员 `Create` 实施。如果其它成员函数需要使用该对象，应作为首个参数传入。

区间：`[210-249]`，40个。

```go
码值    指令字          说明
-----------------------------------------------------------
210     MO_MATH(1){}    数学运算类
        // 汇聚专用于数学运算的高阶操作。
        // 附参：成员标识。
        // 说明：
        // 成员通常用花括号包围的名称表示，而不是用其码值。
        // 调用括号中的参数即为实参定义。
        // 成员：
        // - Abs(x float64) float64
        // - Ceil(x float64) float64
        // - Floor(x float64) float64
        // - Pow(x, y float64) float64
        // - Max(x, y float64) float64
        // - Min(x, y float64) float64
        // - Mod(x, y float64) float64
        // - ....
        // 例：
        // MO_MATH{Abs} 计算实参的绝对值。
        // MO_MATH.Abs  同上，支持用句点引用。

211     MO_TIME(1){}    时间模块
        // 处理日期/时间对象。
        // 第一个成员方法 Create 创建一个时间对象。
        // 其余大部分方法都将时间对象作为首个参数传入。
        // 成员：
        // - Create(sec int64) => Time
        // 创建一个时间对象。实参：Unix时间戳（秒数）
        //
        // - Now() => Time
        // 用当前本地时间创建一个时间对象。实参：无
        //
        // - Add(tm Time, d int64) => Time
        // 将时间对象tm延后一个值，返回一个新的时间对象。
        //
        // - Clock(tm Time) => (hour, min, sec int)
        // 返回时间对象的：时、分、秒
        //
        // - Date(tm Time) => (year, month, day int)
        // 返回时间对象的：年、月、日
        //
        // - ....
        // （待定）

212     MO_RE(1){}      正则表达式
        // 详细定义正则表达式相关的操作。
        // 成员：
        // - Create(str string) => *Regexp
        // 创建一个正则表达式对象。
        //
        // - Find(re *Regexp, b []byte) => []byte
        // 查找匹配的目标序列。
        //
        // - FindAll(re *Regexp, b []byte, n int) => [][]byte
        // 查找匹配的全部目标序列。
        //
        // - Split(re *Regexp, s string, n int) => []string
        // 按模式切分目标字符串，返回n个子字符串。
        //
        // - String(re *Regexp) => string
        // 返回编译正则表达式的源文本。
        //
        // - ....
        // （待定）

213-248 （未用）
```


### 标准模块扩展

```go
码值    指令字          说明
-----------------------------------------------------------
249     MO_X(1){}       扩展模块引用
        // 引用目标位置的子模块并调用。
        // 子模块的成员依然由其自身的一个附参表达，通常也仅为1字节。
        // 附参：目标索引。
        // 提示：
        // 子模块名称及其方法调用书写在花括号内。
        // 例：
        // MO_X{Exp.Create} 调用 Exp 子模块的 Create 方法
        //
        // 设计：
        // 标准256个子模块的扩展空间应已足够，
        // 如需更多扩展支持，可使用专门的扩展指令 EX_MO，空间庞大。
```


## 18. 扩展指令

最后的几个指令空间位用于通用的扩展指令区。

区间：`[250-253]`，4 个。

```go
码值    指令字          说明
-----------------------------------------------------------
250     EX_FN(2){}      函数类扩展
        // 附参：目标索引。
        // 2字节的空间可定义64k个指令，空间庞大。

251     EX_MO(2){}      模块类扩展
        // 附参：目标索引。
        // 专门的扩展模块空间，64k指令位。

252     EX_INST(2){}    通用类扩展
        // 附参：目标索引。
        // 扩展出来的指令是一个自完整的逻辑，有其自身的附参或数据。
        // 2字节的扩展空间依然庞大。

253     EX_PRIV(2){}    第三方私有扩展
        // 附参：目标索引。
        // 私有：
        // 公共校验节点不处理此类指令，它们由私有的应用自行发展和使用。
```

> **注：**
> 最高的码值 `254/255` 为系统保留（不用），不在指令集范畴。



--------------------------------------------------------------------------

上一篇：[脚本系统](6.脚本系统.md)<br>
下一篇：[附：组队校验](附.组队校验.md)<br>
