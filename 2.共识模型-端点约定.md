//////////////////////////////////////////////////////////////////////////////
Copyright (c) 2019 @cxio/blockchain

    Permission is granted to copy, distribute and/or modify this document
    under the terms of the GNU Free Documentation License, Version 1.3
    or any later version published by the Free Software Foundation;
    with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
    A copy of the license is included in the section entitled "GNU
    Free Documentation License".
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&


## 端点约定

在P2P的世界里，不同于传统的「服务器/客户端」的主从逻辑，相互连接的端点是一个平等的关系：一个端点从对方获取服务的同时，也为对方提供服务。端点既是客户端也是服务器，两个端点依靠预先定义的规则平等交互，相互协作，共同形成了自由的P2P网络。这是一个由契约维系的去中心化世界，在这里，所有的端点都遵循共同的规则或约定，这些规则和约定，可以称之为 **端点约定**。

端点约定并没有强制力，P2P是自由的，端点也有不遵守约定的自由，但这样的约定会在现实中形成一道屏障：你可以不遵守约定、破坏规则，但别人会离你而去，当大家都不理你了，你就脱离了这个世界，变得无足轻重。由此可见，端点约定实际上是P2P世界里强有力的约束，即便它没有名义上的强制力。

端点约定有两种：一种是可以在最终数据上检验合法性的规则，可以称之为协议。一种是宽松的公共守则，如果都遵守，系统会运作得很好，但不遵守也不会致命，比如大家在相同的时间做某件事。这种公共守则可以简单地称之为公约或约定。

**注**：在网络语境中，端点有时也称为节点，在下面的叙述中并不刻意区分两者。



## 分叉竞争与主链保持

前述的择优池同步并不能绝对保证区块链网络不产生分区。择优池中的高权重铸造者如果没能及时出块，或者网络的原因导致了优质区块的隔离，分区就可能偶尔出现，这会导致主链的分叉。或者，如果有攻击者分叉出一条支链，试图混淆主链或与之竞争，也应当有办法保证主链的清晰和唯一。

这从两个方面来实现防护：**1.链段的竞争力；2.客户端的主链绑定**。


### 链段的竞争因子

在Bitcoin的PoW工作量竞争机制里，累加的难度也是保护历史区块的因素，如果攻击者算力不够，就无法构造出更长的支链来替换主链。这种机制简单有效，到目前为止运行良好。

本设计采用固定地区块创建时间，不存在最长链的逻辑，如果有攻击者从某个高度分叉出一条支链，双花原主链上的交易并参与主链竞争，那该如何确定正确的主链呢？这就是下面对区块及其链段的竞争力的设计。

链段的竞争力来源于区块的竞争力，区块的竞争力来源于竞争因子，它们被设计在区块头内。

区块头结构（共 `80+32` 字节）：

```go
BlockHeader: {
    Version   uint32    // 协议版本
    PrevBlock [32]byte  // 前一区块哈希
    YearBlock [32]byte  // 前一年块哈希（height % 87661 == 0 有效）
    Height    uint32    // 区块高度
    CheckRoot [32]byte  // 校验根（类似Bitcoin里的MerkleRoot）
    // 竞争因子
    Phases    uint32    // 择优权重（择优池前2位+铸造者 相位差和合计/3）
    Stakes    uint32    // 币权销毁（单位：币天）
}
```

择优权重是择优凭证中 `前2位 + 铸造者` 的合计平均值，如果铸造者就是前2名之一，会双倍之。这样可以把实际铸造者的增益（第1名铸造）或损益（由靠后者铸造）也考虑进来。即：区块的实际铸造者在择优池中越靠前越好。

> **附注：**<br>
> 年块指从创始区块开始，每年引用一次形成年块链。主要用于附生侧链对主链的高效引用。<br>
> 币权销毁更有真实性，但仅统计历史标记有效的交易，这使得攻击者无法通过打包对方链上的交易来获得优势。<br>
> 区块头80字节（有年块时+32字节）用于计算区块哈希。区块头年数据量：80x87661 ~= 6.688MB。<br>
> 存储竞争因子的数据类型仅有4字节，通常情况下不会溢出。但如果会溢出，则存储为最大值本身（0xffffffff）。<br>


### 纵向评估的竞争力

通常来说，因为有择优池的预选和同步，新区块又有足够的传播时间，主链的分叉很难出现。但如果真的出现了（或者攻击发生了），以下规则和算法会应用到两条或多条竞争的分叉上，评选出确定的主链：

1. 参与竞争评估的链段长度必须到达 `240个` 区块（1天）。即支链必须成长到足够的高度才能竞争主链，这使得攻击者必须维持支链足够长的时间，且持续获得强大的高权重基本盘支持才行，这需要付出极大的代价。
2. 竞争因子的取值是链段长度内全部区块该因子的合计值，即纵向合计，因此称为纵向评估。之后再按不同因子进行分级评估。竞争流程如下。

**竞争流程：**

1. **择优权重**：合计各支链段区块的择优权重值，计算链间平均值。如果两条支链该值的差低于平均值的 `1%` 则视为相等，否则值小者胜。
2. **币权销毁**：合计各支链段区块的币权销毁值，值大者胜。
3. **最终唯一性**：如果上面的对比依然无法确定胜负，则简单取分叉后首个区块的哈希值本身对比，值小者胜。


### 发现分叉

不同于Bitcoin里节点力图发现最长链，本设计中链段的增长完全固定，所有的分叉长度都一样。如果节点不去请求和检查区块头链，就需要一个高效的发现分叉的机制，从而避免节点长时间处于一条弱的分叉上。

发现分叉可以通过接收到的交易数据体现出来，即交易头里的历史标记会无效。此时客户端可作如下评估（建议）。

1. 如果发现有较多的合法交易仅仅是历史标记错误，就可以判定存在分叉了。请求分支区块头链，获取分叉链段信息。
2. 保持自身主链不变，持续收集信息至少 `100个` 区块，然后评估分叉支链的竞争力。
3. 如果分叉链段竞争力极强，可以考虑立即切换。否则保持本链不变继续收集到 `200个` 区块左右，如果分叉明显优势，可以切换主链。
4. 如果两条分叉竞争力不相上下，则应等待 `240个` 固定区块数到达，以最终竞争力计算实现主链切换。

> **注记：**<br>
> 正常情况下，历史标记错误的交易不会被收录进区块，除非是在分叉合并阶段（见下）。<br>
> 在240个区块长度之前切换主链后，节点参与的铸造竞争也会跟着变换，这实际上可以强化目标分支，增强其竞争力。<br>


### 分叉合并

分叉支链上的交易可以提取出来被主链合并，是一件很重要的事，它可以避免当分叉出现后用户的畏惧心理：你不知道该把交易绑定到哪一条链。分叉合并可以解决这一难题。

合并只在主链竞争已经明确后才进行，通常是 **按顺序逐块提取** 支链上的交易（不再理会历史标记）。因为铸币交易只能认可一方，源于分叉支链上的新币的交易是无效的，当然支链上的双花交易也会被排除。

如果主链出现了分叉，合并机制可以让用户继续交易，只是会有一些限制。


### 客户端绑定主链的外部约束

在区块链系统中，客户端App通常需要硬编码创始区块的信息，提供主链起始的正确性，使得其它链无法冒充正常的主链。这种做法简单直接而且绝对有效。扩展这种思路，如果我们在客户端App上也硬编码绑定中间区块的信息，是否可以从根本上锁定主链呢？这种锁定在客户端升级发布时进行，不断的发布更新，不断地锁定前进中的区块，从而维持一种根本性的主链保护？

这是一种缺乏技术含量的粗暴做法，但如果可行，则是对区块链及其历史的一种简单而又根本性的保护：不需要复杂的机制设计，也没有性能上的负担。这里试作如下分析：

> 区块链是基于一个去中心化的P2P网络，不同的客户端遵循同样的协议相互连接协作，一个客户端没有理由去绑定一个错误的创始区块，那太荒谬了。在分叉之前，主链是唯一的，如果客户端绑定某个中间段区块，不会有任何异样，人们对这样的行为是无感的，除非主链开始分叉。
>
> 逻辑上，在主链分叉以前，客户端一直跟随当前的主链，如果突然出现一条起始于绑定结点之前的竞争支链，客户端是完全可以忽略的（因为目标已经锁定）。如果这个结点位置恰当，就可以成为一种通用的约定，从而获得主链的稳定。

客户端是开源的，它们硬编码的目标区块可以查看到。一个客户端发布出来，在信息上它就处于了公共领域。错误的绑定会被发现，也会被抵制，它们不得不接受公众的监督。

不同的客户端由不同的开发者或语言实现，它们可能并不严格实施这项规范，但官方的客户端应该保证这样做（且开源）。新版本的绑定基于运行中的旧版本的当前数据，绑定的结点在分叉之前，所以不存在歧义或分叉裁决的权力问题。


#### 绑定规则

1. 运行期动态绑定。运行着的客户端会记下2天前第 `-480号` 区块的哈希，每新出一个区块更新一次。
2. 发布时硬编码绑定。从运行着的客户端获取当前绑定，嵌入在发布的新版本里（无需严格的时效性）。
3. 在线成长或突然出现的长度小于 `240块` 的支链会被纳入主链竞争评估，更长的支链因为超出限制会被忽略。

由于客户端的这种普遍性约定行为，**超过2天（480块）的历史区块将获得几乎绝对的保证**。

这不是一种纯技术，它是一种社会化现实效果在技术结构中的应用。从另一个角度看，它其实是开发者对现实世界里主链共识的一种固化，它们被简单地书写在客户端里而不是借助于某种算法，是一种社会化行为但依然也是一种共识确认。


### 设计参数

> 区块头长度为 `80字节`（不计年块），包含两个链段竞争因子：择优权重和币权销毁。<br>
> 竞争主链的分支必须成长到 `240个` 区块才有效，没有成长到该长度的断链会被忽略，因此上面的交易实际上无法回收。<br>
> 链段评估中择优权重的容差为 `1%`，容度内视为相等。这只是设计者一个直觉的值，没有经过论证。<br>
> 客户端对主链的动态绑定为末端 `-480号` 区块，发布时的静态编码从运行着的客户端中获取。<br>
> 客户端对主链绑定的外部约束是一种社会性共识而不是数学算法，这不好看但可能是一个重要特点。<br>



## 交易的传输

区块是交易的集合，交易的传输影响着铸造者们对交易的期望以及区块的内容。一位贪婪的铸造者可能试图等待尽量多的交易而影响出块时间，而交易时间戳的任意性也会让时间戳缺乏意义。为了某种有序化，需要设计如下规则。


### 适时转播

交易的时间戳与节点本地的时间相比较，如果它属于未来，这笔交易就称为 **未来交易**，区块不收录未来的交易（相对于出块时间点），这是一个基本设计。但定义交易时间戳在未来是允许的，它们只是暂时处于链外，类似于Bitcoin中交易的链外锁定。

这些交易会被正常的校验和转播，但有一个例外：**当前区块时段内的** 未来交易不立即转播，节点应等待时间到达后才转播出去，这就是「适时转播」。

这一约定主要用于配合零确认的安全机制，确保双花交易只在恰当的时间可见（详见后）。

> **注：**<br>
> 未来交易可能无法绑定相应的-11号区块，历史标记位应当置零。这不影响收录，但会失去铸造资格。


### 错时延迟

当一笔交易传播至节点时，交易的时间戳可能晚于（小于）当前节点的实际时间，如果这一差距较大，就称这是一笔**错时交易**。区块可以收录错时的交易（它们属于过去），但这些错时交易可能成为铸造者贪婪的诱饵，影响他们按时出块，所以这里设计了一个约定：

**当出块时间到达后，节点停止时间戳在出块时间之前的错时交易的转播，直到该区块被创建、广播并确定下来，之后再恢复这些交易的传输**。这就是「错时延迟」。这不会影响时间戳在下一区块时段内的交易的正常传输。


### 设计要点

> 当前区块时段内的未来交易应当等到时间到达后才转播。这是零确认安全的前置措施。<br>
> 时间戳在活跃区块时间戳之前的错时交易会暂停传播，直到活跃区块真正确定下来。这可以避免铸造者的贪婪等待。<br>



## 区块的结构和同步

逻辑上，区块只是一个抽象容器，包含交易的索引用于检索交易数据本身。交易索引由 `32字节` 的交易ID和 `8字节` 的交易时间戳构成（`32+8`），它们在区块里有序排列，让区块的构造拥有一种确定性。

### 排序规则

1. **一级排序**：交易索引的前8字节转换为整数（大端序），然后对255取模运算值排序。
2. **二级排序**：如果一级排序相等（同组），则简单地按交易索引本身的字节序列排序。

**说明：**
> 用交易索引前8字节取整数是为了获得一种随机性，避免可能的ID塑造捣乱。<br>
> 对255取模分组是为了快速定位和压缩排序的子集。注：不是对256取模（留出一个值有用）。<br>
> 这一排序规则与UTXO指纹（后续说明）的分级排序规则相兼容。<br>


### 四元链哈希树

区块需要验证，在Bitcoin中是通过对交易ID集的默克尔树来实现。本设计中采用功能类似的四元链哈希校验树结构，如下图。

<img src="images/list4th-1050x700.png" width="1050" alt="四元链哈希树结构" />

**说明：**
- 平行的链式结构方便逐层或跨层地提取哈希值，实现快速的交互对比。
- 最末端的交易索引叶子节点依然可以简单定位，整个序列有序排列。
- 该哈希树仅在最终出块时构建，并不用于内存结构中动态插入交易信息。


### 区块的同步

区块可能包含大量的交易，假设有64k笔，则区块所涉及的数据可能达数十上百兆。这使得在一个较短的区块时段内传输全部数据很困难，至少是不可靠。

但实际上事情并没有那么糟糕，因为如果节点一直在线，区块所涉及的交易大多已经被节点收集和验证了（数据已经存在）。区块之所以需要同步，是因为铸造者打包了它，而铸造者收集的交易集可能稍有不同。所以，区块同步实际上只需要厘清并补足那些少量差异的部分，然后节点自行构造区块即可。

如下分组结构被用于当前区块交易的动态插入和同步时的差异对比。

#### 255段分组

1. 一级分组：255个单元（即上面的一级排序），每单元为一组。
2. 二级成员：上面每一组中包含各自的交易索引，按交易索引的字节序列排序（上面的二级排序）。

**对比结构图**

<img src="images/blocksync-1050x600.png" width="1050" alt="区块同步对比结构" />

> **注：**
> 基本上，这可以看作是一个宽成员的三级哈希校验树。

区块同步前，铸造者计算每一组的交易子集的哈希根，然后合并255个单元的哈希根计算根哈希（`Root'`）。当同步对比时，如果接收到的根哈希不同，则说明交易集有差异，于是就可以对255组的哈希根并行地进行对比，查找差异并请求缺少的交易。

为了全网尽快统一共识，区块的广播只需要包含必要的区块证明：

- Coinbase交易；
- 分组校对的哈希树根（`Root'`）；
- 四元链哈希树根（`CheckRoot`）；
- 相关的签名数据。


### 设计要点

> 区块同步只需要对比发现不同的部分然后补足即可，交易ID在区块内的有序排列是一种确定性约束。<br>
> 区块的发布只需要包含必要的可验证数据，实现快速广播。之后再同步交易数据。<br>
> 四元链哈希树被用于构造区块验证（区块头内的校验根）和历史区块对比下载的用途，类似于默克尔树。<br>



## 零确认的安全性

交易在网络上的传输没有先后顺序，原则上，交易一旦广播出去便无法撤回。如果存在双花的交易，铸造者会优先打包时间戳更早的交易（暂不考虑交易费问题），这是一个简单的约定，也是零确认安全机制的前提。

攻击者可以构造两笔相同输入源的双花交易，其中一笔时间戳更早（可能交易费也更高）但晚一点发送。如果接收者认可零确认，在收到前一笔交易后发货或让顾客拿货离开，但最终进入区块的却是后一笔交易。这会让零确认的安全无法实行。

不过，借助于更精细的一些规则设计，我们可以很大程度上避免这种攻击行为。

> **注：**<br>
> 零确认安全有一个时间上的阈值，这里的设计是1分钟。即：收款方需要等待至少1分钟才能确认安全。


### 时序保障

双花交易可能来自于用户的纠错行为：发送一笔交易后发现失误，立即重构一笔新交易发出。这是允许的，但有一些约束。

1. 更正交易需要设置为更早的时间戳。考虑可靠性，交易费不应当低于前一笔失误交易。
2. 更正交易需要在失误交易发送后1分钟之内发出。这是一个规定阈值，否则更正交易会被丢弃。

对于一个中转节点来说，接收到交易验证合法后会存储到内存池中，同时也需要记录交易的实际收到时间（注：可以是与交易时间戳的差值）。如果发现新收到的交易是一笔双花交易，它们根据下面的规则行事。

1. 如果新交易的时间戳更晚（值更大），则忽略丢弃。因为区块应当收录更早的交易。
2. 如果新交易的时间戳更早（值更小），则检查时间戳与当前实际时间的误差：1分钟内视为更正交易正常转播，否则视为双花攻击丢弃。
3. 如果新交易的时间戳与原交易相同，则检查原交易的实际收录时间，如果在1分钟之内，也视为正常的更正交易转播，否则视为双花攻击丢弃。

> **注：**<br>
> 阈值之内的双花交易可以被铸造者观察到，收录较早交易只是一个松约束（可自由裁定）。


#### 攻击分析

**攻击：**

- 方式：前一笔交易提前发送，但时间戳设置得比较晚（值大），后一笔交易晚发送，但时间戳设置得比较早（值小）。
- 目的：希望前一笔交易被商家认可，但区块实际收录后一笔交易。
- 约束：两笔双花交易的实际发送时间差需要大于 `1分钟`，因为商家会要求等待1分钟以上（安全阈值）。

**分析：**

1. 前一笔交易的时间戳如果晚于实际时间，会被「适时转播」规则阻塞，因此商家并不会提前看到这一笔交易。
2. 前一笔交易的时间戳如果早于当前实际时间，转播不受影响，但第二笔交易的时间戳必须更早，如果时差超过阈值，则会被「时序保障」规则滤掉。
3. 如果两笔交易的时间戳相等，交易的传播受实际收录时间相差1分钟的阈值保护，这也不会有问题。

**结论：**

1. 双花的第二笔交易广播时间超出阈值后，实际上很难广播出去，所以铸造者很难收到第二笔交易。
2. 收款者收到一笔支付后，稍微等待一段时间（1分钟+），就可以看到是否存在双花的情况，然后自行处理。


### 最低交易费

交易费是矿工的重要收入来源，提供服务收取费用是一种正常的逻辑。区块收录交易的数量是有限的，因此交易费的高低源于市场的驱动，但一个恰当的最低交易费规则是有益的。

本设计的铸造资格源于历史交易，最低交易费的门槛可以与币权一起，提高仅仅为铸造资格构造大量细微交易的成本。另外，如果没有此规则，太低的交易费可能导致铸造者长期不收录它们，弃置太久的交易会最终失效（2天），这瓦解了零确认的安全性。

最低交易费由前期的平均交易费自动计算而来：**系统每 `24000个` 区块（100天）统计一次，取平均值的 `1/5` 作为当前阶段的最低交易费**。这是一个端点间公约而不是交易协议，各个端点检查交易费情况，低于最低值的交易将被丢弃。

**注意**：零确认安全只是一种简单设计，应当只用在小额收款上。如果你有大额交易，等待真正的区块确认会更好。


#### 附：交易过期

未被收录的交易超过一定时间后会作废，这个期限设计为2天（`480个` 区块）。过期是按交易的时间戳和当前时间对比判断的，它的意义在于：

1. 缩减未确认交易的规模。
2. 提升时间因子的价值，为某些应用提供条件。

人们不应当期待一笔超过2天都未完成（确认）的交易依然有效，漫长的期待实际上也有一种负面的心理效应。


### 设计要点

> 铸造者优先打包时间戳更早的交易，这是处理双花交易的基本规则，但它是一个宽松约束。<br>
> 交易更正有一个 `1分钟` 的时间容度（阈值），超过之后的交易将被视为双花攻击而被阻塞。<br>
> 收款方如果认可零确认交易，应当等待至少 `1分钟` 以发现是否存在双花攻击。<br>
> 最低交易费采用前期 `24000个` 区块平均交易费的 `1/5` 作为当前阶段的值，但这只是一个端点公约。<br>
> 长时间游离于链外的交易会过期，按时间戳计算超过2天 `480个` 区块时段即为失效。<br>



-------------------------------------------------------------------------------

上一篇：[共识模型-概率证明（PoP）](1.共识模型-概率证明（PoP）.md)<br>
下一篇：[公共服务](3.公共服务.md)<br>
