//////////////////////////////////////////////////////////////////////////////
Copyright (c) 2019 - 2024 @cxio/blockchain

    Permission is granted to copy, distribute and/or modify this document
    under the terms of the GNU Free Documentation License, Version 1.3
    or any later version published by the Free Software Foundation;
    with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
    A copy of the license is included in the section entitled "GNU
    Free Documentation License".
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&


在传统的设计中，一个复杂的系统往往被分解为拥有内在逻辑的简单子系统，这是构造复杂系统的方法。如果我们把P2P网络整个看作一个系统，根据P2P网络运行所需要的逻辑，实际上可以从区块链系统中分解出一些通用公共的服务组件。

这些公共服务组件也是开放的P2P网络，任何人都可以参与，用户只需要贡献CPU、内存或磁盘资源。不同公共服务的资源需求是不同的，有的依赖于磁盘存储，有的偏向于大内存，而一个节点发现服务仅仅需要一台树莓派或安卓手机就可以了。


## 服务的分解

系统可以分解为 `2个通用的公共服务`、`2个寄居微服务`，它们为基础层级，是通用和公共的P2P服务网络。具体的各类区块链系统相对于公共服务则为应用层，这些应用层相对于终端用户则也是一种公共的服务。

1. **节点发现（findings）**：作为一个基础服务，负责应用节点的登记、缓存，提供节点相互连系的信息。功能简单，独立组网。
2. **数据驿站（depots）**：数据传输的中转和停靠，可能实现为一个容器，封装内部微服务的数据请求，实现数据的全网流通和交互。
3. **档案存储（archives）**：一个微服务，存储区块中交易携带的附件数据。由数据驿站封装，无需直接的网络能力。
4. **区块查询（blockqs）**：一个微服务，分离区块数据的存储负担，提供公共的区块查询。同上由数据驿站封装，自身无需网络能力。
5. **区块链应用（xxx...）**：负责自身交易的具体应用。是上面4种公共服务之下的应用层，自身组网成为应用网络，依托于公共服务网络。

> **注：**<br>
> 区块查询通常仅服务于某一特定的区块链，但档案存储和节点发现则可服务于任何区块链应用。<br>


### 服务关系图

<img src="images/serv4nets-920x620.png" width="920" alt="服务关系图" />

**说明：**
- Peer为区块链应用节点，相互连接形成自己的P2P网络，同时也与公共服务节点（F，Da, Db）保持连接。
- 同类公共服务节点之间相互连接形成自己的P2P服务网络，其中findings节点是其它所有网络节点的连系中介。
- 括号内的信息表示连接包含，如：Peer通常应连接3个F节点，4个Da和4个Db节点、10个同类节点。



## 节点发现（findings）

提供各种类型节点的登记注册，维护一个节点连系信息的暂存池，向请求目标类型节点信息的用户提供连系清单。节点类型包含同类节点（findings）、应用节点（各种区块链）和其它公共服务节点（Da, Db）。另外，作为P2P网络的基础性支撑，提供NAT打洞服务的连接协助（多机协作，无需双IP）。

通常，应用节点会启动一个自己的findings服务器，该服务器通过多种方式搜寻其它findings服务节点进行组网。如果存在已知的公共findings节点，组网会很快，否则可能是一个比较耗时的过程，如果需要findings实时可用，运行一个长期在线的服务器（挂机）可能更简单。

服务器会向请求节点信息的区块链应用提供同类区块链的地址，用于接收可能有的奖励。除了公共服务节点外，对不同的区块链应用可能有所选择，当然公益包容的态度也未尝不可。服务器通常会先声明自己支持的区块链标识名，或者是支持任意的区块链。


### 吝啬的区块链

对公共服务节点的奖励不是强制的，也没有简单的办法去约束，因此自私的区块链应用可能并不乐意支付报酬。这很糟糕，但可能事实也并非如此严重。

在铸造收益里划出一部分作为外部奖励，并不是一件很困难的事，甚至都可能不是一种损失，因为区块链的价值来源于用户对它的信任或观感，一条吝啬的区块链和一条公允的区块链，它们给用户带来的观感有什么区别呢？当然，或许世事难料……但可以有信心。


### 关于非区块链应用

公共服务的运行基于区块链代币激励的能力，这对于非区块链的普通P2P应用来说没有意义，它们可能很难获得这些公共服务的支持（虽然逻辑上公共服务是P2P通用的）。但是，如果有一条专门服务于非区块链应用节点连系的区块链，事情就有所不同了。

普通的P2P应用购买某区块链代币，获得同类节点发现的能力（或者更多），从而实现简单容易的组网……这是可能的。


### 项目参考

节点发现：[github.com/cxio/findings](https://github.com/cxio/findings)



## 数据驿站（depots）

在传统的P2P网络里，相同应用的节点间相互连接，交互彼此需要或拥有的数据，不同应用之间是隔离的（即便操作的是同一份数据）。数据驿站服务试图在不同的应用系统之间抽象出统一的接口，专门操作数据本身，最大限度地剥离应用的负载，同时也提高效率。

实际上，这样的数据服务可以成为P2P网络的通用数据层，如果把网络比喻为一台计算机，这一数据层就类似于文件系统的服务。

数据驿站是一个「壳」，管理数据在全网的流通和缓存，内部由具体的微服务实际操作数据（如：archives、blockqs）。基本上，这可以理解为一个内含数据仓库或处理器的数据中转站，数据是变动的：增加、减少、选择性存储、或特定的处理等。

数据驿站之间相互连接组网，构成一个P2P的数据流动层，从而支持开放的数据存储模式。


### 数据的紧缺性感知

P2P网络节点对数据的请求是通过广播查询，没有目标数据的节点会转播请求，拥有数据的节点则回应而不再转播。如果设计请求每转播一次就跳数加一（最大值15），则通过跳数的大小，节点就可以感知请求广播的距离，距离越远说明数据越紧缺，这可以促使节点补充存储紧缺的数据。

驿站之间相互协作共同存储，通过数据的紧缺性感知进行自愿冗余弥补，但这种自愿存储无法保证数据的完备性。虽然对数据需求的利益驱动可以缓解这一问题，但仍不足够，我们需要一些公益性的稀有数据保全节点来补充保障（详见下：**数据心跳**）。

这是P2P逻辑下一种模糊的全网存储协调机制，没有绝对的保证但或许冗余性足够，主要是简单易行。

**关于跳数作弊**

应用对自己重视的数据可以设置较高的起跳数再发起请求，这会欺骗存储服务节点对数据紧缺性的判断，从而获得较高冗余度的存储，这是可能的。

但另一方面，存储节点自己也拥有评估的能力：它们自己发起数据请求，起跳数并不固定但自己清楚，如果返回的应答包中的跳数（终点跳数记录反馈）与起跳数差距不大，说明数据可能并不紧缺。或者，如果有签名认证的公共 **数据心跳服务器**，则也可以获得恰当的反馈。

另外，请求的跳数也有一个上限值（如15），超出之后请求会被丢弃，因此太高的起跳数也会抑制请求广播的范围，这对作弊不利。

> **注：**<br>
> 如果节点请求的数据较为敏感，起跳数为0会暴露请求的源位置，因此非零起跳数是一个建议的安全性措施。


### 数据服务

**数据检索：**

1. 区块链应用向驿站请求目标数据，传递服务名称和数据标识作为定位，驿站收到请求后向内部的目标服务查询数据。
2. 内部服务根据数据标识查询数据，如果没有找到，根据自身的配置策略，向外请求数据或只是简单地告知查询结果。
3. 感知数据的紧缺性，根据配置向内部的微服务提供存储建议。


**数据写入：**

1. 写入数据的请求由应用端发起，提供服务名称和数据标识，驿站向内部的目标服务传递写入请求。
2. 目标服务根据数据标识检查数据是否已经存在，如果存在则忽略，否则根据自己的配置策略决定是否存储或者忽略。
3. 如果决定存储，主动发起数据请求，从充当种子的应用节点处获取实际数据。

> **注：**<br>
> 如果为新数据，驿站本身也可能配置为主动请求并缓存，而不管内部微服务的配置。这是一个可能的优化。<br>

**附：数据服务的4种行为**

1. **给**：只读输出，向应用提供数据。
2. **存**：对内写入，向应用提供存储服务，具体行为由内部微服务自己决定。
3. **要**：数据获取，向其它驿站或应用本身请求数据，实施存储计划或数据补充。通常在应用请求发现无数据时触发。
4. **转**：写入转播，对新数据的写入进行缓存并中转，扩散数据的分布。


### 数据心跳

数据的紧缺性感知并不完全可靠。有些数据的用户很少或使用率很低，这样对这些数据的请求会很少，它们可能被慢慢遗忘，在长期的存储中被清理出去，最后丢失。因此需要一个方法来保证它们的存在性感知，这就是数据心跳。

数据心跳是一个形象的比喻，它实际上是由节点持续发出的数据探测（探测包）。探测不是真实的数据请求，只是一个包含了标记说明的数据查询：拥有数据的节点无需回应，没有数据的节点正常转播。于是数据的紧缺性又可以被觉察了。

执行数据探测的通常是一些公益性节点，因为数据索引（ID）都已存在于区块链上，所以节点按索引间断发出探测请求即可。这些探测节点被称为心跳节点，理论上应该在地理位置上均衡分布，也不需要太多。


### 项目参考

数据驿站：[github.com/cxio/depots](https://github.com/cxio/depots)



## 档案存储（archives）

这里的档案存储不是广义上的P2P文档自由存储，而是指区块链上交易里所包含的附件，这些附件并不存储在区块链上（交易中只有一个附件ID），而是存储在archives公共服务网络中，这是区块链世界里的一个基础服务。


### 文档索引与元信息

文档索引用于检索交易附件文档本身，主要采用附件ID来构造存储路径。文档类型和一些相关的元信息存储在 .meta 文件中，通常为简单的文本描述。

```go
文件名：[索引ID].*      // 文档数据，索引ID即为数据的哈希摘要
元信息：[索引ID].meta   // 文档元信息，文本格式，可能有多语言版本
```


### 固化存储的可能

档案的逻辑是不可修改，只有写入和检索读取，甚至删除都不应该有，通常也是长期保存。因此对于档案存储，可以简化设计：

1. 仅包含读取和添加两种逻辑，没有修改和删除的操作。
2. 缩小存储规模仅能通过转储实现：读取 >> 过滤 >> 添加到新仓库。
3. 没有删除操作是一种实用性考虑，以获得一种有意的「不方便」约束。

因为没有修改和删除，这类似于一种固化存储（如并不高效的光盘刻录），它能带来一些难得的优点：

1. 便于优化存储，提高数据库效率。
2. 没有修改就没有覆写，仅单次写入的优势可能发展出廉价的存储介质，使得大规模存储更易行。
3. 安全性更有保障。因为若是单次写入，除非物理上的破坏，不存在覆写丢失的问题。
4. 因为简单和安全，在维护成本上也会有更好的表现。


### 项目参考

档案存储：*github.com/cxio/archives*



## 区块查询（blockqs）

将区块数据单独存储并提供必要的查询服务，可以对区块链系统中庞大存储负载进行分离。

借助于UTXO指纹的设计，当前区块所需的UTXO集合可以轻易验证。因为存在公共的区块查询服务，全节点不再必需，普通的节点就可以完成所需的验证工作。另外，区块数据托付于单独的服务网络，也使得数据的缓存和共享更有效率。

> **注：**
> 如果交易规模较大，可以采用组队校验的分片工作模型。详见「附1：组队校验」。

因为验证节点会存储近期的区块以及UTXO集内的交易数据，查询服务并不会有想象中的那样繁忙，它们可能更多地服务于对漫长历史区块的检索。

具体的区块存储结构和设计，详见 blockqs 项目文档。


### UTXO指纹

UTXO是区块链所有未花费输出的集合，为了方便节点初始载入时对当前UTXO集进行验证，设计添加了UTXO指纹的逻辑。


#### UTXO指纹结构图

<img src="images/utxo5hash-1050x780.png" width="1050" alt="UTXO指纹结构" />

这其实是一个宽成员的哈希校验树，总共四层的分级可减少每次输出指引改变带来的重新计算的数据量。顶层为年度，虽然是一个无限增长的序列，但粒度足够大，可接受。


#### 意义

UTXO指纹会对区块链末端产生合法性约束，实际上，它有些像全链交易历史的当前总结。正因如此，一个刚刚上线的节点可以请求并不太多的数据量（区块头链、末端11个区块、以及当前UTXO集合），就可以大致确定目标主链是否合法，然后再同步客户端硬绑定高度之后的区块进行完整校验。

这可以极大地降低新节点进入的门槛，提升区块链系统的整体效率。


### 附：UTXO指纹的循环递进约束

#### 当前区块与当前UTXO集合

> 当前区块是指当前正在验证交易数据，即将创建的区块。当前UTXO集合是当前区块所依据的UTXO集合，它尚未减去当前区块所收录交易的花费。<br>
> 当前UTXO集去除掉当前区块收录交易的花费，加上新的输出和Coinbase铸币，就成为当前区块的UTXO结果集。<br>

当前区块的UTXO指纹从当前UTXO集合计算而来，计算的是上一区块完成后的UTXO结果集。这样的设计可以为UTXO指纹计算留出足够的时间，而附带地也获得了一种循环递进的约束，使得可以从当前UTXO集循环递进逆向推导和验证整条区块链。


#### 推导流程示例

- 假设当前区块为101号，当前UTXO集即为第100号区块的UTXO结果集。
- 当前UTXO集减去第100号区块的新输出和Coinbase铸币、加上第100号区块的输入花费，可得到第100号区块的当前UTXO集。
- 计算这个集合的指纹，它应当与第100号区块记录的UTXO指纹相同。这样就验证了（101号区块的）当前UTXO集合的合法性。
- 如果再用第100号区块的当前UTXO集减去第99号区块的新输出和Coinbase铸币，以及同样的输入处理，就可以验证第100号区块的当前UTXO集。
- 如此循环递进，我们就可以从一个最新的UTXO集合逆向验证区块链至任意历史位置。

另外，UTXO指纹表达的是上一区块的UTXO结果集，这使得指纹的约束是链式的，攻击者无法通过单个区块的交易ID塑造来匹配UTXO指纹。


### 项目参考

区块查询：*github.com/cxio/blockqs*



-------------------------------------------------------------------------------

上一篇：[共识模型-端点约定](2.共识模型-端点约定.md)<br>
下一篇：[激励机制](4.激励机制.md)<br>
