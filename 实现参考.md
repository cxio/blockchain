# 实现参考

## 交易

### 交易头

类似于区块头抽象了区块数据，这里设计了交易头结构。伪代码示意：

```go
// 简化版示意：
TxHeader {
    Version    int32    // 版本
    Timestamp  int64    // 交易时间戳
    LeadHash   Hash384  // 首领输入哈希
    HashBody   Hash384  // 数据体哈希
}
```

首领输入的部分单独计算一个哈希，便于铸造者的验证。首领输入中包含完整的信息：接收者公钥、金额、解锁数据、锁定脚本。

整个交易头的哈希即为**交易ID**。

> **注记：**
> 解锁数据包含除签名以外的合约需要的输入信息，因此不能简单丢弃。

HashBody 可能由分开的输入和输出部分别自计算而来：

```go
// ([4][48][4][48])
HashBody = Hash384([长度][输入段哈希] + [长度][输出段哈希])
```


### 交易体

#### 输入项

由3个字段构成：年度、交易ID、输出序位。

- `[n]`  交易所在年度。这是一个概略的时间约束，可方便管理。
- `[48]` 交易ID的全引用。仅限首笔输入（首领输入）。
- `[20]` 交易ID的前段局部引用。用于除首笔输入之外的其余输入，短片段以节省空间。
- `[n]`  输出项下标序位。大多数都只需要1字节表达（<128）。

首领输入也用于铸凭交易的属主检索，因此采用全序列 `48` 字节，便于验证。其它输入使用 `20` 字节片段，以降低数据量。

所有的输入项都从当前UTXO集中检索，不支持未确认交易的输出项作为输入项。


#### 输出项

如果输出配置为销毁，可将地址设置为 `null`。销毁输出的脚本任意，通常置空或为一个`NIL`指令，但也不排除用户构建有意义的脚本。

一个非标准的地址通常意味着自定义验证（不使用 `SYS_CHKPASS`）。


### 铸币交易（Coinbase）

包含铸造者证明和收益分成，以及其它信息：

- 区块高度：明确Coinbase交易的位置。
- 择优凭证：区块铸造者证明，也用于分叉之后的链段竞争。
- 收益总额：铸币 + 交易费 + 兑奖截留。
- 收益分成：铸造者（校验组）、铸凭者（铸凭交易提供者）、Findings、Blockqs、Archives奖励。
- 自由数据：类似于Bitcoin，为铸造者提供灵活性（<256字节）。



## 区块

### 区块头

区块头结构，日常约 `108` 字节：

```go
BlockHeader: {
    Version   int       // 版本，变长存储（Varint）
    PrevBlock [48]byte  // 前一区块哈希
    CheckRoot [48]byte  // 校验根（由交易哈希树根和UTXO指纹及签名而来）
    Stakes    int       // 币权销毁（币天）
    Height    int       // 区块高度
    YearBlock [48]byte  // 前一年块哈希（height % 87661 == 0 时）
}
```

> **说明：**
> 年块指从创始区块开始，每年引用一次上一个年块。年块链可用于高效且节省的主链引用。
> 区块头约108字节（有年块时+48字节）用于计算区块哈希。区块头年数据量：108x87661 ~= 9MB。
> 币权销毁除了参与择优权重计算，它还表达交易量，作为区块竞争的一个辅助安全因子。


### 区块限定

提前预设，避免后期共识困难。

区块限定仅限于对数据量（尺寸）的约束，数据包含解锁部分：

- 第 `1~3` 月：固定为 **1MB**。
- 第 `4~36` 月：逐月递增 **1MB**，最终到 **34**MB。
- 第 `4` 年起：每年递增 **2MB**（注：该年为36MB），直到大小为 **100**MB。
- 之后每年递增 **1MB**，直到 **2GB** 止。

> **注：**
> 按恒星年计算，每年 `87661` 个区块，每月 `7305` 个区块。


### 收录优先级

共约：铸造者遵循如下的优先级收录交易到区块。

- 输入项时间戳较早的交易。最优。
- 币权销毁或交易费更多的交易。次优。



## 凭信

### 创建

即初次创建，没有输入项，任何人都可以凭空创建。

创建时决定凭信是否可修改，并置位新建标记。如果可修改，置位相关标记。


### 转移

将凭信的属主转移为新的接收者。

如果凭信可修改，则转移时可根据规则做出修订（改变描述），并置位*是否修改*标记位。否则只能改变接收者和锁定脚本。

在转移时也可以改变可修改性：由可修改变为不可修改。**注意**：这是单向的，不能由不可修改变为可修改。


### 合规性

根据凭信的可修改性以及是否修改标记，检查凭信的转移是否合规。

- **不可修改**：只有接收者和锁定脚本可变，创建者为一个引用。
- **可修改**：只有描述可以改变，且*是否修改*标记位应当置位。



## 附件

### 附件ID的结构

```go
(1)     总长定义：1字节（<256）。
(1+1)   附件类型：由2个字节表达，前一字节为大类，后一字节为小类。
(~)     附件大小：变长整数，单位：字节。
(1)     附件指纹强度：附件数据哈希的增益长度：0=>40，1=>41，24=>64。
(40-64) 附件指纹。附件数据的哈希，算法 `BLAKE3`，长度由用户自己决定（最低 40）。
(2)     分片数量：2字节表达（< 65536）。
(48)    存证哈希。按二元结合计算的哈希树根（默克尔树或二元链树），主要用于存储抽检。
```

> **注：**
> 若每分片最大 `2MB`，则64k个分片可表达 `128GB` 数据。


#### 规则：

- 分片逻辑始终存在。无分片视为一个分片，这应当仅用于小文件（如：≤2MB）。
- 哈希树的叶子节点为各分片数据的哈希（48字节），且前置2字节序号，共50字节。
- 附件类型参考 HTML:MIME 文档类型分类……

> **注：**
> 叶子节点前置2字节顺序号用于抽检的约束性嵌入，详见后叙。


### 附件的存储抽检

数据网络存储交易的附件以获得区块链节点的奖励，这需要验证。验证是一种随机抽检，如下流程：

1. 区块链节点随机选择一笔交易的附件，参考其分片数量生成一个随机序号。
2. 向源节点发送该附件的存证哈希和该序号，要求其提供分片数据和验证该数据的相关联的路径哈希。
3. 区块链节点得到数据后：计算分片哈希，前置序号，结合路径哈希计算树根哈希。
4. 比较树根哈希和存证哈希，如果相同，则说明源节点存储了该数据。

> **要点：**
> 分片哈希的前置序号由验证者添加，因此源节点无法作弊。

**注：**
> 由附件大小和分片数量可以测算出分片大小，这也可以用于某种辅助性交叉核实。


### 关于附件的大小

原则上，附件不限制大小，但它可能影响交易费：附件越大，费用应当越高。

但区块链节点很难核查附件大小的真实性。不过如果附件信息不实，可能会被数据网络视为不良行为，或认为数据损坏而丢弃。

大附件通过P2P应用分享传输，存证哈希可能会被复用，但应用节点之间的分片传输策略是自由的。

> **数据价值：**
> 如果附件是开放版权的公共文档，数据本身的价值可能会让数据网络更乐意持有。



## 脚本

### 源码的格式

源码应当有良好的格式，以便于阅读和书写。

像大部分程序语言一样，换行和缩进是自由的，但指令之间仅以空白（空格/制表符/换行等）分隔。


#### 指令码的解译显示

脚本指令序列解译为文本展示时，遵循如下换行和缩进规则。

- **子块缩进**：包含子语句块的结构指令会将内容换行并缩进显示。
- **行长限制**：连续的指令显示不会太长，必要时换行。
- **独行指令**：包含较长值的指令通常显示在单独一行，比如：`DATA{}`、大整数或正则表达式等。
- **行尾指令**：显示在行尾时含义更清晰，比如：`PASS`、`RETURN`、`EXIT` 等。
- **跟随指令**：与前阶指令紧密相关，应当显示在同一行。如模式指令中的取值 `#(1)`、带实参的 `@POP RETURN` 等。
- **前缀指令**：是后阶指令的前置指令，应当与后阶指令紧邻。如截取指令：`@`、`~` 等。

如果行长限制与其它规则冲突，视情况灵活处理，如折行或提前换行。



## 杂项

### 哈希校验树

类似Bitcoin中默克尔树的校验功能。

<img src="images/hashcheck-1050.svg" width="1050" alt="哈希校验树结构" style="background-color:#333; padding:10px 30px; border-radius: 20px;" />

> **图解：**
> - 每一层节点都是一条哈希单元序列，可能为数组或链表。
> - `Minting sign` 为铸造者对哈希树根（TreeRoot）和 `UTXO指纹` 的签名，合并计算 `CheckRoot`。

**注**：每一层的长度可以根据下层长度计算出来。


### UTXO指纹

UTXO集是区块链所有未花费输出的集合，为方便节点初始载入时对当前UTXO集进行验证，添加了UTXO指纹设计。

另外，UTXO指纹实际上与区块ID一起，构成了一种对区块链历史的双路保护。


#### UTXO指纹结构图

<img src="images/utxohash-1180x700.svg" width="1180" alt="UTXO指纹结构" style="background-color:#333; padding:20px; border-radius: 20px;" />

这其实是一个宽成员的哈希校验树，总共四层的分级可减少每次输出指引改变带来的重新计算的数据量。顶层为年度，虽然是一个无限增长的序列，但粒度足够大，可接受。


#### 意义

UTXO指纹会对区块链末端产生合法性约束，实际上，它有些像全链交易历史的当前总结。正因如此，一个刚刚上线的节点可以请求并不太多的数据量（区块头链、末端9个区块、以及当前UTXO集合），就可以大致确定目标主链是否合法。

这可以极大降低新节点进入的门槛，提升区块链系统的整体效率。

> **附注：**
> 对于无限延伸的漫长区块头链，实际上还可以籍由年块链来获得更小的数据体积。


### 附：UTXO指纹的链式约束

#### 当前区块与当前UTXO集

- **当前区块**：指当前正在验证交易数据，即将创建的区块。
- **当前UTXO集**：当前区块所依据的UTXO集合，它尚未减去当前区块所收录交易的花费。

当前UTXO集去掉当前区块收录的交易的花费，加上新交易的输出项和Coinbase铸币，即为下一个区块的当前UTXO集。

当前区块的UTXO指纹从*当前UTXO集*计算而来。因为无需考虑新交易的收录变化，所以计算时间充裕。并且这还附带创建了一种循环递进的链式约束。


#### UTXO集的逆向推导和链式约束

当前UTXO集是上一个区块的UTXO结果集，根据上一个区块收录的交易，可以逆向推导出*上一区块*的*当前UTXO集*。

假设当前区块为101号，当前UTXO集即为第100号区块的UTXO结果集。

1. 当前UTXO集减去100号区块的新交易输出项和Coinbase铸币，加上100号区块的输入项，即为100号区块的当前UTXO集。
2. 计算这个集合的指纹，它应当与100号区块上的UTXO指纹相同。
3. 这样就验证了101号区块的当前UTXO集的合法性。

如果再用100号区块的当前UTXO集推导99号区块的当前UTXO集并验证……循环迭代，我们就可以从一个最新的UTXO集逆向验证区块链至任意历史位置。

这样，UTXO指纹实际上就和区块ID的链式绑定，从不同的侧面共同锁定了区块链的历史。
