# 实现参考

## 交易头

类似于区块头抽象了区块数据，这里设计了交易头结构。

交易中的输入和输出部分会分别计算哈希，然后两者合并计算的哈希即为交易体数据的哈希，交易头的哈希即为**交易ID**。

```go
// 交易ID：
// 长度参与哈希计算，增强嵌入式约束。
Hash384(输入段长度:输入段哈希 + 输出段长度:输出段哈希)
结构：([4][48][4][48])

// 附注：
// 交易数据序列内的长度采用变长整数标记。
```


### 交易头结构

简化版伪代码：

```go
TxHeader {
    Version    int32     // 版本
    Timestamp  int64     // 交易时间戳。设定为未来时间可处于链外游离等待
    HashBody   Hash384   // 数据体哈希，Hash(输入摘要+输出摘要)
}
```

已经验证的区块链是安全的，所以交易的解锁数据可能在适当的时候被移除，也因此，交易的解锁数据并不参与计算交易ID。



## 交易结构

### 输入项

由3个字段构成：年度、交易ID、输出序位。

- `[n]`  交易所在年度。这是一个概略的时间约束，可方便管理。
- `[48]` 交易ID的全引用。仅限首笔输入（首领输入）。
- `[20]` 交易ID的局部引用（前段）。用于除首笔输入之外的其余输入，短片段以节省空间。
- `[n]`  输出项下标序位。大多数都只需要1字节表达（<128）。

首领输入也用于铸凭交易的属主检索，因此采用全序列 `48` 字节，便于验证。其它输入使用 `20` 字节片段，因为这只是一个索引，会从当前UTXO集中检索。

这样可以有效降低输入部分的数据，友好多输入项的交易。


### 输出项

支持 `null` 地址，表示销毁。null地址不可花费，因此也不会进入UTXO集。

null地址的金额若为零，表示全部输入都是交易费。此时应当只有这一笔输出，否则没意义（普通输出已包含交易费逻辑）。

> **注：**
> nill地址是一个特殊值，其输出脚本不可作为输入。
> 但这不影响交易者构造有意义的脚本，可能有它自己的特别用途。

一个非标准的地址表示自定义验证，注意与 `null` 的区别！

非标准的地址无论如何都应该有些什么，比如一个E-mail，或名称之类的东西。



## 区块头结构

区块头结构，日常约 `108` 字节：

```go
BlockHeader: {
    Version   int       // 版本，变长存储（Varint）
    PrevBlock [48]byte  // 前一区块哈希
    CheckRoot [48]byte  // 校验根（由交易哈希树根和UTXO指纹及签名而来）
    Stakes    int       // 币权销毁（币天）
    Height    int       // 区块高度
    YearBlock [48]byte  // 前一年块哈希（height % 65746 == 0 有效）
}
```

> **说明：**
> 年块指从创始区块开始，每年引用一次形成年块链。可用于对主链的节省和高效引用。
> 币权销毁具有统计价值，也用于铸凭哈希计算里未知的X信息。
> 区块头约108字节（有年块时+48字节）用于计算区块哈希。区块头年数据量：108x65746 ~= 6.8MB。



## Coinbase交易

包含铸造者证明和收益部分，以及必要的其它信息：

- 区块高度：明确Coinbase交易的位置。
- 择优凭证：区块铸造者证明，也用于分叉之后的链段竞争。
- 收益总额：铸币 + 交易费 + 兑奖截留。
- 收益地址：铸造者（校验组）、铸凭者（铸凭交易提供者）、Findings、Blockqs、Archives奖励。
- 定制数据：类似于Bitcoin，为铸造者提供灵活性。最长255字节。



## 四元链哈希树

代替Bitcoin中默克尔树的功能，快速校验底层局部交易ID叶子节点。

<img src="images/list4th-1050x700.svg" width="1050" alt="四元链哈希树结构" style="background-color:#333; padding:10px 30px; border-radius: 20px;" />

> **图解：**
> - 每一层节点都可以形成一条贯穿的链表，方便直接获取特定层级的成员。
> - 每层链表中末尾不足4个的并无特殊处理，简单串联哈希即可，单个成员时再哈希一次。
> - `Coinbase sign` 为铸造者对哈希树根（TreeRoot）和 `UTXO指纹` 的签名数据，共同参与 `CheckRoot` 计算。

平行的链式结构方便逐层或跨层地提取哈希值，实现快速的交互对比。该哈希树仅在最终出块时构建。



## UTXO指纹

UTXO集是区块链所有未花费输出的集合，为了方便节点初始载入时对当前UTXO集进行验证，添加了此UTXO指纹设计。

另外，UTXO指纹实际上与区块ID一起，构成了一种对区块链历史的双路保护。


### UTXO指纹结构图

<img src="images/utxohash-1180x700.svg" width="1180" alt="UTXO指纹结构" style="background-color:#333; padding:20px; border-radius: 20px;" />

这其实是一个宽成员的哈希校验树，总共四层的分级可减少每次输出指引改变带来的重新计算的数据量。顶层为年度，虽然是一个无限增长的序列，但粒度足够大，可接受。


### 意义

UTXO指纹会对区块链末端产生合法性约束，实际上，它有些像全链交易历史的当前总结。正因如此，一个刚刚上线的节点可以请求并不太多的数据量（区块头链、末端9个区块、以及当前UTXO集合），就可以大致确定目标主链是否合法。

这可以极大降低新节点进入的门槛，提升区块链系统的整体效率。

> **附注：**
> 对于年度漫长的区块头链，实际上还可以借用年块来获得更小的数据体积。


### 附：UTXO指纹的链式约束

#### 当前区块与当前UTXO集

- **当前区块**：是指当前正在验证交易数据，即将创建的区块。
- **当前UTXO集**：是当前区块所依据的UTXO集合，它尚未减去当前区块所收录交易的花费。

> **注：**
> 当前UTXO集去掉当前区块收录的交易的花费项，加上新交易的输出项和Coinbase铸币，即为下一个区块的当前UTXO集。

当前区块的UTXO指纹从*当前UTXO集*计算而来。因为无需考虑当前区块收录交易的情况，所以计算时间充裕。并且附带还获得了一种循环递进的链式约束。


#### UTXO集的逆向推导

当前UTXO集是上一个区块的UTXO结果集，根据上一个区块收录的交易，可以逆向推导出上一区块的当前UTXO集。

假设当前区块为101号，当前UTXO集即为第100号区块的UTXO结果集。

1. 当前UTXO集减去100号区块的新输出项和Coinbase铸币，加上100号区块的输入项，即可得到100号区块的当前UTXO集。
2. 计算这个集合的指纹，它应当与100号区块上的UTXO指纹相同。
3. 这样就验证了101号区块的当前UTXO集的合法性。

如果再用100号区块的当前UTXO集推导99号区块的当前UTXO集并验证……循环迭代，我们就可以从一个最新的UTXO集逆向验证区块链至任意历史位置。



## 脚本系统

### 凭信的转移验证逻辑

**可修改凭信：**

- 无输入源时：表示初始新建。新建标记位置位，可修改标记位置位。
- 有输入源时：表示凭信转移。保持当前可修改时，按「修订传递」验证；转为不可修改时，可修改标记清位，修改转换标记置位。

**不可修改凭信：**

- 无输入源时：表示初始新建。新建标记位置位，可修改标记位置零。
- 有输入源时：表示凭信转移。检查输入源新建或修改转换标记位，置位则为「引用传递」（记录源交易ID），否则为「复制传递」（复制源交易记录的值）。


> #### 凭信源身份记录
> - 引用传递：输出中记录凭信源引用：交易年度 + 交易ID + 输出项序位。
> - 复制传递：输出中记录与输入源的记录保持一致（即记录的值不变）。


> #### 修订传递逻辑
> 如果内容发生了变化（包括附件变化），都视为新建逻辑，新建标记位置位。
> 如果内容未变，新建标记清位。凭信源记录根据输入源情况采用引用传递（新建时）或复制传递（非新建）。。


#### 说明：

- 可修改凭信可以通过清位修改标记而转变为不可修改凭信，但反过来则不行。这是一个有意的限制。
- 由可修改转为不可修改后，修改转换标记置位。如果内容已修改，新建标记也需置位。
- 凭信源身份的引用/复制传递使得追溯创建者很容易，这有时很有用，比如追溯子链的创建者以实施某种验证（「侧链微支付」）。


### 附件ID的结构

```go
(1)     ID总长定义。最长可支持到255字节。
(1+1)   附件类型。由两个字节表示，前一字节为大类，后一字节为小类。
(n)     附件大小。标明实际附件内容的数据量，变长整数。
(48+)   附件哈希序列。最低48字节长，采用 `BLAKE3` 可变长哈希算法，给用户更多灵活性。
(32)    分片哈希。把附件按特定大小分片后，合并计算的哈希树根（类似Torrent），固定32字节长。主要用于存储抽检和传输。可选。
```

其中末尾的*分片哈希*是可选的，仅用于大附件。规则为：

- **2MB 以下**：无分片哈希。附件直接由Blockqs服务器负责提供。
- **2MB ~ 10MB**：分片可有可无。附件可以由Blockqs服务器负责，但如果用户更想把附件存放在数据网络上，则需分片。
- **10MB 以上**：有分片哈希。附件只能由数据网络存储和提供，必须分片。

分片大小的规则：

- **小附件**：规格为 `16/32/64kb`。最小16KB。
- **大附件**：规格为 `256/512/1024kb`。最大1MB。

> **注：**
> Blockqs可保证2MB文件的直传，即一个分片文件可以有2MB大小。
> 如果采用最大分片1MB的话，2MB分片文件可支持64GB附件大小（2MB/32 * 1MB）。
> 分片文件也有自己的meta配置，会明确分片的大小。

附件的大小可能影响交易费。这并不会被核查，但如果不实，可能会被数据网络视为不良行为而放弃存储。

用户支付的交易费会部分返还给存储系统（数据网络），因此适当增加付费是说得通的。

> **关于存储：**
> 本区块链系统有奖励数据网络存储的机制，这是一个辅助保障。但这并不是绝对的保证。
> 如果附件是开放版权的公共文档，在一个以数据为核心的未来，数据的价值本身也是一个保障。

大附件通过P2P分享应用传输，分片哈希可能被复用，但客户端也可能自行协商不同的分片规则。



## 源码的格式

源码应当有良好的格式，以便于阅读和书写。

换行和缩进是自由的，指令之间仅以空白（空格/制表符/换行等）区隔。

### 解译源码的显示

脚本指令序列解译为文本展示时，遵循如下换行和缩进规则。

- **子块缩进**：包含子语句块的结构指令会将内容换行并缩进显示。
- **行长限制**：连续的指令显示不会超过一定长度，超过时即换行。
- **独行指令**：单个指令通常不会被断开显示，因此包含较长值的指令会显示在单独一行，比如：`DATA{}`, `TEXT{}`, 大整数和正则表达式等。
- **行尾指令**：部分指令显示在行尾有更好的含义表达，比如：`PASS`, `FAIL`, `RETURN`, `EXIT` 等。它们会导致当前行结束。
- **跟随指令**：部分指令与前阶指令紧密相关，它们应当显示在同一行，比如模式指令中的取值指令 `#(1)`, `&(1)` 或带取值实参的 `BREAK` 等。
- **前缀指令**：部分指令是后阶指令的前置指令，它们应当与后阶指令显示在一起，比如：`@`, `~`, `$`, `?(1)` 等。

如果**行长限制**与其它规则冲突，视情况灵活处理。比如强制折行或提前换行。
