# 实现参考

## 交易

不同于Bitcoin的交易历史只是一种存储，这里的交易历史有后期的各种需求（识别脚本应用、介管脚本引用、第三方二次开发等）。因此交易数据结构需要便于检索和验证。

检索和验证主要采用哈希校验树的方式，类似于Bitcoin的默克尔树，但细节稍有不同。


### 交易头

类似于区块头抽象了区块数据，这里设计了交易头结构。伪代码示意：

```go
// 简化版示意：
TxHeader {
    Version    int      // 版本
    Timestamp  int64    // 交易时间戳
    HashBody   Hash512  // 数据体哈希
}
```

HashBody 由分开的输入和输出部分别自计算而来。交易头的哈希即为交易ID。

```go
TxID: Hash512( TxHeader )
HashBody: Hash512( InputHash + OutputHash )
```


### 交易体

#### 输入项

由3个字段构成：年度、交易ID、输出序位。

- `[n]`  交易所在年度。这是一个概略的时间约束，方便管理。
- `[64]` 交易ID的全引用。仅限首笔输入（首领输入）。
- `[20]` 交易ID的前段局部引用。用于除首笔输入之外的其余输入，短片段以节省空间。
- `[n]`  输出项下标序位。大多数都只需要1字节表达（<128）。

首领输入也用于铸凭交易的属主检索，因此采用全序列 `64` 字节，便于验证。其它输入使用 `20` 字节片段，以降低数据量。

所有的输入项都从当前**UTXO**集中检索，UTXO集是可靠的（有UTXO指纹），因此20字节的引用只涉及重名问题，与安全无关。

> **注**：不支持未确认交易的输出项作为输入项。


#### 输入项校验哈希

首领输入单列为一项，剩余输入项作为列表串接计算哈希。

```go
// 由首领输入和其余输入项串接计算。
InputHash: Hash512(LeadHash + RestHash)
```

首领输入单列，便于铸造者快速定位和验证凭证属主。

```go
LeadHash: Hash512(
    Year      int       // 交易年度
    TxIDPart  [64]byte  // 交易ID前64字节
    OutIndex  int       // 输出项序位
)
```

剩余输入项作为列表串接计算哈希：

```go
RestHash: Hash512( ListOf(RestInputs) )
RestInput: {
    Year      int       // 交易年度
    TxIDPart  [20]byte  // 交易ID前20字节
    OutIndex  int       // 输出项序位
}
```


#### 输出项

如果配置为销毁，可将地址设置为 `null`。输出脚本任意，通常置空或一个`NIL`，但也不禁止用户构建有意义的脚本。一个非标准的地址通常意味着自定义验证（没有 `SYS_CHKPASS` 指令）。

各个输出项作为叶子节点，计算哈希校验树。哈希树根与输入项哈希一起，合并计算交易体哈希。

```go
OutputHash: Hash512( Tree<Outputs> )
Output: {
    Serial      int         // 输出序位（从0开始）
    Amount      int64       // 数量（最小单位）
    Address     [48]byte    // 接收地址（公钥地址哈希）
    LockScript  []byte      // 锁定脚本
    ...                     // 其它可选字段
}
```

> **注：**
> 各输出项作为叶子节点单独构建哈希校验树，便于独立验证和定位。


### 铸币交易（Coinbase）

包含铸造者证明和收益分成，以及其它信息：

- 区块高度：明确Coinbase交易的位置。
- 择优凭证：区块铸造者证明，也用于分叉之后的链段竞争。
- 收益总额：铸币 + 交易费 + 兑奖截留。
- 收益分成：铸造者（校验组）、铸凭者（铸凭交易提供者）、Findings、Blockqs、Archives奖励。
- 自由数据：类似于Bitcoin，为铸造者提供灵活性（<256字节）。



## 区块

### 区块头

由区块头计算区块ID，连续的区块头形成区块头链。

伪代码示意：

```go
BlockHeader: {
    Version   int       // 版本号
    PrevBlock [64]byte  // 前一区块哈希
    CheckRoot [64]byte  // 校验根（由交易哈希树根、UTXO指纹及签名合并计算）
    Stakes    int       // 币权销毁（币天）
    Height    int       // 区块高度
    YearBlock [64]byte  // 前一年块哈希（height % 87661 == 0 时）
}
```

**其中：**
- 币权销毁除了参与择优权重计算，它还表达交易量。能作为区块竞争的一个辅助性安全因子。
- 年块指从创始区块开始，每年引用一次上一个年块（按87661/年）。可用于更高效和节省地引用主链。

如果整数按4字节计算，区块头长140字节（年块除外），区块头年数据量：140x87661 ~= 11.7MB。


### 区块限定

提前预设，避免后期共识困难。

区块限定仅限于对数据量（尺寸）的约束，数据包含解锁部分（但不含标准签名）：

- 第 `1~3` 月：90天，固定为 **1MB**。
- 第 `4~36` 月：按每月30天，逐月递增 **1MB**，最终到 **34**MB。
- 第 `4` 年起：每年（87661/年）递增 **2MB**（注：该年为36MB），直到大小为 **100**MB。
- 之后每年递增 **1MB**（注：如到 **2GB** 时止，约2千年）。

> **注：**
> 年度按恒星年（`87661` 个区块）计算，月度则简单按30天（`7200` 个区块）计算。


### 收录优先级

共约：铸造者遵循如下的优先级收录交易到区块。

- 输入项时间戳较早的交易。最优。
- 币权销毁或交易费更多的交易。次优。



## 凭信

### 创建

即初次创建，没有输入项，任何人都可以凭空创建。

创建时决定凭信是否可修改，并置位新建标记。如果可修改，置位相关标记。


### 转移

将凭信的属主转移为新的接收者。

如果凭信可修改，则转移时可根据规则做出修订（改变描述），并置位*是否修改*标记位。否则只能改变接收者和锁定脚本。

在转移时也可以改变可修改性：由可修改变为不可修改。**注意**：这是单向的，不能由不可修改变为可修改。


### 合规性

根据凭信的可修改性以及是否修改标记，检查凭信的转移是否合规。

- **不可修改**：只有接收者和锁定脚本可变，创建者为一个引用。
- **可修改**：只有描述可以改变，且*是否修改*标记位应当置位。



## 附件

### 附件ID的结构

```go
(1)     总长定义：1字节（<256）。
(1+1)   附件类型：由2个字节表达，前一字节为大类，后一字节为小类。
(~)     附件大小：变长整数，单位：字节。
(1)     附件指纹强度：按4字节增量：0=>40, 1=>44, 2=>48, ... 6=>64。
(40+)   附件指纹。附件数据的哈希，算法 `BLAKE3`，长度由用户自己决定（最低 40）。
(2)     分片数量：2字节表达（<65536）。
(48)    片组哈希。按二元结合计算的哈希树根（类默克尔树），叶子节点含前置2字节序号。
```

> **注：**
> 若每分片最大 `2MB`，则64k个分片可表达 `128GB` 数据。


#### 规则：

- 分片数量为 `0` 时，表示无分片，后续片组哈希全为0（无意义）。
- 分片数量为 `1` 时，与无分片相同，但此时片组哈希是相应算法的附件数据哈希。
- 分片数量为 `>1` 时，表示有分片，片组哈希由正常的含序哈希校验树计算而来。
- 哈希树的叶子节点为各分片数据的哈希（48字节），另外前置2字节序号，共50字节。
- 附件类型参考 HTML:MIME 文档类型分类……

> **注：**
> 叶子节点前置2字节顺序号方便随机检索和验证。


### 附件的分片验证

如果需要附件数据的局部分片，可以通过序号简单获取和验证。

1. 向源节点发送附件的分片哈希和序号，请求分片数据。
2. 源节点提供分片数据和验证该数据的关联路径哈希。
3. 用户得到数据后：计算分片数据的哈希，前置序号，结合路径哈希计算并验证片组哈希（是否相同）。

> **要点：**
> 在分片数据的哈希前置序号由验证者实施，源节点无法作弊。


### 关于附件的大小

原则上，附件不限制大小，但它可能影响交易费：附件越大，费用应当越高。

但区块链节点很难核查附件大小的真实性。不过如果附件信息不实，可能会被数据网络视为不良行为，或认为数据损坏而丢弃。

大附件通过P2P应用分享传输，存证哈希可能会被复用，但应用节点之间的分片传输策略是自由的。

> **数据价值：**
> 如果附件是开放版权的公共文档，数据本身的价值可能会让数据网络更乐意持有。



## 脚本

### 源码的格式

源码应当有良好的格式，以便于阅读和书写。

像大部分程序语言一样，换行和缩进是自由的，但指令之间仅以空白（空格/制表符/换行等）分隔。


#### 指令码的解译显示

脚本指令序列解译为文本展示时，遵循如下换行和缩进规则。

- **子块缩进**：包含子语句块的结构指令会将内容换行并缩进显示。
- **行长限制**：连续的指令显示不会太长，必要时换行。
- **独行指令**：包含较长值的指令通常显示在单独一行，比如：`DATA{}`、大整数或正则表达式等。
- **行尾指令**：显示在行尾时含义更清晰，比如：`PASS`、`RETURN`、`EXIT` 等。
- **跟随指令**：与前阶指令紧密相关，应当显示在同一行。如模式指令中的取值 `#(1)`、带实参的 `@POP RETURN` 等。
- **前缀指令**：是后阶指令的前置指令，应当与后阶指令紧邻。如截取指令：`@`、`~` 等。

如果行长限制与其它规则冲突，视情况灵活处理，如折行或提前换行。



## 杂项

### 哈希校验树

类似Bitcoin中默克尔树的校验功能。

<img src="images/hashcheck-1050.svg" width="1050" alt="哈希校验树结构" style="background-color:#333; padding:10px 30px; border-radius: 20px;" />

**图解：**
- 每一层节点都是一条哈希单元序列，可能为数组或链表。
- `Minting sign` 为铸造者对哈希树根（TreeRoot）和 `UTXO指纹` 的签名，合并计算 `CheckRoot`。
- 叶子节点为交易ID的哈希序列（计算时前置序号，可能为固定3字节长）。
- 哈希长度可能采用64字节（SHA-512），以提升安全性。

> **注：**
> 若采用数组，每一层的长度可以根据下层长度计算出来。


### UTXO指纹

UTXO集是区块链所有未花费输出的集合，为方便节点初始载入时对当前UTXO集进行验证，添加了UTXO指纹设计。

另外，UTXO指纹实际上与区块ID一起，构成了一种对区块链历史的双路保护。


#### UTXO指纹结构图

<img src="images/utxohash-1180x700.svg" width="1180" alt="UTXO指纹结构" style="background-color:#333; padding:20px; border-radius: 20px;" />

> **注：**
> 顶层分级的年度指交易时间戳对应的年度（UTC）。

这其实是一个宽成员的哈希校验树，总共四层的分级可减少每次输出指引改变带来的重新计算的数据量。顶层为年度，虽然是一个无限增长的序列，但粒度足够大，可接受。


#### 意义

UTXO指纹会对区块链末端产生合法性约束，实际上，它有些像全链交易历史的当前总结。

正因如此，一个刚刚上线的节点可以请求并不太多的数据量（区块头链、末端9个区块、以及当前UTXO集合），就可以大致确定目标主链是否合法了。

这可以极大降低新节点进入的门槛，提升区块链系统的整体效率。

> **附注：**
> 对于无限延伸的漫长区块头链，实际上还可以籍由年块链来获得更小的数据体积。


### 附：UTXO指纹的链式约束

#### 当前区块与当前UTXO集

- **当前区块**：指当前正在验证交易数据，即将创建的区块。
- **当前UTXO集**：当前区块所依据的UTXO集合，它尚未减去当前区块所收录交易的花费。

当前UTXO集去掉当前区块收录的交易的花费，加上新交易的输出项和Coinbase铸币，即为下一个区块的当前UTXO集。

当前区块的UTXO指纹从*当前UTXO集*计算而来。因为无需考虑新交易的收录变化，所以计算时间充裕。并且这还附带创建了一种循环递进的链式约束。


#### UTXO集的逆向推导和链式约束

当前UTXO集是上一个区块的UTXO结果集，根据上一个区块收录的交易，可以逆向推导出*上一区块*的*当前UTXO集*。

假设当前区块为101号，当前UTXO集即为第100号区块的UTXO结果集。

1. 当前UTXO集减去100号区块的新交易输出项和Coinbase铸币，加上100号区块的输入项，即为100号区块的当前UTXO集。
2. 计算这个集合的指纹，它应当与100号区块上的UTXO指纹相同。
3. 这样就验证了101号区块的当前UTXO集的合法性。

如果再用100号区块的当前UTXO集推导99号区块的当前UTXO集并验证……循环迭代，我们就可以从一个最新的UTXO集逆向验证区块链至任意历史位置。

这样，UTXO指纹实际上就和区块ID的链式绑定，从不同的侧面共同锁定了区块链的历史。


### 含序哈希校验树

- 叶子节点含有前置序号的哈希值，可用于随机检索和验证。
- 适用于附件分片和区块内交易的自由定位提取和验证的场景。
- 也可用于优化交易数据的节点间同步（未知交易ID，但确知缺失的位置信息）。


### 交易存储

- 数据部分：以交易年度（按交易时间戳计算）和交易ID为索引，存储交易的完整数据。由需要数据的用户使用。
- 验证部分：以区块年度和高度为索引，存储区块内交易ID列表，可提供哈希校验树的验证路径哈希序列。由验证者使用。

> **注：**
> 用户拥有区块头链（及关联数据），可以按区块高度验证交易数据。


#### 交易的查询和验证

已知交易ID和交易时间戳（或年度），用户可以定位到交易数据及其元信息。

元信息中包含交易所在的区块和序位，于是可以定位并获取验证关联的部分，结合交易数据本身，即进行完整验证。

> **注：**
> 用户拥有区块头链即必要的关联数据。它是交易验证的总根。


### 自签名证书的使用

自签名证书不用一次性（App运行后即时生成）设计，含有一个合理的短暂有效期（如：几小时到几天）可能更好。

这样可以避免应用短时间内多次启动造成的注册信息无效问题。同时也便于登记信息过期的移除管理。
