//////////////////////////////////////////////////////////////////////////////
Copyright (c) 2019 - 2023 @cxio/blockchain

    Permission is granted to copy, distribute and/or modify this document
    under the terms of the GNU Free Documentation License, Version 1.3
    or any later version published by the Free Software Foundation;
    with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
    A copy of the license is included in the section entitled "GNU
    Free Documentation License".
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

## 基础指令集

**实现**：承载指令的锁定/解锁脚本在验证过程中应当是只读的。项目参考：https://github.com/cxio/script

> **注：**
> 下面的代码并非Go语言代码，仅为高亮以友好阅读。


### 1. 值指令

在脚本中作为一个实际的值存在，直接自动入栈，**没有实参**。

对于前面3个值指令（**0-2**），指令值本身即代表其表达的值。对于前段的数值类值指令，附参即为其数据。对于后面的复杂值类型，小括号内的数字指示了其数据的长度（字节数）。如果小括号内是 `~` 字符，表示这是一个变长字节整数（值本身或后续数据长度定义）。

指令值区间：`[0-19]`，20个。

```go
指令码  指令字      说明
-----------------------------------------------------------
0       NIL         空值
        // 即Go语言中的 nil 值。

1       TRUE        真值（true）
2       FALSE       假值（false）
        // 类型：Bool，布尔值。
        // 在源码中书写指令字/名，解析为指令码值。
        // 例：
        // TRUE 解析为脚本指令码值 1，运行时解码为 true。


// 以下指令的附参即为值数据。

3       {}(1)       单字节存储：-uint8  [-255, 0]
4       {}(1)       单字节存储：uint8   [0, 255]
5       {}(~)       变长字节存储：-uint63 [-1<<63, 0/-256]
6       {}(~)       变长字节存储：uint63  [0/256, 1<<63 - 1]
        // 类型：Int/int64，整数。
        // 附参：指令的关联数据。
        // 从源码解析为指令时，数据值的大小自动决定使用哪个指令。
        // 变长整数采用 Uvarint 存储，最多占用9字节（除了最小负值-1<<63）。
        // 例：
        // {12756}  入栈正整数，指令选用6（uint63）。
        //          脚本中指令序列：首字节值6，后续变长字节存储 12756
        // {0xfff0} 入栈正整数，支持十六进制表示。
        // {200}    入栈正整数，指令使用3（uint8）。
        // {-200}   入栈负整数，指令使用4（-uint8）。
        //
        // 友好：
        // 支持单下划线分隔书写，如 {12_345} 实为整数 12345。
        // 支持多个值在一个{}内连续书写，如：
        // {100, 200} 源码解析器会自动将之拆分为 {100} {200}。
        // {100, 3.14, 400} 支持不同类型混写。
        //
        // 注记：
        // 系统内部会统一转换为 Int（int64）类型后使用。

7       {}(1)       字节类型：byte
        // 类型：Byte，字节。
        // 附参：关联的字符数据（单字节长）。
        // 格式：
        // {'A'} 单引号包围目标字符A。
        // - 支持常规转义表达，如 {'\n'}，一个换行符值（10）。
        // - 支持16进制转义表达，如 '\x41'，即字符 'A'（65）。

8       {}(4)       字符类型：rune
        // 类型：Rune，字符。
        // 附参：关联的Unicode字符，但限于无法用单字节存储的部分。
        // 格式：
        // {'嗨'} 单引号包围的 Unicode 字符。
        // - 支持 '\uhhhh' 或 '\Uhhhhhhhh' 转义。
        // 如：
        // '\u4e16' => '世'，同 '\U00004e16'
        //
        // 说明：
        // 字符类型与 byte 类型采用相同的单引号包围格式，
        // 源码解析器会根据值的大小自动判断存储类型（byte 或 rune）。

9       {}(4)       四字节浮点数存储：float32
10      {}(8)       八字节浮点数存储：float64，即 Float
        // 类型：Float，浮点数。
        // 附参：指令的关联数据。
        // 源码书写时必须包含小数点，支持科学记数法。
        // 解析为指令时，值的大小自动决定使用哪个指令。
        // 例：
        // {3.14159} 入栈浮点数 3.14159。使用4字节存储。
        // {2.1606e108} 超出float32容量。使用8字节存储。
        //
        // 注记：
        // 系统内部会统一转换到 float64（Float）类型后使用。

11      DATE{}(~)   时间对象
        // 类型：Time。
        // 附参：UNIX时间戳（毫秒）。
        // 有符号变长整数存储（Varint），支持负时间戳。
        // 花括号内书写为标准格式的时间表达式（RFC3339）。
        // 例：
        // DATE{2020-11-24T15:04:05Z}
        // DATE{2020-11-24T15:04:05+08:00}
        // DATE{2020-11-24T15:04:05.456+08:00}
        // 注：
        // 格式串中秒数后面可附加毫秒，以句点连接。
        // 仅支持RFC3339，更多的格式可使用日期模块 MO_TIME。


// 以下指令的附参标明数据的长度（字节数）。

12      {}(1)+N     大整数，字节长度不定（<256）
        // 类型：BigInt。
        // 附参：实际数据占用的字节数。
        // 注：也即Go语言中 math/big 包里的Int类型。
        // 例：
        // {0x8000ffff_8000ffff_8001}
        // 超出了int64的表示范围，会被解析为大整数。
        //
        // 注记：
        // 大数值通常用16进制书写，值内支持下划线友好分隔。

13      DATA{}(1)   字节序列数据。1字节附参（短）
14      DATA{}(2)   字节序列数据。2字节附参（长）
        // 类型：Bytes，字节序列。
        // 附参：实际数据的长度（字节数）。
        // 源码书写时使用16进制字符串，解析时值的长度自动决定指令值（若未指定附参）。
        // DATA{}(2) 指令2字节附参最大可表示64kb数据。
        // 例1：
        // DATA{46af3fb481837fadbb421727f9959c2d} 入栈16字节值，按16进制解析。
        // 解析后的指令序列：
        // [16|16|0x46|0xaf|0x3f|...]
        // 其中：指令码（16）1字节，附参值（16）1字节，后续16字节数据。
        // 例2:
        // DATA[8]{46af3fb4} 入栈8字节，后续不足者用0值填充。
        // 解析后的指令序列：
        // [16|8|0x46|0xaf|0x3f|0xb4|0|0|0|0] 指令码+附参值+数据共10字节。
        // 注：
        // 花括号内的16进制字符串无需前置 0x 标识。

15      TEXT{}(1)   文本数据。1字节附参（短）
16      TEXT{}(2)   文本数据。2字节附参（长）
        // 类型：String，字符串。
        // 附参：实际字符串 `UTF-8` 编码字节数。
        // 从源码解析为指令序列时，文本的字节长度自动决定使用哪个指令。
        // 例：
        // TEXT{Hello}      入栈 Hello 文本串。
        // TEXT{ Hello }    同上，首尾空格视为显示友好（非数据，可选）。
        // TEXT{"Hello "}   若需在首尾包含空白，需要使用双引号包围。
        // 注意：
        // 不必也不应当手工指定附参值大小。

17      /.../(1)    正则表达式
        // 类型：RegExp。
        // 附参：表达式占用字节数。
        // 双斜线之内即为正则表达式的内容（regexp/syntax RE2）。
        // 例：
        // /(?i)[a-z0-9]+/  匹配ASCII字母和数字，忽略大小写
        // /(?i)Zip-(\d+)/  忽略大小写，包含一个子匹配式（捕获组）

18      CODE{}(1)   代码/指令序列
        // 类型：Script。
        // 关联数据为一段解析后的指令序列（指令码+附参+数据）。
        // 附参：序列长度。
        // 例：
        // CODE{
        //      TOP FN_HASH256 DATA{<hashResult>} EQUAL PASS
        // }
        // 入栈一段哈希屏障验证的指令序列。
        // 附参无需书写，将由解析器解析后自动设置。换行只是一种友好。
        //
        // 注记：
        // 仅支持最长255字节的直接指令书写，以约束嵌入代码的规模。
        // 数据中的指令名称仅在解析时有意义，并不执行。

19      （未用）
```


### 2. 截取指令

包含“截”和“取”两种操作类型：

1. 拦截跟随指令的返回值。拦截后，跟随指令的返回值不再自动入栈，而是放入实参空间（`@`），或者添加到当前的局部域中（`$`）。
2. 从几个特殊地方提取值。`$(1)` 从 `$` 指令存放的局部域中取值，`${}(1)` 从循环域中取值。附参定义了取值位置。

另外还有一个特殊的**实参直取**指令（`~`）：它标记跟随指令将跳过实参区直接从数据栈取实参。该指令对**无实参**和**不定参数**的指令无效，如果它在这种指令之前，会被简单忽略。

这是几个用特殊符号表示的指令，功能独特。作为一种显示友好，符号与后面的跟随指令可无需空格分隔。该类指令**无实参**。

指令值区间：`[20-24]`，5个。

```go
指令码  指令字      说明
-----------------------------------------------------------
20      @           实参捕获
        // 拦截后一个指令的返回值添加到实参区。
        // 因为实参空间是一个值队列，所以也可以形象地理解为放入当前位置。
        // 例1：
        //      {0} @PEEKS[2] @SPREAD PRINT[16]
        // 获取栈底2个值的切片放入实参区，展开该切片，向控制台打印它们。
        // 例2：
        //      @POPS[3] OUTPUT BUFDUMP
        // 弹出栈顶3项数据为一个切片，输出到缓存区并转储清空。
        // 注：
        // 如果@后面是实参直取指令~（见下），会简单跳过。

21      ~           实参直取
        // 指示后一个指令的实参将从数据栈直接提取（跳过实参空间）。
        // 这是一种主动的取值渠道切换。
        // 该指令通常与后面的指令紧邻，但空格是可选的。
        // 如果目标指令同时也前置了拦截指令（@|$），则本指令应当在拦截指令之后，目标指令之前。
        // 例：
        // ~EQUAL   直接取栈顶两个值比较相等与否，返回一个布尔值入栈。
        // @~EQUAL  同上取栈顶两个值比较，但结果被截取放入实参区。
        // $~EQUAL  同上比较，结果添加到当前局部域。
        // 注记：
        // 支持跳过实参空间取实参，可为数据的腾挪增加更多灵活性。

22      $           局域存值
        // 截取后一个指令的返回值添加到当前局部域中。
        // 局部域是一个静态堆叠空间（只添加），高度小于128（最多可添加128个值）。
        // 通过位置下标引用堆叠中成员。
        // 与实参创建指令@相同，如果后面是实参直取指令~，会简单忽略。
        // 例：
        // $TOP       引用栈顶项添加到当前局部域中（实为复制）。
        // $POPS[3]   弹出栈顶3项添加到局部域中（3个成员的切片）。
        // ${100}     将值 100 直接存入局部域。
        // @POPS[3] $SPREAD  弹出栈顶3项打包为一个切片，展开添加到局部域中。
        //
        // 注意：
        // 每一个语法块都会有一个当前局部域，即便只是一个简单的 IF{} 块。
        // 各个语法块的局部域是无法互访的，因此只有平级的指令才共享相同的局部域。
        // 如果需要跨级访问，请使用脚本域的全局变量空间（VAR/SETVAR）。
        //
        // 注记：
        // 这种仅平级指令才能共享的特性，为下面的局部域用名称取值提供了方便，
        // 使得可静态解析分析名称位置（无需运行时）。

23      $(1)        局域引用
        // 按添加时的顺序引用局部域的值。
        // 这可视为上面$的逆指令。
        // 作为取值指令，它引用的值会自动添加进实参区而非入栈。
        // 附参：局部域成员下标，int8 支持负数从末尾算起。
        // 例：
        // $[0]   引用第1个添加进局部域中的值。
        // $[-1]  引用最后一个添加到局部的值。
        // 友好：
        // 可以用$存值时所截取指令的名称来取值，名称用花括号包围。
        // 不过需要注意名称重复覆盖的问题，最好就近使用。
        // 例：
        // $POP   弹出栈顶项添加到当前局部域。
        // ${POP} 从局部域获取上面添加的值。
        // $MO_MATH.Abs   取栈顶值计算绝对值后，添加到当前局部域。
        // ${MO_MATH.Abs} 从局部域中获取上面添加的值。
        // 注：
        // 模块方法调用表示为用句点连接模块名和方法名。
        // 例：
        // $[0] $[1] $[2] PUSH
        // 将局部域前3个值压入到数据栈。
        //
        // 注记：
        // 友好名称引用在源码解析阶段有效，实际的脚本代码中附参依然只是一个数值。
        // 因为局部域并不能跨层级引用，所以解析阶段即可以准确定位（平级约束）。

24      ${}(1)      循环域变量引用
        // 仅用于循环体内，但可跨语法块层级（与上面的局域不同）。
        // 附参：成员引用位置。
        // 只支持4个成员：
        // - ${Value}   当前条目值 [0]
        // - ${Key}     当前循环键（整数下标或字符串） [1]
        // - ${Data}    目标集本身 [2]
        // - ${Size}    集合大小（迭代次数） [3]
        // 注意：
        // - 名称大小写敏感。这是与上面局域引用中用指令名书写时的区别。
        // - 不能直接采用数字形式引用，这会与局域引用混淆。
        // - 与局域引用类似，作为取值指令，返回值进入实参空间而非入栈。
```

> **注：**
> 除了局域存值（`$`）和实参直取（`~`）外，其它3个指令都是把得到的值放入实参空间。


### 3. 栈操作指令

对脚本数据栈中的条目执行直接的操作，如：入栈、出栈、引用、转移等。通常会配合拦截指令 `@` 或 `$` 使用。

指令值区间：`[25-34]`，10个。

```go
指令码  指令字      说明
-----------------------------------------------------------
25      NOP         无操作
        // 实参：不定数量。
        // 无任何操作，但会读取实参区，即清空。
        // 返回值：无。
        // 例：
        // @INPUT[] NOP 读取导入缓存区到实参区，然后清空。
        // @SHIFT[] NOP 同上原理清空数据栈。
        // @SHIFT NOP   同上。零值附参书写时可省略中括号。
        // NOP          无任何行为，继续。
        // 注记：
        // 不定数量实参允许0个实参（系统不会自动从数据栈取值）。

26      PUSH        数据入栈
        // 把实参区全部内容按顺序压入数据栈。
        // 实参：不定数量。
        // 返回值：无。
        // 例：
        // {0} @PEEK @INPUT PUSH  提取栈底项和缓冲区全部数据，顺序压入数据栈。
        // ... PUSH  如果实参区为空，这是一个空操作。

27      SHIFT(1)    转移栈顶条目
        // 移出栈顶多个条目，保持原顺序展开到目标位置。
        // 附参：取栈条目数。uint8类型，0值表示全部。
        // 实参：无。
        // 如果条目数超出栈高度，执行会失败。
        // 返回值：多值自动展开。
        // 例：
        // @SHIFT[4]    移出栈顶4项原样添加到实参区。
        // $SHIFT[4]    同上但添加到当前局部域。
        // @SHIFT[0]    移出数据栈全部条目到实参区。
        // @SHIFT[]     同上。0可选。
        // @SHIFT       同上。零值表达全部时，中括号也可选。
        // SHIFT[4]     移出4项又原样返回入栈，没有意义。
        // @SHIFT[1]    移出栈顶1项到实参区，与 @POP 同。
        // 注意：
        // 转移会维持栈内数据的先后顺序，即先入栈的在前。
        // 通常前置取值指令，否则返回值会重新入栈（没有意义）。
        // 注：
        // 某种程度上可视为 PUSH 指令的逆操作。

28      CLONE(1)    克隆栈顶条目
        // 克隆栈顶多项数据，保持原始顺序展开到目标位置。
        // 附参：克隆数量。uint8类型，0值无意义。
        // 实参：无。
        // 返回值：多值自动展开。
        // 注意：此为浅克隆，切片或字典条目依然会引用源数据。
        // 例：
        // @CLONE[3]    克隆栈顶3项，展开添加到实参区。
        // $CLONE[3]    同上克隆展开添加到当前局部域。
        // CLONE[3]     克隆栈顶3项展开入栈。
        // CLONE[0]     无克隆项，没有意义。
        // 提示：
        // 与后面运算指令DUP的区别：
        // - DUP[n]     取出栈顶 1 项复制 n 次，返回 1+n 项展开。
        // - CLONE[n]   复制栈顶 n 项 1 次，返回 n 项展开。
        // 例：
        // DUP[1]       取出并复制1次，返回两项展开。栈顶有两个相同数据
        // CLONE[1]     引用复制1项，返回一项入栈。效果同上。
        // TOP          引用栈顶项返回，效果同上。


// 以下指令直接读取数据栈，无实参。
// 注：返回的切片并不会自动展开。

29      POP         栈顶项弹出
        // 返回值：栈顶项。
        // 如果没有前置取值指令，返回值会自动重新入栈（无意义）。
        // 例：
        // @POP     弹出栈顶项添加到实参区。
        // $POP     弹出栈顶项添加到当前局部域存储。
        // POP      弹出栈顶项又返回入栈，没有意义。

30      POPS(1)     栈顶多项弹出
        // 附参：弹出的条目数。
        // 附参为uint8类型，0值表示弹出全部。
        // 如果条目数超出栈高度，执行会失败。
        // 返回值：一个Any切片
        // 弹出的集合维持栈内数据原有的顺序（先进者在前）。
        // 例：
        // POPS[4]  打包栈顶4项为一个切片。
        // @POPS[4] 弹出栈顶4项打包为一个切片添加到实参区。
        // @POPS    取出栈内全部条目打包添加到实参区。

31      TOP         引用栈顶项
        // 返回值：栈顶项。
        // 如果没有前置取值指令，返回值会自动重新入栈。
        // 例：
        // @TOP 引用栈顶项添加到实参区。
        // TOP  引用栈顶项并返回入栈，相当于克隆/复制1项。

32      TOPS(1)     引用栈顶多个条目
        // 附参：引用条目数。
        // 附参uint8类型，0值无引用（与POPS不同）。
        // 如果条目数超出栈高度，执行会失败。
        // 返回值：一个Any切片。
        // 同POPS，成员维持栈内原有底顶顺序。
        // 例：
        // TOPS[1]  引用栈顶项封装为一个单成员切片返回。
        // TOPS[3]  引用栈顶3项封装为一个切片返回。
        // TOPS[]   无引用返回一个空切片。
        // TOPS     同上。但含义不够明晰。


// 以下指令由实参指定下标位置。

33      PEEK        引用栈内任意位置条目
        // 实参：目标条目下标。
        // 栈底位置为0，支持负数从栈顶算起。
        // 返回值：引用目标项。
        // 例：
        // {-1} PEEK    与 TOP 效果相同。
        // {0} PEEK     引用栈底项入栈（克隆栈底项到栈顶）。
        // {0} @PEEK    同上引用，添加到实参区。
        // {0} $PEEK    同上引用，放入当前局部域。

34      PEEKS(1)    引用栈内任意位置段条目
        // 附参：引用条目数。
        // uint8类型，最多引用255条。0值表示目标位置之后全部。
        // 实参：起始位置下标。
        // 栈底位置为0，支持负值从栈顶算起（当前实参不计在内）。
        // 如果位置下标超出栈高度，或实际数量不足，执行会失败。
        // 返回值：目标位置段条目的Any切片。
        // 例：
        // {0} @PEEKS[5]    引用栈底5项数据封装放入实参区。
        // {-5} @PEEKS[0]   引用栈顶5项封装放入实参区，同：@TOPS[5]
        // {0} PEEKS[5]     引用栈底5项封装返回入栈。
```


### 4. 集合指令

支持可迭代集合（切片或字典）的一些基本操作。

为维护源脚本的只读属性，这里对有切片写入逻辑的指令都会在一个副本上操作，比如目标可能是 `SOURCE` 指令的取值。

> **注记：**
> 在这里约束写入类指令在副本上操作，比在其它地方读取成一个副本更有效率。因为读取类指令更多也更常用。
> 只能使用既有的指令构造脚本逻辑，这也是栈脚本的安全性优势所在。

指令值区间：`[35-45]`，11个。

```go
指令码  指令字      说明
-----------------------------------------------------------
35      SLICE       局部切片
        // 对切片类目标切分出一个子切片。
        // 注意返回的是原切片的局部引用，如果需要副本，可COPY之。
        // 实参1：目标集合。
        // 实参2：起始下标，支持负数从末尾算起。Int类型
        // 实参3：结束下标（不含），同上支持负数。特例 nil 值表示末尾之后。
        // 返回值：一个同类型的局部切片。
        // 例：
        //      {0} RANGE[10]           //=> [0,1,2,3,4,5,6,7,8,9]
        //      @POP @{5} @{8} SILCE    //=> [5,6,7]
        //      或：
        //      {5} {-2} SLICE          // 结果同上，负值倒数。
        // 注意：
        // - 如果起始下标超出集合大小，执行失败。
        // - 结束下标需要在起始下标之后，否则出错。
        // - 起始下标等于结束下标时，返回一个空切片。
        // 支持：
        // - Bytes      => []Byte（同 Bytes）
        // - Runes      => []Rune（同 Runes）
        // - []any      => []any
        // - []Int      => []Int
        // - []Float    => []Float
        // - []String   => []String
        //
        // 注记：
        // 考虑安全原因，Script 类型不被支持，虽然它的底层是 []byte 类型。
        // 采用结束下标实参而不是长度附参，可以无需知道切片长度（更灵活）。

36      REVERSE     序列反转
        // 将切片内的成员顺序反转。
        // 实参：目标集合。
        // 返回值：反转后的新切片。
        // 注：支持类型同上。

37      MERGE       分片合并
        // 将多个切片合并为一个切片。
        // 实参：1+不定数量。首个实参必须存在。
        // 返回值：一个合并后的新切片。
        // 例：
        // @SHIFT[3] MERGE  栈顶3项添加到实参区，合并为一。
        // 注意：
        // DATA{}值并不是一个[]byte切片，而是一个Bytes单值。

38      EXPAND      切片扩充
        // 将实参成员添加进目标集合。
        // 实参：1+不定数量。首个实参为目标集，后续为待添加成员。
        // 返回： 一个新的扩充后的切片。

39      GLUE        序列成员粘合
        // 将切片的成员串连在一起。
        // 各个成员之间紧邻，并没有分隔彼此的分隔符。
        // 实参：一个切片。
        // 返回值：一个新的字节序列。
        // 例：
        // POPS[3] GLUE 将栈顶3项数据打包后串连在一起。
        // 注：
        // 仅适用于 byte、rune、Bytes 和 String 类型的成员。
        // 各个成员可以是这三种类型的任意一种（混杂合法）。

40      SPREAD      序列展开
        // 将目标切片展开返回。
        // 如果前置取值指令，会展开添加到目标空间。
        // 实参：一个切片。
        // 返回值：不定数量。
        // 例：
        // $SPREAD  将目标项展开压入当前局部域。
        // @SPREAD  将目标项展开添加到实参区。
        // ~SPREAD  将栈顶项展开后返回入栈（POPS逆操作）。
        // 注意：
        // 目标项需要是可展开类型，比如一个切片条目。
        // 提示：
        // 连续的 @~SPREAD 可将栈内多个切片逐一展开到实参区。

41      ITEM        成员条目获取
        // 获取数据集合中的成员或成员集。
        // 实参1：目标集，切片或字典（map[string]any）。
        // 实参2：成员位置键/集（下标或键名）。
        // - 数值下标支持负数从末尾算起。
        // - 可以是一个位置切片同时获取多个值。
        // 返回值：目标成员值或值集。
        // 例：
        //      POPS[5] PEEK[0] ITEM EQUAL PASS
        // - 取栈顶5项打包为一个集合入栈。
        // - 取栈底成员值入栈（可能由解锁实参传入，假定为单值）。
        // - 获取集合内目标位置的值入栈。
        // - 比较此时的栈顶2项是否相等（前面取值时已消耗栈顶2项，最新入栈为拣取值）。
        // - 相等则验证通过。
        // 注意：
        // 从字典中取值时，如果条目不存在会取到一个默认零值。
        // 支持多值同时取值，依键类型自动判断。

42      SET         成员条目设置
        // 设置字典（map[string]any）某键的值。
        // 实参1：目标字典。
        // 实参2：键名或键名集（[]string）。
        // 实参3：目标值或值集。
        // 返回值：原目标字典。
        // 注记：
        // 切片是栈脚本中的基础操作目标，考虑安全性，不支持切片的成员值修改。

43      SIZE        集合大小
        // 实参：一个切片或字典。
        // 返回值：一个整数。


// 下两个指令含子语法块：
// 包含一个私有数据栈，实参用于初始化该数据栈。

44      MAP{}(1)    映射迭代
        // 针对目标集，迭代每一个成员执行子语句块，返回值构造为一个最终切片。
        // 附参：子语句块长度。
        // 实参：1+不定数量。首个成员为目标集，后续作为私有数据栈初始成员。
        // 返回值：一个切片。
        // 语法：
        // 子语句块拥有一个局部私有环境（数据栈、实参区），与上层脚本无关。
        // 私有环境在各个迭代之间是共享的（注意实参区也是共享的）。
        // 局部变量：
        // - ${Value}   // 当前条目数据
        // - ${Key}     // 当前循环键（整数下标或字符串）
        // - ${Data}    // 迭代集本身
        // - ${Size}    // 集合大小（迭代次数）
        // 注意：
        // 子语法内返回的 nil 值会被忽略，这让指令也有筛选的能力。
        // 目标集通常是一个切片，但兼容字典，如果是后者，迭代的顺序是不确定的。
        // 例：
        // {10} RANGE[3]    // 创建了一个切片 [10,11,12] 入栈
        // {200} {300}      // 简单入栈2个值
        // @SHIFT[3]        // 首个实参为待迭代集合，后续实参将进入MAP的私有栈
        // MAP{
        //      ${Key} @POP PRINT
        //      ${Key} ${Value} PRINT
        //      @( ${Value} * 2 ) RETURN
        // }
        // 将打印共3组值：
        // - 0 300      // 第1次
        // - 0 10
        // - 1 200      // 第2次
        // - 1 11
        // - 2 <nil>    // 第3次，栈内已无值
        // - 2 12
        // 返回的结果集：[20, 22, 24] 自动进入上层数据栈。

45      FILTER{}(1)   成员过滤
        // 针对目标集，迭代每一个成员执行子语句块，提取返回真值的源成员。
        // 附参：子语句块长度。
        // 实参：1+不定数量。首个成员为目标集，后续为私有数据栈初始成员。
        // 返回值：一个切片或字典。
        // 语法和局部变量参考上面MAP指令。
        // 支持字典的过滤，返回假值的循环其条目会被丢弃。
        // 返回值维持原类型。注意字典的迭代顺序是不确定的。
        // 例：
        // {10} RANGE[4]        // 创建了一个切片 [10,11,12,13] 入栈
        // @POP                 // 仅有一个实参（目标集）
        // FILTER{              // 私有栈为空
        //      ( ${Key} % 2 )
        //      @BOOL RETURN
        // }
        // 返回的结果：奇数集 [11, 13]，进入上层数据栈（整体返回值）。
        // 注：
        // 依然可以前置取值指令截取返回值：@FILTER{...}
```

> #### 关于Each
> `EACH{}` 指令是作为流程控制而非集合指令对待，一是因为它无需返回值，二是它内部应支持 `BREAK` 指令。<br>
> 另外，因为只是流程控制指令，所以 `EACH{}` 也没有子语句块的私有栈逻辑。<br>


### 5. 交互指令

在脚本的执行中存在一个数据的「缓存区」结构，它是与外部世界发生联系的一个中介区域。

缓存区是一个先进先出（FIFO）的队列结构，读取即为移出。导入和导出是两个各自独立的区域。对缓存区的写入（导出）和转出是非阻塞的，从缓存区导入则会视情况而定：有数据时正常执行，无数据时终止脚本（`EXIT`）。

指令值区间：`[46-50]`，5个。

```go
指令码  指令字      说明
-----------------------------------------------------------
46      INPUT(1)    导入缓存区数据
        // 如果无值或数量不足，执行会失败（验证不通过）。
        // 这是一种严格逻辑，因此通常不会用在可支付脚本中，
        // 更多的使用场景可能是在识别脚本中，数据由客户端自己提供。
        // 附参：读取的条目数，0值表示全部。
        // 实参：无。
        // 返回值：不定数量自动展开到目标空间。
        // 例：
        // @INPUT[0]    导入缓存区全部数据展开到实参区。
        // $INPUT[3]    导入缓存区头部3项数据展开添加到当前局部域。
        // INPUT[3]     导入缓存取头部3项数据展开入栈。
        // @INPUT NOP   导入缓存区全部数据到实参区，然后清空。
        //
        // 注记：
        // 缓存区是一个队列（FIFO）结构，脚本顺序与导入顺序一致会更友好。

47      OUTPUT      导出数据到缓存区
        // 实参：不定数量。
        // 因为实参为不定数量，所以仅会导出实参区内容。
        // 与INPUT和SHIFT指令类似，有自动展开能力。
        // 例：
        // @SHIFT OUTPUT  移出数据栈全部内容到缓存区（原样保持）。
        // ... OUTPUT  若实参区为空，无任何效果。
        //
        // 注记：
        // 导出缓存区没有大小限制，但间接受制于实参空间大小。

48      BUFDUMP(1)  导出缓存区数据转出
        // 将导出缓存区内容转出到外部（清空缓存区）。
        // 附参：序位标识，uint8。用户自定义（随机但唯一）。
        // 实参：无。
        //
        // 说明：
        // 第三方服务可预先注册处理器，接收转出的数据并完成自己的逻辑。
        // 这是一个无阻塞操作，可触发外部响应机制。
        // 序位标识实际上可为任意值（<256），但在同一段脚本中需唯一，主要用于接收者定位数据转出点（位置）。
        // 注：
        // 有无第三方是一种私有逻辑，只有需要的节点才需要执行。

49      （未用）

50      PRINT       控制台打印
        // 将实参区的内容打印到标准控制台。
        // 实参：不定数量。
        // 实际上就是调用 fmt.Println()，采用默认的格式打印。
        // 多个实参条目间会以一个空格分隔。
        // 例：
        // @TOP PRINT  打印栈顶项数据。
        // @SHIFT[3] PRINT  打印栈顶3项数据。
```


### 6. 结果指令

对脚本的执行实施检查和控制（通关），如：通过、失败、退出或跳转等。如果脚本执行中未碰上失败，就视为验证通过。

通常来说，锁定脚本中必然存在通关性指令 `PASS` 或 `FAIL`，不然就没有锁定的逻辑（任何人皆可“解锁”脚本）。

指令值区间：`[51-56]`，6个。

```go
指令码  指令字      说明
----------------------------------------------------------
51      PASS        检查通过（安检）
        // 实参值为true时通过，否则失败。
        // 失败会导致脚本结束，信用转移失败（即验证失败）。
        // 实参：布尔值。
        // 返回值：无。
        // 注记：
        // 通关失败可能触发某种通知机制，以便外部可以了解情况。
        // 如果外部需要监控验证，这是很有必要的。

52      FAIL        验证失败（安检）
        // 实参值为true时失败。
        // 这是 NOT PASS 的简捷版，但表意更清晰。
        // 实参：布尔值。
        // 返回值：无。

53      GOTO(4,4,2)  执行流跳转（独立）
        // 跳转到目标区块的某个交易输出脚本。
        // - 实参区数据传递到新脚本作为数据栈初始内容。
        // - 新脚本延续当前的校验，但有其自身的环境（数据栈、实参区、全局变量区），
        //   但共享导入/导出缓存区。
        // - 新脚本的验证结果即为当前脚本的结果。
        // 附参1：区块高度，uint32类型
        // 附参2：交易ID在区块中的序位，uint32类型
        // 附参3：输出项偏移（索引），uint16类型。
        // 实参：不定数量。
        // 返回值：无。
        // 例：
        //      @SHIFT[10] GOTO[1000, 355, 1]
        // 提取栈顶10项数据，跳转到第1000号理想块的第356位交易的第2项输出，传递实参为其数据栈初始内容。
        //
        // 安全性：
        // 考虑安全性和性能，系统的实现中对连续跳转会有一些限制。
        // - 循环块（MAP, FILTER, EACH）内不允许跳转。
        // - EVAL 所执行的代码内禁止跳转。
        // - 一段脚本中运行时的跳转积累不能超过3次。

54      JUMP(4,4,2)  执行流跳转（嵌入）
        // 跳转定位与 GOTO 指令相同。
        // 目标脚本为嵌入逻辑，共享当前的脚本环境（数据栈、实参区、全局变量区等）。
        // 子脚本有自己的顶层局部域。
        // 附参：（同上GOTO）
        // 实参：无。
        // 返回值：无。
        // 例：
        //      JUMP[1000, 355, 1] FN_HASH256 DATA{...} EQUAL PASS
        // 跳转执行嵌入代码。
        // 返回后取栈顶值计算哈希摘要（FN_HASH256）和后面的工作。
        // 注：
        // 目标子脚本可能已往当前栈中添加了哈希源数据。
        //
        // 安全性：
        // 与 GOTO 类似，脚本中允许使用的JUMP指令有一个限度。
        // - 私有域的循环（MAP, FILTER）内禁止嵌入，但 EACH 内允许。
        // - EVAL 的外部代码内禁止嵌入。
        // - 一段脚本中运行时的嵌入积累不能超过9次。

55      EXIT        脚本结束
        // 结束脚本的执行。至此无错视为验证通过。
        // 如果实参区有值，返回该值（到系统，可能会被处理）。
        // 实参：不定数量。
        // 返回值：
        // 即实参值，任意类型。多个值会被打包为一个切片。

56      RETURN      返回一个值
        // 从子语句块退出并返回一个值。
        // 只适用于函数式语句块 MAP{} 和 FILTER{}，退出当前迭代。
        // 实参：任意类型，单值。
        // 返回值：即实参值。
        // 例：
        //      MAP{
        //          ... RETURN  // 每次返回栈顶项
        //      }               // 全部迭代的返回值构成一个切片，作为MAP的返回值
        //      @SPREAD         // 该MAP的返回值被展开添加到实参区。
        // 注意：
        // 无值返回时应当返回nil（NIL指令可创建该值）。
```


### 7. 流程指令

普通编程语言中是以花括号限定语句块的范围，通过词法解析来编译和执行代码。

栈脚本是指令值序列，需要实时解析并对阅读友好，为了提高效率，语句块的长度被作为附参附在了指令之后。附参的*字节长度*限定了语句块的长度范围，这是一种*有意的约束*，以一定程度限制脚本结构的复杂性。语句块的最终长度由解析器解析计算而来，书写时无需包含中括号的附参明示（会很麻烦）。

指令的子语句块即为该指令的关联数据。该类指令无返回值。

指令值区间：`[57-66]`，10个。

```go
指令码  指令字      说明
-----------------------------------------------------------
57      IF{}(1)     真值执行
        // 附参：子语句块长度，uint8类型。
        // 实参：布尔值。
        // 实参值为true时执行子语句块。
        // 注记：
        // 会设置IF的状态，供后续可能的ELSE指令判断。
        // 例：
        // ... EQUAL       // 比较结果入栈。
        // IF{             // 栈顶值为true时执行子语句块
        //      TRUE PRINT // 打印 true
        // }
        // 说明：
        // - IF的条件由它的实参表达，在指令之前就已经计算好了。
        //   这是栈脚本栈式结构的特点。
        // - IF和ELSE并不需要紧邻，两者之间可以有其它普通语句。
        //   IF状态在同层级是共享的，后来的IF会覆盖之前的IF状态（影响ELSE逻辑）。

58      ELSE{}(1)   IF不满足时执行
        // 检查本层级IF状态值，如果IF为假则执行本语句块。
        // 附参：指令块长度，uint8类型。
        // 实参：无。
        // 注：
        // 连续的ELSE是可能的，它们相对于前面的IF状态判断自身的逻辑。
        // 虽然这看起来有点怪异。
        // 如果ELSE块很大，这可以是一种拆分策略。

59      SWITCH{}(~) 分支选择区
        // switch 语法块开启。
        // 附参：区块长度，变长正整数。
        // 实参1：标的值。将与CASE分支值对比，任意可比较类型。
        // 实参2：CASE分支值列表，长度与CASE数量相同。
        // 提示：
        // 若标的值为true，可模拟 if/elseif/else 的逻辑。
        // 注记：
        // 变长整数定义区块长度，友好短小代码。

60      CASE{}(1)   条件分支
        // 附参：语句块长度。
        // 实参：无。已由SWITCH预先取出，按位置逐项对比。
        // 相应值对比结果：
        // - 真：执行子语句块。
        // - 假：跳过子语句块。
        // 说明：
        // CASE 块如果被执行，之后即结束 SWITCH 语法块。
        // CASE 块中也可以用 BREAK 指令提前退出。
        // 例：
        // @POP                 // SWITCH 标的值
        // @POPS[3]             // CASE 分支对比值集
        // SWITCH{
        //      CASE{           // 序列[0]与SWITCH标的值比较，相等则执行
        //          ...
        //          BREAK       // 可选，会自然退出
        //      }
        //      CASE{           // 序列[1]与标的值比较...
        //          ...
        //      }
        //      CASE{           // 序列[2]与标的值比较...
        //          ...
        //      }
        //      DEFAULT{...}    // 默认分支，无CASE匹配时至此，无条件执行
        // }
        // 说明：
        // SWITCH 的两个实参可以不用取出到实参区，这里是便于说明。
        // 平级 CASE 之间实际上可以插入普通指令，虽不好看但确实可行。
        //
        // 注记：
        // CASE 分支的值在执行 SWITCH 时已全部取出，这使得 SWITCH/CASE 更为一体。

61      DEFAULT{}(1)  默认分支
        // 无条件执行。
        // 附参：语句块长度。
        // 实参：无。
        // 说明：
        // 其它CASE分支未执行时执行，只能在所有CASE之后。可选。

62      EACH{}(1)   迭代式循环
        // 对集合成员逐一迭代处理，有限循环。
        // 附参：循环块长度。
        // 实参：可迭代集合（切片或字典）。
        // 局部变量：
        // - ${Value}   // 当前条目数据
        // - ${Key}     // 当前循环下标，从0开始
        // - ${Data}    // 目标集合本身
        // - ${Size}    // 迭代条目总数
        //
        // 与集合指令MAP/FILTER不同，这里全局数据栈是可见的。
        // 另外，如果需要中断当前循环，需要执行 BREAK 而不是 RETURN。
        // 注意：
        // 如果目标集是一个字典，迭代顺序是不确定的。

63      CONTINUE    跳入下一迭代
        // 会立即终止当前循环，开始下一次迭代。仅用于 EACH{} 指令内。
        // 实参：布尔值，可选。
        // 如果实参有值，则真值执行，假值略过。否则直接执行。
        // 类似上面的 BREAK 自带判断逻辑。

64      BREAK       退出EACH或SWITCH
        // 实参：布尔值，可选。
        // 如果实参有值，则真值执行，假值略过。否则直接执行。
        // 自带判断逻辑，可省略简单的IF{}结构。
        // 例：
        // @POPS[10]                // 取栈顶10项打包待处理
        // EACH{
        //      ${Value} @{1000}    // 当前值和目标值
        //      GT                  // 当前值是否大于1000，结果入栈
        //      @POP BREAK          // 取比较结果，真值结束EACH{}，假值忽略
        // }
        // 注：EACH开始后实参区已为空。

65      FALLTHROUGH 分支穿越
        // 在一个 CASE 分支中完成了操作，直接延续到下一个 CASE 之内。
        // 就是go语言中的 fallthrough 关键字的功能。
        // 实参：无。不支持条件穿越（简化）。
        // 例：
        // SWITCH{
        //      CASE{
        //          ...             // 1.
        //          FALLTHROUGH     // 贯穿到 2. 继续执行
        //      }
        //      CASE{
        //          ...             // 2.
        //      }
        //      DEFAULT{...}
        // }
        // 注记：
        // 这是 switch/case 结构中的特有逻辑，以此支持完整的语法。

66      BLOCK{}(~)  创建局部域
        // 创建一个没有实际结构逻辑的子块。
        // 附参：子块长度，变长正整数。
        // 实参：无。
        // 在块内，局部域和子块范围有意义，其它都与上层相同（共享）。
        // 在原本平级的指令序列中分隔出一个区域，可用于 SOURCE 提取局部代码。
        // 或者简化复杂的局部变量使用。
```


### 8. 转换指令

将脚本中的数据转换为不同的表达方式，有时是很需要的。

这里的转换不只是数据**类型**的转换，还包括值的改变。比如字符串 `"123"` 可以转换为整数 `123`，外观上虽然一致，但表达它们的二进制值实际上已经不一样了。而整数转换为字符串时，并不是改变值的含义，而是转换为值的字符串表示，如 `String(65)` 并不是将65视为码点值（`"A"`），而是转换为字符串 `"65"`（如果采用十进制的话）。

> 注记：
> 考虑安全性，禁止转换到脚本类型。因此脚本中的 EVAL 仅能执行由 CODE{} 明确书写的代码。

指令值区间：`[67-79]`，13个。

```go
指令码  指令字      说明
-----------------------------------------------------------
67      BOOL        转换为布尔值：Bool
        // 实参：
        // - 空值：     nil => false
        // - 字符串：   ""  => false
        // - 整数：     0   => false
        // - 字节：     0   => false
        // - 字符：     0   => false
        // - 大整数：   0   => false
        // - 浮点数：   x <= math.SmallestNonzeroFloat64 => false
        // 提示：
        // 测试字典或切片是否非空，可用 "SIZE BOOL"。

68      BYTE        转为字节：Byte
        // 作为 Bytes 的子成员而存在。
        // 实参：
        // - 空值：     nil => 0
        // - 布尔值：   true => 1, false => 0
        // - 整数：     小于256的值类型转换，否则出错
        // - 字符：     Unicode码值小于256的类型转换，否则出错
        // - 浮点数：   取整，小于256的值类型转换，否则出错。
        //
        // 注记：
        // uint8的别名，但拥有自己的逻辑（不同于Int）。
        // 转换到字符串时与Int不同，仅做单纯的类型转换（同Go）。

69      RUNE        转为字符：Rune
        // 作为字符序列 Runes 的子成员而存在。
        // 实参：
        // - 空值：     nil => 0
        // - 布尔值：   true => 1, false => 0
        // - 字节：     直接类型转换
        // - 整数：     小于int32最大值时类型转换，否则出错
        // - 浮点数：   先取整，同上整数转换规则。
        // - 字节序列： 按UTF-8编码解释，仅支持单个字符。
        // - 字符串：   （不支持）
        //
        // 注记：
        // int32的别名，但拥有自己的逻辑（不同于Int）。
        // 转换到字符串时与Int不同，仅按值含义做类型转换（会有UTF-8编码）。

70      INT         转换为整数：Int
        // 实参：
        // - 空值：     nil => 0
        // - 布尔值：   true => 1, false => 0
        // - 字节：     简单转换。
        // - 字符：     简单转换。
        // - 字符串：   Golang合法的整数表示：
        //              普通十进制
        //              0b|0B 二进制
        //              0o|0O 八进制
        //              0x|0X 十六进制
        //              数字之间支持单下划线友好分隔。
        // - 浮点数：   截断小数部分，超过int64上限的大数会抛出异常。
        // - 时间：     提取Unix时间戳（毫秒数）。
        // - 大整数：   值在int64的范围内则转换，否则抛出异常。
        // - 字节序列： 按大端序解释，长度需等于 1、2、4、8 的固定值。
        //
        // 注意：
        // 与字符串的相互转换按字面意义解释（strconv规则）。

71      BIGINT      转换为大整数：BigInt
        // 实参：
        // - 字符串：   合法的整数字符串表示，支持前缀标志。
        // - 字节序列： 按大端序转换（math/big）。
        // - 布尔值：   true => 1, false => 0
        // - 整数：     简单转换，无要求。
        // - 浮点数：   截断小数部分。
        // - 字节：     按整数简单转换。
        // - 字符：     按整数简单转换。
        // - 空值：     nil => BigInt(0)

72      FLOAT       转换为浮点数：Float
        // 实参：
        // - 布尔值：   true => 1.0; false => 0.0
        // - 整数：     简单的类型转换，无要求
        // - 字节：     按整数转换。
        // - 字符：     按整数转换。
        // - 字符串：   合法的浮点数或科学记数法表示。
        // - 空值：     nil => 0.0

73      STRING(1){} 转换为字符串：String
        // 附参：进制或格式标识，仅适用数值类型。
        // - 2 ~ 36 整数进制。结果无前置标识（如 0x）。
        //          用法：如 STRING[16]，中括号指定具体的数值。
        // - 2 ~ 62 大整数进制，a-z 表示 10-35，A-Z表示 36-61。
        //          用法：同上整数方式，如 STRING[16]。
        // - b, e, E, f, g, G, x, X 浮点数格式标识。
        //          用法：如 STRING{E}，花括号包围标识字符，或中括号指定字符的值。
        // 实参：
        // - 布尔值：   true => "true"; false => "false"
        // - 整数：     按进制格式显示（strconv）。
        // - 大整数：   同上。
        // - 浮点数：   按格式标识显示（最少位数）。
        // - 字节：     视为字符值转换。
        // - 字符：     视为Unicode码点值转换。
        // - 字节序列： 视为UTF-8编码的字节序列。
        // - 字符序列： []rune => string(x) 自动UTF-8编码。
        // - 空值：     nil => ""

74      BYTES       转换为字节序列：Bytes
        // 实参：
        // - 空值：     nil => Bytes{} 零长度
        // - 整数：     按大端序转换，固定为8字节长。
        // - 大整数：   按大端序转换，长度不定。
        // - 字节：     长度为1的字节序列。
        // - 字符：     按字符的UTF-8编码转换。
        // - 字符串：   转换为字符串的UTF-8码值序列。
        // - 字符序列： 转为UTF-8编码的字节序列。
        // - 脚本：     提取源字节序列（副本）。

75      RUNES       转换为字符序列：Runes
        // 转为单个字符的切片可方便某些处理。
        // 实参：
        // - 空值：     生成一个空 []rune
        // - 字符：     包含一个字符的字符切片。
        // - 字符串：   视为UTF-8编码解码为 []rune
        // - 字节序列： 同上解码，无效的UTF-8会解码为值 \uFFFD

76      TIME        转换为时间类型：Time
        // 用实参构造日期/时间值（毫秒数时间戳）。
        // 实参：
        // - 整数：     视为UNIX时间戳（毫秒数）。
        // - 字符串：   RFC3339的标准时间格式串。
        // 例：
        //      {1608883593536} TIME
        // 整数直接视为一个时间戳值（2020-12-25T08:06:33.536Z）。
        //
        //      TEXT{2020-12-25T08:06:33.536+08:00} TIME
        // 用RFC3339格式字符串构造一个时间值（上海时区，精确到毫秒）。
        // 毫秒数时间戳实为：1608854793536，比上面少8个小时。

77      REGEXP      构造为一个正则表达式：RegExp
        // 用实参值构造一个正则表达式对象。
        // 实参：
        // - 字符串：   正则表达式的字符串形式。

78      ANYS(1){}   切片转换（[]any <=> []T）
        // 将某具体类型的切片转换为 []any，或反之。
        // 附参：类型标识值。
        // 类型名：
        // 仅有5个类型支持与Any之间的转换。
        // - any    默认，从下面四个类型转换到 []any
        // - Byte   字节，[]any => Bytes
        // - Rune   字符，[]any => Runes
        // - Int    整数，[]any => []Int
        // - Float  浮点数，[]any => []Float
        // - String 字符串，[]any => []String
        // 实参：目标切片。
        // 注记：
        // 某些指令如DICT需要[]any数据，但实际可能是某种具体类型的切片，需要转换。
        // 某些操作需要具体类型的值集（如ITEM），但实际数据却为[]any。

79      DICT        构造字典：Dict（map[string]any）
        // 实参1：键序列（[]string）
        // 实参2：值序列（[]any）
        // 两个实参序列的成员按顺序对应创建一个字典。
        // 值序列的大小必须等于或多于键序列，否则出错（多出的部分被简单忽略）。
        // 键仅支持字符串类型。
        // 例：
        //      TEXT{one} TEXT{two} TEXT{three} POPS[3]
        //      {100} {200} NIL {1.0} POPS[4]
        //      DICT
        // 创建为：{
        //      "one": 100,
        //      "two": 200,
        //      "three": <nil>,
        // }
        // 值序列中多出的 {1.0} 被简单忽略（这里仅为示例）。
        // 例中的键序列实际上是 []any 类型，但 any 存储的是字符串。
        //
        // 注记：
        // 字典作为一种基础结构，可以方便某些需要大量重复取值的应用场合。
        // 但字典并不是栈脚本的基础类型，不能通过值指令来创建。它只是一个效率工具。
        //
        // 字典里的成员可以被删除或添加，但成员本身是无法改变的。
        // 这是源脚本“只读”的安全性要求。
```


### 9. 运算指令

有两种形式的运算指令：

1. 符号指令。操作数在符号两侧的常见形式，如：`{100} + {10}`。仅支持四则运算，用于表达式内。
2. 命名指令。类似于函数的普通指令，操作数作为实参在指令之前，如：`{100} {10} ADD`。可用于表达式之内和之外。

指令值区间：`[80-103]`，24个。


#### 表达式

表达式是一个独立的运算单元，外部实参区和局部域对表达式内的指令是只读的。表达式中的指令可以正常获取实参，但其返回值只是一个操作数，而不会自动进入数据栈或被取值指令（`@`, `$`）拦截。

通常，表达式内只是一些值指令或简单取值类的指令，如 `{123}、POP、ENV、VAR、$[]` 等，但依然可以是复杂的函数类指令，它们从实参区或数据栈内取实参，运算的结果滞留于当前位置作为操作数。通常，一个更好的方式是先执行这些复杂指令，让它们的结果进入数据栈或存入局部域，然后再在表达式中简单地获取它们。

表达式计算的最终结果会作为表达式指令本身的结果返回（被截取或自动入栈），但这不包含内部的子表达式。

> **注：**
> 截取指令 `@` 和 `$` 在表达式内没有意义，但从局部域取值的 `${}` 依然可用，不过其自动添加到实参区的能力没有了。


#### 指令清单

```go
指令码  指令字      说明
-----------------------------------------------------------
80      ()(1)       表达式封装&优先级分组
        // 计算相对独立，内部可包含子表达式。
        // 内部指令或子表达式的返回值不会被外部捕获，仅根表达式的返回值进入流程。
        // 表达式内的指令可正常从外部实参区或数据栈取实参，但返回值被滞留在表达式内参与计算。
        // 附参：表达式长度。
        // 实参：无。
        // 返回值：一个浮点数（float64），单值。
        // 例：
        // ( POP + {100} )  栈顶值加100，结果值返回自动入栈。
        // ( POP + ${100} ) 错误。无法添加局部变量（且 ${100} 也无返回值）
        // ( POP + $[0] )   正常。$[0] 为取值而非赋值
        // ( {1.5} * (POP + {100}) )  内部的子表达式的结果只是一个操作数。
        //
        // 提示：
        // 顶层的根表达式与普通指令一样，返回值会自动入栈或被取值指令（@, $）捕获拦截。
        // 如：
        // $( POP + {100} )  将运算结果放入局部域
        //
        // 注意：
        // - 原则上，表达式内可以使用任意指令，但没有返回值或错误的返回值会导致计算失败。
        //   因此用户应当恰当地使用指令，比如简单的取值或计算。
        // - 表达式内的数值会转换为 float64 后计算，且返回一个同类型的浮点数，
        //   如果用户需要最终为整数，需要自行转换。


// 符号指令：
// 单/双操作数，仅用于表达式内部。
81      *           乘
82      /           除
83      +           加，单/双，仅适用数值
84      -           减，单/双
        // 实参在指令前后两侧。
        // 例：
        //      ( {100} + POP * {1.5} / {2} )
        // 注意运算符优先级。
        // 运算符之间的空格是可选的。


// 命名指令：
// 双实参，支持 Int|Float|Byte|Rune
// 返回一个浮点数（Float）
85      MUL         乘：MUL(x, y) => x*y
86      DIV         除：DIV(x, y) => x/y
87      ADD         加：ADD(x, y) => x+y  // 支持 string, []byte, map[string]any
88      SUB         减：SUB(x, y) => x-y
89      POW         幂：POW(x, y) => x**y // math.Pow(x, y)

// 双实参，Int 类型。
// 返回一个整数（Int）。
90      MOD         模：MOD(x, y) => x%y // 兼容 Float 类型
91      LMOV        左移位：LMOV(x, y) => x<<y
92      RMOV        右移位：RMOV(x, y) => x>>y
93      AND         位与：AND(x, y) => x&y
94      ANDX        位清空：ANDX(x, y) => x&^y
95      OR          位或：OR(x, y) => x|y
96      XOR         位异或：XOR(x, y) => x^y
        // 例：
        // {32} {100} MUL    入栈32和100，取栈顶2项相乘，返回 float64(3200)
        // @POP @{100} MUL   先取出到实参区后计算，返回 Float 类型值
        // @POP {100} MUL    错误。实参区只有1个值，参数不足。
        //
        // 例：
        //      ( {100} + MUL )
        // 表达式内 MUL 从外部实参区或数据栈取实参，不过这里并不直观。
        // 更好的做法可能是在前段执行它们，然后在表达式内 POP 或 PEEK 引用。

// 命名指令：
// 单实参。
97      NEG         取负：-x   // Int, Float
98      NOT         取反：!v   // Bool
        // 实参：目标操作数。
        // 例：
        // {0} PEEK NEG     取栈底项值，返回其负数
        // {123} BOOL NOT   结果为 false

// 命名指令：
// 多返回值，仅用于表达式外。
99      DIVMOD      除并求余
        // 实参1：支持该操作的类型。
        // 实参2：同上。
        // 返回值：商和余数，2个值。
        // 值1：x / y
        // 值2：x % y
        // 返回值自动展开到接收域。


100     DUP(1)      复制
        // 复制目标数据，返回值自动展开到接收域。
        // 附参：复制的份数，uint8类型。
        // 实参：目标项数据。
        // 返回值：原值+复制的条目，不定数量。
        // 例：
        // DUP[1]       取出栈顶项复制1份，与原值同时返回（共2份）。效果同 TOP。
        // DUP[2]       取出栈顶项复制2份，与原值同时返回（共3份）。
        // DUP[0]       没有复制，返回原值（实际上没做啥）。
        // $[0] @DUP[1] 引用局部域首个成员，复制后返回2份自动展开到实参区。
        // 注：
        // 适用任意数据类型，但仅为浅复制，主要用于Bytes和String。

// 集合清除：
101     DEL         删除
        // 删除字典（map[string]any）内的某个条目。
        // 实参1：目标字典。
        // 实参2：键名（字符串）或键名序列。
        // 返回值：原目标字典。
        // 注记：
        // 提供同时删除多个条目的方便，否则使用 EACH 会稍复杂。

102     CLEAR       清空
        // 将字典内容清空。
        // 实参：目标字典。
        // 返回值：原目标。

103     （未用）
```

> #### 说明：
> 符号指令 `+` 仅用于数值计算（操作数会被转换为 `float64`），因此不可用于字符串（`String`）连接。<br>
> 但命名指令 `ADD` 则支持字符串（`String`）和字节序列（`Bytes`）的连接，同时还支持字典（`Dict`）的合并。<br>


### 10. 比较指令

两个或多个操作数执行比较，返回一个布尔值（单值）。

> **注：**
> 相等性比较也支持浮点数，但更合适的指令可能是后面的 `COMFLO`，支持传递一个误差值。

指令值区间：`[104-111]`，8个。

```go
指令码  指令字      说明
-----------------------------------------------------------
104     EQUAL       相等（a == b）
105     NEQUAL      不相等（a != b）
106     LT          小于（a < b）
107     LTE         小于等于（a <= b）
108     GT          大于（a > b）
109     GTE         大于等于（a >= b）
        // 实参1：支持该比较的类型。
        // 实参2：同上。
        // 返回值：true 或 false。
        // 注：
        // 特别支持字节序列（[]byte），逐一比较内部每一个字节。

110     ISNAN       是否非数字
        // 实参：任意类型值。
        // 直接用数值表达的值都视为数字，返回false。
        // 如：整数、字节、字符、大整数、布尔值、时间戳。也包括nil值和空串。
        // 浮点数类型由 math.IsNaN(...) 判断。
        //
        // 注记：
        // NaN 与任意数值比较都返回 false，因此特别支持。
        // 该函数的行为参考了JavaScript，但对数字字符串的处理有所不同。

111     WITHIN      范围判断（min <= x < max）
        // 实参1：待比较值。
        // 实参2：下边界值（包含）。
        // 实参3：上边界值（不包含）。
        // 例：
        //      ENV{Height} {0} {240} WITHIN
        // 判断当前交易所在理想块高度是否为在第一天之内。
        //
        // 注意：
        // 如果是浮点数，下边界的相等判断可能不准确。
        // 特别支持字节序列（[]byte），逻辑与字符串类似。
```

**注：**
> 序列（`Bytes`）类型的大小比较按从左到右的逐字节进行。布尔（`Bool`）类型仅适用 `EQUAL, NEQUAL` 指令。


### 11. 逻辑指令

实参需为布尔类型，返回值也是一个布尔值（`true` 或 `false`）。

指令值区间：`[112-115]`，4个。

```go
指令码  指令字      说明
-----------------------------------------------------------
112     BOTH        两个都为真（&&）
        // 逻辑AND，是否两个值都为 true。
        // 实参1：一个布尔值。
        // 实参2：一个布尔值。
        // 返回值：一个布尔值。
        // 例：
        // BOTH PASS  取栈顶两个值，都为真时通过。

113     EVERY       全部为真（类 &&）
        // 逻辑AND，是否全部成员都为 true。
        // 实参：一个布尔值集合（包括由any内含）。
        // 返回值：一个布尔值。
        // 例：
        // POPS[3] EVERY  栈顶3项打包，检查成员是否都为 true。
        // TOPS[0] EVERY  栈顶为一个空集，返回 true。

114     EITHER      两个中任一为真（||）
        // 逻辑OR，两者中是否有其一为 true。
        // 实参1：一个布尔值。
        // 实参2：一个布尔值。
        // 返回值：一个布尔值。
        // 例：
        // EITHER PASS  取栈顶两个值，任一为真时通过。

115     SOME(1)     部分为真（||, &&）
        // 逻辑OR，全部成员中是否至少 n 个为 true。
        // 附参：为真的最低数量（n）。
        // 实参：一个布尔值集合（包括由any内含）。
        // 返回值：一个布尔值。
        // 例：
        // SOME[2]  需至少2个为真
        // SOME[1]  至少1个为真，常用
        // SOME[0]  无条件为真。同空集之于EVERY
        // 例：
        // TOPS[0] SOME[1]  实参为空集，返回 false
        // TOPS[0] SOME[0]  无条件返回 true
```


### 12. 模式指令

指令序列的模式匹配，用于验证目标脚本是否符合特定的逻辑。目标指令序列需与模式指令序列按位置逐项检查完成匹配测试，如果最终完整匹配则通过，否则失败。
符合某种逻辑流的指令序列通常称为一个模型，可由这里的模式指令序列来检查、测试和提取信息。拥有广泛共识的经典模型可能会被预先发布在某笔管理者交易中，作为 `GOTO` 或 `JUMP` 的目标供全网分享。

模式匹配很有用处，比如在链间兑换时确认对方的预支付脚本是否有效，在选举子链中对投票内容的格式做验证，甚至由中间件执行匹配提取信息以执行链外的业务，实现无人工审核的自动化流程等。

总之，模式匹配可以让某件事在下一步*具体行动前*得到合规性确认，无论是人工或自动。

指令值区间：`[116-127]`，12个。

```go
指令码  指令字          说明
-----------------------------------------------------------
116     MODEL{}(2)   创建模式匹配区
        // 开启一个解析子环境，等待对目标脚本（实参）执行模式匹配。
        // 模式内如果包含取值逻辑（#, &），提取的值会被打包为一个数组（切片）返回。
        // 如果没有取值，返回一个布尔值表示匹配成功与否。
        // 附参：取值标记（高2位）和模式区代码长度（低14位，最长支持16k字节）。
        // 实参：待测试的指令序列（*Script | Bytes）。
        // 返回值：一个切片或布尔值。
        // 注意：
        // 存在取值时，如果匹配失败会抛出异常。
        // 如果没有取值，匹配失败会返回false以表达匹配结果，流程继续。
        // 注记：
        // 内部是否包含取值逻辑，由源码解析器判断并置位标记在附参高位。
        // 例：
        // 支付脚本：
        //      TOP FN_PUBHASH DATA{<pkHash>}
        //      @TOP PRINT              // @TOP 为 PRINT 的实参区实参
        //      EQUAL PASS FN_CHECKSIG PASS
        //
        // 模型（有取值）：
        //      CODE{ ... }             // 封装上面的脚本（指令值序列）
        //      MODEL{                  // 块内普通指令即为全等模式指令
        //          TOP FN_PUBHASH      // 严格匹配（原样）
        //          DATA[20]{?}         // 关联数据长度固定，内容任意
        //          #[64]               // 取 DATA{} 关联数据
        //          ?{ @TOP PRINT }     // 打印指令可选
        //          EQUAL PASS FN_CHECKSIG PASS // 严格匹配（原样）
        //      }
        //      @SPREAD OUTPUT BUFDUMP  // 上面 MODEL{} 收集的数据展开并导出。
        //      说明：
        //      - #[64] 指令提取了匹配目标的关联数据（公钥地址）。
        //      - 模式匹配结束后，MODEL 返回了提取的公钥地址（单成员切片）。
        //
        // 模型（无取值）：
        //      CODE{ ... }
        //      MODEL{
        //          TOP FN_PUBHASH DATA[20]{?}
        //          ?{@TOP PRINT}       // 打印指令可选（有|无）
        //          EQUAL PASS FN_CHECKSIG PASS
        //      }
        //      PASS  // 如果前面 MODEL{} 匹配正确则通过验证。
        //      说明：
        //      - 打印指令被标注为可选。
        //      - MODEL 返回一个布尔值表示匹配是否成功。
        //      - 如果一个未知脚本匹配这个模型，就说明它的支付逻辑正常。
        //
        // 注意：
        // 除了下面定义的模式指令外，其它普通指令在模式区内即是模式指令，执行完整匹配逻辑。
        // 无法支持对模式块内容的模式验证，如果目标脚本内含有 MODEL 块，其内容会作为一个普通数据对待。
        // 也即：
        // MODEL 块只有全等或哈希匹配，或指令通配（MODEL[?]{?}）。
        // 使用哈希匹配可以简化 MODEL 块的内容，这样就不必书写相同的代码了。


// 以下为局部指令，仅在 MODEL{} 内有效。

117     #(1)        取值指示（指令）
        // 针对前一个指令匹配的目标，取目标的不同部分的值。
        // 附参：目标值标识。
        // 0000 0001 - 单纯指令码。(1)
        // 0000 0010 - 第1个附参。(2)
        // 0000 0100 - 第2个附参。(4)
        // 0000 1000 - 第3个附参。(8)
        // 0001 0000 - 第4个附参。(16)
        // 0010 0000 - 第5个附参。(32)
        // 0100 0000 - 关联数据。(64)
        // 1000 0000 - 完整指令，含附参和关联数据。(128)
        // 注：
        // 多个附参可同时提取，会按顺序存为多个值。
        // 当取完整指令时，附参是一个any切片，这与单独取附参有所区别。
        // 完整指令优先于其它置位，如果指令没有附参或数据，会有nil占位（保持3个成员）。
        // 本指令必须紧跟在取值指令之后，因为后来的匹配会导致状态改变。
        // 例：
        // MODEL{
        //      DATA[32]{?} #64  // 提取前面 DATA 匹配目标的数据段。
        // }
        // #64 是 #[64] 的简写形式。
        // 支持管道符合并表达多个标记，如 #[1|2|64]。此时必须由中括号包围。
        // 注：
        // 提取的值会放入一个内部队列，作为MODEL最终的返回值。
        //
        // 注记：
        // 不支持实参提取，因为这需要执行脚本而非静态匹配。
        // 各个层级之间是独立的，无法跨层级提取前一个指令的数据。

118     _           指令通配
        // 目标指令可为任意指令，含附参和关联数据。
        // 例：
        // _    目标位置为任意一个指令，不能为空（结尾）。
        //
        // 注记：
        // 所有的匹配都不包含实参，因为实参是一个运行时概念，
        // 这里只提供静态匹配的逻辑。

119     _(1)        指令段通配
        // 目标可为任意指令段（同级连续）。
        // 这是上面 _ 指令的复数形式，也是后面 ... 指令的性能版候选。
        // 附参：目标段的指令个数。
        // 例：
        // _[3]     通配（忽略）源脚本当前位置及之后共3个指令。
        // _[0]     没有意义。
        // _[1]     与前面 _ 指令效果相同。
        // 注：
        // 一个指令包括指令本身和其附参与关联数据（视为一体）。
        // 各个层级之间是独立的，包含结构块的指令就只是一个指令。

120     ?(1)        指令局部通配
        // 用跟随指令来和目标作比较，附参指定了通配的部分。
        // 附参：位置标识。
        // 0000 0001    目标指令为可选（有|无）。(1)
        // 0000 0010    第1个附参任意。(2)
        // 0000 0100    第2个附参任意。(4)
        // 0000 1000    第3个附参任意。(8)
        // 0001 0000    第4个附参任意。(16)
        // 0010 0000    第5个附参任意。(32)
        // 0100 0000    关联数据任意。(64)
        // 1000 0000    关联数据的哈希匹配。(128)
        // 注：
        // 最多支持5个附参的通配标记，各个通配位可同时设置。
        // 如果附参和关联数据是同一个值，如值指令，则用数据表达通配，附参位指明长度类型。
        // 哈希匹配仅支持用附参定义数据长度的指令。
        //
        // 例：
        // ?[64] DATA[32]   跟随指令的关联数据任意（但必须为32字节长），适配 DATA{}(1)。
        // ?64 DATA[32]     同上。
        // DATA[32]{?}      同上。阅读友好，由解析器处理实际位置。
        // TEXT[300]{?}     匹配300字节长任意文本。注：将被解析为 TEXT{}(2) 指令。
        // ?[1] PRINT       目标位置有一个PRINT指令，或者没有。
        // ?1 PRINT         同上。
        // ?PRINT           同上，简化格式。
        // ?DATA[?]{?}      目标位置有一个DATA指令（附参和数据任意），或者没有。
        // ?DATA            同上，此时的 ? 相当于 ?[n]，n >= 1。
        // ?67 DATA         同上，67 = 1|2|64
        // ?DATA[32]{?}     目标位置有一个DATA指令（附参相同，数据任意），或者没有。
        // ?DATA[32]{...}   目标位置有一个DATA指令（数据相同），或者没有。
        // ?DATA{...}       同上，有数据指定时附参可忽略。
        // ?1 DATA{...}     同上。
        // ?{1234}          目标是一个整数值 1234，可选。
        // ?1 {1234}        同上，空格分隔时通配标识值1不可省略。
        //
        // 注意：
        // DATA[?]{?}       附参任意，关联数据任意。匹配任意 DATA{} 值。
        // !Bytes           效果同上。匹配字节序列型任意值。
        // ?1 !Bytes        目标是一个任意 DATA{} 指令，但可选（有或无）。
        // ?!Bytes          同上，两个指令紧邻时，通配标识 1 省略。
        // {?}[1]           目标是一个单字节正整数（uint8）。
        // !Byte            目标是一个字节（byte）。
        // {-?}[1]          目标是一个单字节负整数（-uint8）。
        // {?}[4]           目标是一个4字节正整数（uint32）。
        // {-?}[4]          目标是一个4字节负整数（-uint32）。
        // {?}              格式错误！长度未知。
        // ?{?}[8]          目标是一个8字节整数（int64），但可选。
        // {?}[20]          目标是一个20字节长的大整数。长度超出8字节则为大整数。
        // {.?}[4]          目标是一个4字节浮点数。
        //
        // 例：
        // @ ?64 DATA[32]   匹配实参取值，任意32字节序列。
        // @ DATA[32]{?}    同上。@ 之后的空格可选。
        // @ !Bytes         匹配字节序列取值指令（两个 DATA{}）。
        // $ POP            匹配 $ 和 POP 两个指令，空格可选。
        // $[?]             匹配局部域任意取值。
        // ?2 $             同上。
        // ?2 OUT[3]        首个附参任意，第二个附参确定。
        // OUT[?, 3]        同上，可读性更好。
        //
        // 例：
        // ?$               匹配局域设置指令 $ 可选（无附参）。
        // $[?]             匹配局域取值指令 $(1)，任意位置值。
        // ?$[?]            同上匹配，但可选。
        // ?$[]             同上，中括号不可省略。
        // ${?}             匹配循环变量指令 ${}(1)，任意取值。
        // ?${}             同上匹配，但可选。
        //
        // 深匹配：
        // 包含子语句块的指令称为高阶指令，如果其前面没有匹配指示（?指令），
        // 则正常进入子语句块作进一步匹配测试。
        // 此时附参表达指令自身子块长度，不参与比较。
        // 例：
        // IF{...}          递进到子块内进一步测试。
        // ({10} + _)       表达式内目标位置的指令任意。
        //
        // 单匹配：
        // 如果高阶指令前置了匹配指示，则视为单指令匹配，子块作为关联数据对待，
        // 不再进入子块作检查测试。
        // 例：
        // IF[60]{?}        匹配if指令，子块长60字节，内容不限，不再进入测试。
        // IF[?]{?}         匹配if指令，长度和内容都任意。即目标位置必须有一个IF。
        // ?IF              目标位置有一个IF，或者没有。
        // ()[30]{?}        目标表达式占用30字节，内容任意。
        // ()[?]{?}         目标是一个任意表达式，必须存在。
        // (?)              同上。简化格式。
        // ?()              目标位置有一个表达式，内容任意，有或没有。
        //
        // 哈希匹配：
        // 仅适用关联数据的严格匹配，可能采用160位哈希摘要。
        // 因为内容已严格约束，所以忽略指定其长度的附参。
        // ?128 DATA{0x4f262ae8...}         目标是一个 DATA{} 指令，其内容的哈希摘要为 4f262ae8...
        // ?128 MODEL{0x4f262ae8...}        目标是一个 MODEL 指令，其内容的哈希摘要为 4f262ae8...
        // ?130 MODEL{0x4f262ae8...}        同上，明确首个附参任意（冗余）。
        // ?[128|2] MODEL{0x4f262ae8...}    同上。支持管道符并列标记（130 = 128|2）。
        // MODEL[?]{0x4f262ae8...}          同上，阅读友好。
        // MODEL{0x4f262ae8...}             错误。通配符不可省略。
        // MODEL[?]{?}                      目标是一个 MODEL 指令。
        // DATA{0x4f262ae8...}              错误。数据应无0x前缀（DATA{}规范），或者通配符不可省略。
        // {0x4f262ae8...}[?]               目标是一个大整数，值的哈希摘要为 0x4f262ae8...
        // ?128 {0x4f262ae8...}             同上。
        //
        // 注记：
        // 文本源码解析构建指令码序列时，如果：
        // - 设置关联数据通配，则关联数据位置会被取消，不再占用空间。
        // - 设置附参通配，则附参位取消或置零占位（不可取消时，如多个附参）。

121     ?{}(1)      指令序列可选
        // 内部的指令序列与目标相同或者不存在。
        // 附参：内部指令序列长度。
        // 这是前面局部通配零值可选模式的扩展版，同时支持多个指令可选匹配。
        // 注意这是一种全等匹配，含指令的附参和数据。
        // 内部罗列的指令没有特殊含义，因此不应当包含模式指令。
        // 提示：
        // 如果只需要单个指令可选，可使用前一个指令（无花括号）。
        // 例：
        // ?{ @TOP PRINT }  忽略打印指令序列。
        // ?@ ?TOP ?PRINT   使用前面局部通配指令（多次），效果相同。
        //
        // 注记：
        // 出于实用性考虑，这里仅支持1字节长度的指令序列可选。
        // 如果需要包含结构块指令，结构块内容需要明确书写，因为这只是字节相等测试。

122     !(1){Type}  类型匹配
        // 目标为特定类型的值指令。
        // 附参：类型标识值。
        // 类型名：
        // - Bool   布尔值（2个值指令）
        // - Int    整数（7个存值指令）
        // - Byte   单字节
        // - Rune   单字符
        // - BigInt 大整数（实为*BigInt，不区分指针）
        // - Float  浮点数（2个）
        // - Bytes  字节序列（2个）
        // - String 字符串（2个）
        // - RegExp 正则表达式（实为 *RegExp，不区分指针）
        // - Time   时间类型（DATE{}）
        // - Script 脚本（*Script）
        // 特别支持：
        // - Number 整数或浮点数
        // - Model  模式块（整体对待）
        // 例：
        // !{Bool}  目标必须是布尔类型（true|false）。
        // !Bool    同上，可省略花括号。
        // !Bytes   匹配两个 DATA{} 指令。
        // !String  匹配两个 TEXT{} 指令。
        // !Script  匹配 CODE{} 指令。
        // !Int     匹配任意整数。
        // !Float   匹配任意浮点数。
        // !Number  匹配任意整数和浮点数。
        // !Model   目标是一个模式块（同 MODEL[?]{?}）。
        // 注：
        // 花括号内用名称指定，解析器会自动用其标识值代替。

123     !{}(~,~)    整数值范围匹配
        // 目标值在设定的范围之内时匹配，否则失败。
        // 附参1：下边界值，变长整数（Varint）。包含。
        // 附参2：上边界值，变长整数（Varint）。不包含。
        // 例：
        // !{0, 1024} 限定目标值：0 ≦ n < 1024
        // !{0, 128}  限定目标值：0 ≦ n < 128（目标通常是 {}(1) 指令）。
        // 注：
        // - 整数由多个指令表达，范围匹配并不要求目标具体是哪个指令，
        //   只要值满足要求即可。
        // - 不支持大整数（BigInt）范围匹配。

124     !{}(8,8,4)  浮点数值范围匹配
        // 目标值在设定的范围之内时匹配，否则失败。
        // 附参1：下边界值，8字节表达。包含。
        // 附参2：上边界值，8字节表达。不包含。
        // 附参3：下边界相等误差（差值不超过即视为相等）。
        // 例：
        // !{0, 1.0, 0}         目标为0或小于1.0的任意正浮点数。与0的相等比较可精确，故误差可为0。
        // !{0.1, 10, 1e-10}    目标为0.1~10之间的任意值，下边界误差不超过1e-10时也为合规。
        // !{0.1, 10, 0}        目标同上，但下边界的相等判断由浮点数二进制实现决定。
        // 注记：
        // 仅用4字节浮点数（float32）表达误差，因此极大误差的两个值无法被视为相等。
        // 可用误差值范围：1.4013e-45 ~ 3.4028e+38

125     RE{!/.../gG}(1,1)    正则匹配
        // 对文本或字节序列目标执行正则表达式匹配。
        // 附参1：匹配标识值（g|G|!）。
        // 附参2：双斜线之内的正则式内容长度。
        // 前置!：通关性检查标志（注：由附参1的高位表达）。
        //      有：无匹配时视为失败。
        //      无：普通匹配取值（可无值）。
        // 注意：
        // 不是检查目标是否为合规的正则表达式指令，而是对目标执行正则式匹配。
        // 匹配的结果值可以通过下面的 & 指令（依附关系）获取。
        // 支持 MATCH 指令的全局匹配标识 g|G，但默认时始终返回一个切片，以便于取值。
        // 例：
        // RE{/(?i)[a-z]+/}     查找首个匹配，结果为一个单成员切片暂存
        // RE{!/(?i)[a-z]+/}    同上匹配和暂存，但如果没有匹配则视为失败（模式不通过）
        // RE{/(?i)[a-z]+/g}    查找全部匹配，结果为一个全部匹配的切片暂存
        // RE{!/(?i)[a-z]+/g}   同上匹配和暂存。没有找到匹配时失败
        //
        // 附注：
        // 没有前置RE和花括号的 /.../ 才是指令自身匹配检查。
        // 目标必须是字符串或字节序列类型，否则会抛出异常。

126     &(1)        取值指示（正则匹配）
        // 配合上面的 RE{/.../} 指令使用，针对其匹配目标，取匹配值或子匹配式的值。
        // 附参：正则表达式的取值序位。
        // 这是模式内除 # 指令外的第二个取值指令，它们的取值共同构成 MODEL{} 的返回值。
        // 注意本指令需要紧随其属主指令 RE{/.../} 之后。
        // 在下一个RE{}之前，可以多次取值或提取各个不同的部分。
        // 如果目标没有匹配或目标序位无值，取值为nil。
        // 例：
        // MODEL{
        //      RE{/(?i)[a-z]+/} &[0]   取目标匹配结果中的首个成员
        // }
        // 例：
        // RE{/Ver-(\d+)/} &[1]     取首个子表达式的匹配项（主版本号）
        // RE{/Ver-(\d+)/} &1       同上。简写形式
        // RE{/(?i)[a-z]+/g} &3 &1  取全局匹配的第四个和第二个匹配结果
        // 注：
        // 上面示例中省略了上级封装指令 MODEL{}。
        //
        // 注记：
        // 最多支持256个匹配结果的取值，如果有更多的匹配将无法取到。
        // 目标值可能是字符串或字节序列，因此取值实际上是一个any值（空值为nil）。
        // 各个层级是独立的，只能提取到本层级的匹配结果。

127     ...         指令段通配
        // 在当前层级匹配任意指令序列，包括附参和数据。
        // 采用非贪婪模式：
        // - 用跟随指令序列（下一个平级...之前）与目标逐项测试，向后迭代直到完全匹配时止，
        //   这一过程所忽略的目标指令即是本指令的匹配目标。
        // - 如果目标指令包含子语句块且与跟随指令相同，则两个子块会作整体测试（进阶匹配）。
        // 例：
        // 目标脚本：
        //      SYS_TIME{Stamp} {<expireTime>} GT
        //      @TOP PRINT              // 1
        //      IF{
        //          @POP PRINT
        //      }
        //      TRUE
        //      IF{
        //          TEXT{Hello in IF}   // 2
        //          @TOP PRINT          // A
        //      }
        //      TEXT{done!}
        //      @TOP PRINT              // B
        //      @POPS[] NOP
        // 模型：
        // MODEL{
        //      SYS_TIME{Stamp}         // 换行没问题
        //      {<expireTime>} GT
        //      ...                     // 1
        //      IF{
        //          ...                 // 2
        //          @TOP PRINT          // A
        //      }
        //      TEXT{done!}
        //      @TOP PRINT              // B
        //      @POPS NOP               // 终点完整匹配（POPS[] 与 POPS 效果相同）
        // }
        // 1.
        // 第一个...匹配“@TOP PRINT IF{...} TRUE”。注：到第二个 IF{...} 匹配时止。
        // 2.
        // 第二个...匹配「TEXT{Hello in IF}」，到A为止，不会跨层级测试。
        //
        // 模型：
        // MODEL{
        //      SYS_TIME{Stamp}
        //      {<expireTime>} GT
        //      ...
        //      IF{?}           // 匹配上面第一个IF（非贪婪）
        //      ...             // 剩余匹配
        // }
        // 注意：
        // 最后的...是必须的，这是匹配完整性要求（匹配到脚本结束）。
        //
        // 模型：
        // MODEL{
        //      SYS_TIME{Stamp}
        //      {<expireTime>} GT
        //      ...
        //      IF{?}           // 匹配上面第二个IF，
        //      TEXT{done!}     // 因为本指令与IF共同形成一个约束。
        //      ...             // 剩余匹配
        // }
        //
        // 警告：
        // 本指令是“段-段”匹配，需要反复逐个测试，因此会有较多的性能损失。
        // 如果可能，尽量避免使用，或在短的块内使用。或用 _(1) 指令替代。
        //
        // 提示：
        // 连续的两个或多个 ... 没有意义，因为没有跟随指令段用于适配终止。
```


#### 附：模式匹配的方式

- **位置匹配**：模式指令与目标指令按位置对比匹配。
- **指令匹配**：指令相同即为匹配。如果指令为值指令，则也隐含了类型匹配逻辑。
- **附参匹配**：在指令匹配的前提下，附参参与匹配。
- **数据匹配**：在指令匹配的前提下，指令关联的数据也参与匹配。
- **范围限定**：整数和浮点数按值的范围匹配。
- **类型匹配**：对目标的数据类型执行匹配，值任意。
- **正则匹配**：支持 `RE{/../}` 对文本和字节序列目标进行正则匹配，可通过 `&` 指令提取匹配的结果。
- **片段匹配**：连续多个指令片段的匹配或通配。

> **注：**
> 流程类指令（`IF{}`、`SWITCH{}` 等）在有子内容匹配时，附参会被忽略。


### 13. 环境指令

脚本的运行处在一个逐层嵌套的环境里：`系统环境 > 交易域 > 校验域 > 脚本域 > 局部域`，其中前者是后者的父域。

1. **系统环境**。节点的运行时环境。包含节点能提供的一些系统级信息。
2. **交易域**。  一笔交易可包含多个输入和输出，以及输入的来源输出部分。
3. **校验域**。  当前脚本的校验环境，包含 `GOTO` 跳转引入的脚本的验证。
4. **脚本域**。  当前脚本的全局环境。`JUMP` 嵌入的子脚本与当前脚本共享此域，但 `GOTO` 跳转的脚本拥有自己的脚本域。
5. **局部域**。  当前脚本按语法块分层的存储区，包含顶层和嵌套子块。这些域是私有的，无法互访。

> **注：**
> 证据中的输出（识别脚本）是在客户端需要确认它（另一种意义上的输入）时，才需要验证。

该类指令大多不需要实参，除了设置全局变量的 `SETVAR`。

指令值区间：`[128-137]`，10个。

```go
指令码  指令字      说明
-----------------------------------------------------------
128     ENV(1){}    环境变量取值
        // 附参：目标名称的标识值，uint8。
        // 返回值：目标成员值。
        // 书写时通常使用标准的名称而不是数值下标。
        //
        // 交易域：
        // 针对脚本所在的源交易。
        // - Height     理想块高度（按时间戳算）
        // - Time       理想块时间戳
        // - RealHeight 交易打包进的实际区块的高度
        // - TxID       交易ID
        // - Timestamp  交易创建时间戳
        // 例：
        // ENV{RealHeight} 获取当前输入所在交易的真实区块高度。
        //
        // 针对当前正在验证的交易。
        // 注：对于定义这些取值的脚本来说，是指将来花费它们的交易。
        // - InSize     输入项总数
        // - InAmount   输入总金额
        // - OutSize    输出项总数
        // - OutAmount  输出总金额
        //
        // 校验域：
        // 特定于当前脚本。
        // - InGoto     是否在 GOTO 跳转的脚本中
        // - InJump     是否在 JUMP 引入的脚本中
        // - Gotos      当前 GOTO 跳转计数
        // - Jumps      当前 Jump 嵌入计数
        //
        // 系统环境：
        // - BlockHeight 区块链当前最新高度
        // - BlockTime   当前最新区块创建的时间戳
        // - LimitStack  栈高度上限（256）
        // - LimitScope  局部变量域上限（128）
        // - ……

129     OUT(2,1){}  输出项取值（交易域）
        // 针对当前交易的输出项集（即正在验证的交易）。
        // 可用于支付源约束花费者的消费行为（比如遗嘱，预定的受者）。
        // 附参1：输出项偏移（起始值0）。
        // 特殊值：0xffff 表示和当前输入相同的偏移值。
        // 附参2：输出项中的成员标识。
        // 返回值：目标成员值。
        // 成员：
        // 具体输出：
        // - Amount      币金数量
        // - Receiver    接收者
        // - Description 凭信描述，适用凭信交易
        // - Count       凭信转移计数，适用同上
        // - Title       证据标题，适用证据交易
        // - Content     证据内容，适用同上
        // - Attachment  附件ID，适用凭信和证据交易
        // - Source      输出脚本自身
        // 例：
        //      OUT[0]{Amount}
        // 取当前在验交易中首个输出项的币金数量。
        // 注意：
        // 这可能只是一个全账户计算结果，但也可能被存储在交易数据中（效率考虑）。

130     IN(1){}     输入项取值（校验域）
        // 支付来源脚本在当前交易的输入部分的信息。
        // 附参:目标项标识值。
        // 返回值：目标成员值。
        // 成员：
        // - Index      当前输入在输入集内的偏移（索引）
        // - Amount     当前输入币金数量（币金类才有）
        // - Account    当前输入账户（公钥地址）
        // - Address    当前输入地址（文本地址）
        // - PayType    当前输入的类型（币金|凭信）
        // - Sigs       当前输入已签名数量（>= 0）
        // - CanSigs    当前输入能够签名的数量（>1时为多重签名账户）
        // - SigType    当前输入的签名类型
        // - Source     当前输入脚本（含解锁部分），注：INOUT/Source 为不含解锁部分

131     INOUT(1){}  输入项的源输出项取值（交易域）
        // 与前面 OUT 指令类似，但这里只有输入项对应的来源输出。
        // 附参：取值的成员标识。
        // 返回值：目标成员值。
        // 成员：
        // - Timestamp   源交易的创建时间戳
        // 其它同上 OUT 指令部分。
        //
        // 注记：
        // 不牵涉源输出交易的整个输出集，因为那管得太宽了。
        // 同时也影响效率（需要新的数据）。

132     XFROM(1){}  获取源脚本信息
        // 外部脚本对跳转来源交易的信息检索（GOTO, JUMP, EVAL）。
        // 附参：目标信息标识值。
        // 返回值：任意类型，单值。
        // 成员：
        // - Source     源脚本指令序列（从开头到跳转点，可能含解锁脚本）
        // - Offset     跳转/嵌入点在源脚本中的偏移位置
        // - InSize     源交易输入集大小（项数）
        // - InAmount   源交易输入总金额
        // - OutSize    源交易输出集大小（项数）
        // - OutAmount  源交易输出总金额
        // ENV 相同：
        // - TxID       源交易的ID
        // - Height     理想块高度
        // - Time       理想块时间戳
        // - Timestamp  源交易的创建时间戳
        // IN 相同：
        // - Amount     源输入币金数量（币金类才有）
        // - Account    源输入账户（公钥地址）
        // - Address    源输入地址（文本地址）
        // - PayType    源输入的类型（币金|凭信）

133     VAR(1)      全局变量取值（脚本域）
        // 附参：目标变量位置。
        // uint8 类型，最多支持256个变量。
        // 与局部域不同，此为变量逻辑，可被定位覆盖赋值。
        // 返回值：目标置位的值，单值。
        // 例：
        // @VAR[0] 取全局变量段里0号位的值添加到实参区。
        // VAR[10] 取全局变量段里第10号位置的值入栈。
        // 注：
        // 本指令属于脚本域，不跨GOTO。
        // JUMP指令跳转的脚本共享同样的脚本域，因此会相互影响。
        // 注记：
        // 实现可能是一个map[int]any，而不是一个切片。

134     SETVAR(1)   全局变量赋值（脚本域）
        // 在脚本域的全局变量区设置值，变量定位采用8位数值。
        // 可由上面的 VAR 指令读取。
        // 附参：变量位置值。
        // 实参：任意类型，单值。
        // 返回值：无。
        // 例：
        // {123} SETVAR[1]    将栈顶的值 123 存入全局变量段的第1号位置。
        // {1.5} SETVAR[255]  将浮点数 1.5 存入全局变量段的第255号位置。
        // $VAR[1]            读取上面存储的 123 添加到当前局部域。

135     SOURCE(1)   获取当前源脚本字节序列（脚本域）
        // 获取当前同级源码指令序列的一个字节序列引用。
        // 附参：片段标识值。
        // > 0  当前块完整代码。
        // > -1 前阶已执行的代码段，包含当前指令。
        // > -2 前阶已执行的代码段（含当前指令），但从NULL点开始。
        // > 1  后阶尚未执行的代码段，不含当前指令。
        // > 2  从NULL点开始的到脚本末尾的片段。
        // 返回值：字节序列（原始引用）。
        // 提示：
        // 仅局限于当前层级范围，不包含上层脚本段但包含内部的子块代码。
        // 因此，只有在顶层才能获取到原始完整的脚本（含解锁部分）。
        //
        // 如果需要在子块内使用上层或其它块脚本，可以在其中先提取后存入全局变量区备用。
        // 如果需要对代码进行截断取片，可以执行SYS_NULL指令设置NULL点。
        //
        // 注记：
        // EVAL 指令要求 *Script 实参，此仅返回字节序列以回避。
        // NULL点可用于截取部分脚本，比如 P2SH 中分隔不需要哈希的部分。

136     MULSIG(1)   多重签名序位确认（校验域）
        // 目标序位的账户有签名时返回true，否则返回false。
        // 附参：目标序位。
        // 即多重签名公钥地址列表中的序位，从0开始。
        // 返回值：布尔值。
        // 仅适用多重签名输入，在GOTO到的目标脚本中也可用。
        // 例：
        //      MULSIG[2]
        // 确认多重签名公钥地址列表中第3序位者参与签名。
        //      MULSIG[0] MULSIG[1] MULSIG[2] POPS[3] SOME[2] PASS
        // 确认公钥地址列表中前3个账户中至少有2个参与签名。

137     （未用）
```


### 14. 工具指令

包含一些基础性并常用的功能性指令，另外还包含一个保留区（未来用）。

指令值区间：`[138-163]`，26个。

```go
指令码  指令字      说明
-----------------------------------------------------------
138     EVAL        子脚本执行
        // 将实参视为脚本指令序列执行。私有环境。
        // 实参：*Script。
        // 考虑安全性，实参仅能由 CODE{} 创建，不支持普通的字节序列。
        // 返回值：私有栈条目集。
        // 提示：
        // 高消耗的脚本可能导致不受欢迎而被拉入黑名单。
        //
        // 注记：
        // 仅执行 CODE{} 明确创建的脚本片段，可用于功能性脚本创建和复用。
        // 源于栈脚本的逻辑，返回值为私有数据栈的剩余条目。

139     COPY        切片复制
        // 复制成员到一个新的切片中。
        // 实参：一个切片。
        // 返回值：一个新的切片。
        // 注意：
        // 如果目标切片的成员是any类型，
        // 这里的复制并不能保证新老切片成员底层没有相互引用。

140     DCOPY       切片深层复制
        // 复制切片成员到一个新的空间。
        // 实参：一个切片。
        // 返回值：一个新的切片，[]any成员会被递归处理。
        // 注意：
        // 仅保证6种切片成员会被深层复制：
        // - []any    会递进处理。
        // - []byte   字节成员复制。
        // - []rune   字符成员复制。
        // - []Int    整数成员复制。
        // - []Float  浮点数成员复制。
        // - []string 字符串成员复制。
        // 其它切片成员仅仅只是引用复制。

141     KEYVAL(1)   字典键值切分
        // 附参：取值标识。
        // - 0: 键, 值。两个切片。
        // - 1: 键。一个切片。
        // - 2: 值。一个切片。
        // 实参：一个字典。
        // 返回值：1-2个切片。
        // 注意：
        // 返回的切片成员是没有固定顺序的，每次不一样。
        // 如果返回键/值两个切片，两者的成员依然按下标位置对应。

142     MATCH(1)    正则匹配取值
        // 对字符串或字节序列进行正则匹配，取匹配值或子匹配的值。
        // 附参：匹配方式（g|G）。
        // 实参1：目标字符串或字节序列。
        // 实参2：正则表达式（*RegExp）。
        // 返回值：一个单值或集合。
        // 附参含义：
        // - g  查找全部匹配，但仅限于正则式的完整匹配。结果是一个any切片。
        // - G  查找全部匹配，包含其中的子匹配。结果是一个目标值类型切片的any切片。
        // - x  任意其它值，查找首个匹配。如果正则式包含子匹配，返回一个any切片，其中首个成员为完整匹配。
        //      如果正则式不含子匹配，则返回一个目标类型的单值。
        // 注意：
        // 如果正则式不含子匹配式，想要获取全部匹配应当使用 g 标记，
        // 因为 G 标记确定会返回一个二维数组。
        // 例：
        // ... /(?i)[a-z]+/ MATCH{g}        获取全部完整匹配，结果是一个切片。
        // ... /(?i)[a-z]+/ MATCH[103]      同上，g 用码值表示。
        // ... /(?i)Ver-(\d+)/ MATCH{G}     获取全部匹配，包含子匹配，结果是一个二维切片。
        // ... /(?i)Ver-(\d+)/ MATCH[0]     获取首个匹配。因为存在子匹配，返回的切片包含了两个成员。
        // ... /(?i)[a-z]+/ MATCH[0]        同上。没有子匹配，所以返回一个单值。

143     SUBSTR(2)   字串截取
        // 附参：字符（rune）数量。
        // 实参1：一个字符串。
        // 实参2：起始字符位置。按字符计数，从0开始。支持负数从末尾算起。
        // 返回值：一个子字符串。
        // 注：
        // 原始字符串应当是合法的 UTF-8 格式。
        // 注记：
        // 使用附参定义字符数量，可以约束字符串长度且更简单。
        // 作为栈脚本，字符数量预先指定是可行的（即不能由解锁脚本指定）。

144     REPLACE(1)  字串替换
        // 对目标字符串中匹配的部分进行替换。
        // 附参：替换次数，0值表示全部。
        // 仅对字串匹配式有效，匹配式为正则表达式时会替换全部（不能指定次数）。
        // 实参1：目标字符串。
        // 实参2：替换匹配式（子串或正则表达式）。
        // 实参3：替换串，可包含特殊标识（当匹配式为正则表达式时）。
        // 返回值：一个新的字符串。
        //
        // 注记：
        // 暂不提供对字节序列的替换能力（实用性&安全性考虑）。

145     SRAND       切片成员顺序扰乱
        // 实参：一个切片。
        // 返回值：成员顺序随机重排的一个新切片。
        // 注意：
        // 随机数的种子是安全的，但不保证排列随机性的安全。

146     RANDOM      获取一个随机数（安全）
        // 返回的随机数是安全的（crypto/rand）。
        // 实参：上限值（不含），可选。Int|BigInt 类型。
        // 返回值：一个小于实参的随机正整数，类型与实参相同。
        // 注意：
        // 上限值可选，如果提供则不可为负值。
        // 默认上限为int64可表达的最大值，也即默认返回Int类型。

147     QRANDOM     获取一个随机数（快速）
        // 快速获取一个随机数，但是随机性并不安全。
        // 实参：上限值（不含），可选。Int类型。
        // 返回值：一个小于实参的随机正整数。
        // 注意：
        // 上限值可选，如果提供则不可为负值。默认为int64可表达的最大值。
        // 应当仅用于没有安全性要求但需要性能的场景。

148     CMPFLO(1)   浮点数比较
        // 用于弥补前面比较指令中对浮点数相等测试的不足。
        // 附参：比较类型标识，int8类型：
        // > 0  相等比较（==）
        // > -1 小于等于（<=）
        // > 1  大于等于（>=）
        // 实参1：待比较值。
        // 实参2：待比较值。
        // 实参3：误差值，实参1-2间的差值不超过该值时即视为相等。
        // 返回值：一个布尔值。

149-154 （未用）

155     RANGE(2)    创建数值序列
        // 附参：序列长度（成员数量）。
        // 数值类型由实参表达，以实参1为基准。
        // 附参0值会创建一个空切片，此时的两个实参任意，但需占位和类型表达。
        // 实参1：起始值，Int|Float。
        // 实参2：步进值，Int|Float。
        // 返回值：一个整数或浮点数切片。
        // 例：
        // {10} {1} RANGE[5]    // 生成 [10, 11, 12, 13, 14]
        // {1.} {1.1} RANGE[5]  // 生成 [1.0, 2.1, 3.2, 4.3, 5.4]
```


#### 保留区

主要用于未来可能需要的基础性支持，比如与量子安全相关的能力。共计 8 个。

```go
156-163 （系统保留）
```


### 15. 系统指令

执行系统级功能的指令。

指令值区间：`[164-169]`，6个。

```go
指令码  指令字          说明
-----------------------------------------------------------
164     SYS_TIME(1){}   取全局时间对象的属性值
        // 全局时间对象是客户端真实的当前时间，只读。
        // 附参：目标属性的标识值。
        // 实参：无。
        // 每一个属性被规划为固定的序号位置，但也包含标准的命名。
        // 如果采用字符串名称，需书写在花括号内。
        // 属性：
        // - 默认         当前时间（Time）
        // - Stamp        当前时间戳（毫秒）
        // - Year         年次（4位）
        // - Month        月次/年（1-12）
        // - YearDay      日次/年（1-365|366）
        // - Day          日次/月（1-31）
        // - WeekDay      日次/周（0-6）
        // - Hour         时数/日（0-23）
        // - Minute       分钟数/时（0-59）
        // - Second       秒数/分钟（0-59）
        // - Millisecond  毫秒数/秒（0-999）
        // - Microsecond  微秒数/秒（0-999999）
        // 返回值：属性特定类型值
        // 注：返回的数值统一为Int类型。
        // 例：
        // SYS_TIME{Stamp} 获取当前系统的时间戳值入栈。
        // SYS_TIME[0]     获取当前时间对象。

165     SYS_AWARD       兑奖验算
        // 检查目标区块之后240个区块的兑奖槽，计算奖金兑现。
        // 仅适用区块的零号铸造交易（首笔输出）。
        // 实参：区块高度（历史区块）。
        // 返回值：奖金兑现值。
        // 规则：
        //      确认数   兑现比例
        //      ----------------
        //      1        20%
        //      2        40%
        //      3        60%
        //      4        80%
        //      5        100%
        // 说明：
        // 因为是统计之后的区块的兑奖确认数，奖励必须超过一天才能兑现。
        // 所以当前铸造者需要分析前面240个区块的兑奖槽并计算-241号区块的奖金截留。
        //
        // 注记：
        // 用户能够取走的奖金和将要被截留的部分可能各自计算，但应互为契合。
        // 兑奖检查由系统内部完成，对外用处不大。

166-168 （未用）

169     SYS_NULL        设置间隔点
        // 在当前位置为脚本设置一个标记，供脚本片段提取时使用。
        // 主要对 SOURCE 指令有影响。
```


### 16.函数指令

除了最后一个扩展函数专用指令，通常来说函数指令没有附参，全部需要的输入信息由实参提供。

指令值区间：`[170-209]`，40个。


#### 基础函数集

定义一些常用的基础性函数。

> **注意：**
> 函数指令也可以有附参，但有附参的函数指令应当尽可能定义在这第一层级。
> 这里的指令书写按普通函数定义的方式，实参可从小括号内的文本体现出来，更为直观。

```go
指令码  函数名（参数序列） => 返回值类型
-----------------------------------------------------------
170     FN_BASE58( data Bytes|String ) => String|Bytes
        // 将目标字节序列为编码为 Base58 字符串，或反向解码。
        // 实参：字节数据或已编码字符串。
        // 返回值：编码字符串或解码字节序列。
        // 注：
        // 视实参类型来决定解码还是编码。

171     FN_BASE32( data Bytes|String ) => String|Bytes
        // 将目标字节序列编码为 Base32 字符串，或反向解码。
        // 实参：字节数据或已编码字符串。
        // 返回值：编码字符串或解码的字节序列。
        // 规范：
        // RFC 4648，大写 + 234567。
        // 注：
        // 编解码数据没有填充字符。
        // 编码或解码时实参类型而定，自动判断。

172     FN_BASE64( data Bytes|String ) => String|Bytes
        // 将目标字节数据编码为 Base64 字符串，或反向解码。
        // 实参：字节数据或已编码字符串。
        // 返回值：编码字符串或解码的字节序列。
        // 注：
        // 编解码数据无填充字符，增补字符采用URL友好类型（-_）。
        // 编码或解码由实参类型自动决定。

173     FN_PUBHASH( data Bytes|String ) => Bytes
        // 创建或解码为公钥地址。
        // 对公钥实参进行特定规则的哈希构造，创建出公钥地址。
        // 或者对字符串账户地址实参执行解码，提取其中的公钥地址。
        // 实参：公钥数据或文本账户地址。
        // 返回值：公钥哈希地址。
        // 注：
        // 公钥哈希地址通常简称为公钥地址。
        // 是创建或是解码，视实参类型而定。

174     FN_MPUBHASH( pubKeys, restPKHS []any ) => Bytes
        // 创建多重签名公钥地址。
        // 实参1：签名所用公钥集。
        // 实参2：剩余未签名公钥地址集。
        // 返回值：多重签名总公钥地址（前置 n/T 配比）。
        // 注：
        // 两个集合中的成员实际类型为 Bytes。
        // 所有 Bytes 成员的首字节为它们在公钥地址清单中的序为（从0开始）。

175     FN_ADDRESS( pbHash Bytes, prefix String ) => String
        // 将公钥地址编码为可视的账户地址（Base58）。
        // 包含地址验证功能和前置识别标识。
        // 实参1：公钥地址。
        // 实参2：识别前缀。
        // 返回值：账户地址字符串。
        // 提示：
        // 文本形式的账户地址主要用于传输和UI展示。
        //
        // 编码：
        // 0. 公钥地址添加识别前缀，即“前缀+公钥地址”注：加号（+）仅表示连接。
        // 1. 对其执行两次哈希运算，取末尾4字节为校验码。
        // 2. 在公钥地址之后附上校验码（此时无前缀），编码为文本地址。
        // 3. 附上识别前缀，即“前缀:文本地址”即为可视的账户地址。注：分隔符（`:`）是系统自动添加的。
        // 校验：
        // 0. 提取识别前缀（借助 `:` 分隔符）和文本地址。
        // 1. 将文本地址解码为字节序列。截取末尾4字节校验码，前段即为公钥地址。
        // 2. 公钥地址前置识别前缀（即“前缀+公钥地址”），执行两次哈希运算取末尾4字节为校验码。
        // 3. 比较两个校验码，相同则地址合法。

176     FN_CHECKSIG(1)( sig, pubKey Bytes ) => Bool
        // 单签名验证。
        // 附参：签名消息种类标识。
        // 实参1：签名数据。
        // 实参2：签名用公钥。
        // 返回值：成功与否。
        //
        // 注记：
        // 签名消息种类在这里设定，意味着支付者对将来的花费者有着更为严格的约束。
        // 此时花费者就失去了自由定义使用场景的权力，这一般在定制验证中出现。
        //
        // 只有在输出采用系统内置验证时，花费者才有机会通过签名种类表达自己对使用场景的要求。
        // 比如只对交易的输入项（资金来源）签名，输出则可以任意（随便给谁都行）。

177     FN_MCHECKSIG(1)( sigs, pubKeys []any ) => Bool
        // 多重签名验证。
        // 附参：签名消息种类标识。
        // 实参1：签名集。
        // 实参2：签名用公钥集。与签名集成员一一对应。
        // 返回值：成功与否。
        // 两个集合中的成员实际上为 Bytes 类型。
        // 公钥首字节可能是序位标识，在此无用（容错）。
        //
        // 注记：
        // []Bytes 类型在数据栈中并不存在，因为Bytes入栈即为any。

178     FN_HASH224(1)( data Bytes ) => Bytes
        // 哈希计算。
        // 附参：哈希算法标识（sha3|sha2|blake2），默认 sha3。
        // 实参：任意字节序列。
        // 返回值：28字节长。
        // 注记：
        // 支持算法标识可以使得算法升级更和缓，
        // 因为新算法可以在任何时候补充进来，而旧算法淘汰可由用户的选择完成。
        // 当然，一定时间后旧算法也可能不再支持。

179     FN_HASH256(1)( data Bytes ) => Bytes
        // 哈希计算。
        // 附参：哈希算法标识（sha3|sha2|blake2），默认 sha3。
        // 实参：任意字节序列。
        // 返回值：32字节长。
        // 例：
        // DATA{...} FN_HASH256{sha3}   // 采用 sha3.Sum256（FIPS-202）
        // DATA{...} FN_HASH256         // 同上，默认算法
        // DATA{...} FN_HASH256[0]      // 同上，数值附参
        // DATA{...} FN_HASH256{sha2}   // 采用标准库 sha256.Sum256（FIPS 180-4）
        // DATA{...} FN_HASH256{blake2} // 采用 BLAKE2b 算法
        // 注：
        // 哈希计算通常用于建立一道哈希屏障保护。
        //
        // 注记：
        // 这里的 blake2 实为 BLAKE2b 算法。
        // 在安全性上，BLAKE2b 比 SHA2 好，在 64位 x86 和 ARM 架构上也比 SHA2/SHA3 块。
        // 维基百科：https://en.wikipedia.org/wiki/BLAKE_(hash_function) 。

180     FN_HASH384(1)( data Bytes ) => Bytes
        // 哈希计算。
        // 附参：哈希算法标识（sha3|sha2|blake2），默认 sha3。
        // 实参：任意字节序列。
        // 返回值：48字节长。

181     FN_HASH512(1)( data Bytes ) => Bytes
        // 哈希计算。
        // 附参：哈希算法标识（sha3|sha2|blake2），默认 sha3。
        // 实参：任意字节序列。
        // 返回值：64字节长。

182-207 （未用）

208     FN_PRINTF( fmt, val, ... ) => nil
        // 格式化打印（格式化串，实参1，实参2，...），同 go:fmt.Printf。
        // 实参：1+不定数量。
```


#### 基础函数扩展

```go
指令码  指令字          说明
-----------------------------------------------------------
209     FN_X(1){}       扩展函数引用
        // 附参：目标索引。
        // 基础扩展仅支持1字节空间，可扩展256个函数指令。
        // 如果需要更多功能性函数，请使用正式的扩展指令 EX_FN（见后）。
        // 友好：
        // 花括号内可用目标名称书写。
```


### 17.模块指令

模块的成员以标准的名称书写在花括号内，附参通常仅为1个字节，用于索引成员函数。

作为约定，模块如果需要创建一个表示自身的对象，应由首个成员 `Create` 实施。如果其它成员函数需要使用该对象，应作为首个参数传入。

指令值区间：`[210-249]`，40个。

```go
指令码  指令字          说明
-----------------------------------------------------------
210     MO_RE(1){}      正则表达式模块
        // 处理正则表达式对象，对象作为首个参数传入。
        // 可由 /.../ 指令创建，或由 REGEXP 指令转换而来。
        // 方法：
        // - （待定）

211     MO_TIME(1){}    时间模块
        // 处理日期/时间对象，对象作为首个参数传入。
        // 可由 DATE{} 指令创建，或由 TIME 指令转换而来。
        // 方法：
        // - （待定）

212     MO_MATH(1){}    数学运算模块
        // 例：
        // MO_MATH{Abs} 计算实参的绝对值。
        // 成员：
        // - Abs    绝对值：|-4| => 4
        // - IsInf  无穷大判断
        // ...

213     MO_CRYPT(1){}   加密运算模块
        // 对称加密：
        //
        // 非对称加密：
        //

214-248 （未用）
```


#### 标准模块扩展

```go
指令码  指令字          说明
-----------------------------------------------------------
249     MO_X(1){}       扩展模块引用
        // 附参：目标索引。1字节可扩展256个模块。
        // 花括号内可用目标名称书写（友好）。
        // 例：
        // MO_X{Example.Create}  模块名和方法名间用句点连接
        // 注记：
        // 256个扩展模块空间应该已经足够，
        // 如需更多功能支持，可使用扩展指令区的 EX_INST。
```


### 18. 扩展指令

最后的5个指令空间位用于扩展指令区。

指令的扩展籍由附参实现，主要包含了一个函数类扩展指令 `EX_FN`、一个通用性扩展指令 `EX_INST`（指令本身是一个完整的逻辑，可以包含其自身的附参或数据）、一个第三方私有类扩展指令 `EX_PRIV`。

指令值区间：`[250-254]`，5 个。

```go
指令码  指令字          说明
-----------------------------------------------------------
250     EX_FN(2){}      函数类扩展
        // 附参：目标索引。2字节可定义64k个指令。

251     EX_INST(2){}    通用类扩展
        // 附参：目标索引。2字节可扩展64k个目标。

252     （未用）

253     EX_PRIV(2){}    第三方私有扩展
        // 附参：目标索引。2字节可扩展64k个指令或目标。
        // 私有范畴：
        // 公共节点简单忽略，由有特定需求的应用发展和使用。

254     （未用）
```


### 系统保留码

最后一个指令码 `255` 为系统保留（用途未知），暂不在指令集内使用。



## 源码的格式

用户书写的源码并不会直接作为交易脚本保存在交易的数据里，而是经过解码器转换为指令码值存储。

用户书写源码时，换行和缩进是自由的，指令之间是用空格或空白区隔识别，因此用户书写的源码可以有良好的阅读格式（如果你那样做的话）。但是当指令码值逆向展示为源码时（比如区块浏览查询时），一个良好的格式是必要的。

脚本指令码序列中没有换行符码值表达换行，也没有表达缩进的指令，因此后期展示的源码并不与原始的源码有相同的格式。

后期逆解析展示的源码由固定的规则约束，可能并不十分悦目，但至少存在换行和缩进，以及行长限制。这样的源码可读性会好很多。

### 源码自动格式约束

脚本指令序列逆向解析展示时，遵循如下换行和缩进规则。

- **子块缩进**：包含子语句块的结构指令会将内容换行并缩进显示。
- **行长限制**：连续的指令显示不会超过一定长度，超过时即换行。
- **独行指令**：单个指令通常不会被断开显示，因此包含较长值的指令会显示在单独一行，比如：`DATA{}`, `TEXT{}`, 大整数和正则表达式等。以及惯用独行的 `FALLTHROUGH`, `CONTINUE` 等。
- **行尾指令**：部分指令显示在行尾有更好的含义表达，比如：`PASS`, `FAIL`, `RETURN`, `EXIT` 等。它们会导致当前行结束。
- **跟随指令**：部分指令与前阶指令紧密相关，它们应当显示在同一行，比如 MODEL{} 中的取值指令 `#(1)`, `&(1)`，以及包含实参提取的 `BREAK`, `EXIT` 等。
- **前缀指令**：部分指令是后阶指令的前置指令，它们也应当与后阶指令显示在同一行，比如：`@`, `~`, `$`, `?(1)` 等。

如果 **行长限制** 与其它规则相冲突，则视情况灵活处理。如：

- *强制折行*：适用独行指令。
- *提前换行*：适用跟随指令、前缀指令。
- *适当宽容*：适用行尾指令、前缀指令、跟随指令。
- *可接受违例*：适用行尾指令。


-------------------------------------------------------------------------------

上一篇：[脚本系统设计](5.脚本系统设计.md)<br>
下一篇：[附1：组队校验](附1.组队校验.md)<br>
