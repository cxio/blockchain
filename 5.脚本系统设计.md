//////////////////////////////////////////////////////////////////////////////
Copyright (c) 2019 - 2022 @cxio/blockchain

    Permission is granted to copy, distribute and/or modify this document
    under the terms of the GNU Free Documentation License, Version 1.3
    or any later version published by the Free Software Foundation;
    with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
    A copy of the license is included in the section entitled "GNU
    Free Documentation License".
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&


## 概述

交易是信用呈现和转移的一个包装单元，除了必要的基本信息外，一笔交易中主要包含输入和输出两个部分。输入表达的是信用来源（由另一笔交易的输出定义），输出表达信用转移的目的地（由信用值如金额和一个可执行的锁定脚本构成）。

用户之所以能够使用另一笔交易的输出来作为本次交易的输入，是因为他或她能提供那一笔交易输出里锁定脚本的解锁证明，让本次交易验证里可以成功执行上一笔交易输出里的锁定脚本。这就是区块链交易的验证逻辑。

> **注：**
> 下文中的代码并非Go语言代码，仅是借语法颜色以获得良好显示。



## 三种基本信元

在本设计中，信用的数字表达有三个：**币金**、**凭信** 和 **存证**，它们可被称为「信元」。币金是可拆分的数值，类似货币；凭信是不可拆分的文本或二进制数据，类似契约、债券或与实物绑定的数字凭证；存证则是一种存在性表达，可能是文本也可能是二进制数据，不可拆分也不能转移。

如果一笔交易里的输入项全部是币金，这就是一笔纯粹的转账交易，如果还包含有凭信或存证，就是一笔混合交易。仅仅包含凭信或存证的交易虽然逻辑上没有问题，但交易上链是需要交易费的（打包交易的矿工需要激励），因此必须要有币金信元的输入（注：币金输入与输出的差值即为交易费——矿工计算验证后即可创建等额的新币归自己所有）。

锁定脚本由指令序列构成，包含：数据定义、流程控制、算术运算、条件对比、对外交互、以及功能性函数指令等。解锁证明也是一段指令序列，俗称解锁脚本或解锁参数，通常只是数据定义和变量设置。

脚本依然沿用Bitcoin区块链中的**栈结构**设计：一个初始的空栈用于暂存指令的实参，每一个指令执行的结果又被压入栈中，为后续指令提供参数数据。栈是后进先出（LIFO）的逻辑，出于安全和性能的考虑，脚本有长度和执行时间的限制。

不同于Bitcoin系统中的脚本指令规则，这里进行了较多的扩展，以期获得完整的编程逻辑。


### 币金

数字化的信用单位，表达具体额度的价值，类似于货币或金钱，有时也被称为代币或Token。因为是数值，所以可以执行算术逻辑，分割或合并。

接收币金的通常都是一个标准地址，出于优化，解锁会默认执行前置的签名验证，即验证指令序列无需书写在锁定脚本里。

> **注：**<br>
> 接收者也可以是非标准的任意目标，此时则无法应用标准的内置验证。<br>

币金的生成只能由区块的铸造者完成（铸币），币金的转移交易则是任何人都可以创建的。


#### 输入项

一笔币金的输入项即币金的来源，也即上一笔交易的输出项（币金的接收者）。

输入项仅需能够准确地引用来源即可，验证并不是输入项本身的职责。因此这里设计的输入项结构为：`2+20+2` 共24字节。其中：

- `[2]`  交易的年份，由交易的时间戳决定，2字节长。
- `[20]` 交易ID引用，考虑足够的碰撞安全冗余，截取交易ID中的后20字节即可。
- `[2]`  输出项下标偏移值。

年度值是一种人性化友好，同时也能获得一个长分级特性，即：年度可以按现实持续延展，直至2字节能表达的最大年份（公元65535年）。


#### 接收者

如果是采用系统内置的默认验证，接收者需要是标准格式的地址。

标准的地址包含2种：

1. **P2SA**: 即 `Pay to Single Address`，同Bitcoin中的 `P2PKH`。这里交易数据中实际存储的是公钥哈希地址（简称*公钥地址*）。
2. **P2MA**: 即 `Pay to Multiple Address`，支付到多重签名地址。同上，交易数据中存储的也是多重签名的公钥地址。详情见下 *多重签名*。

如果采用定制验证，接收者是可选的，但一个友好的名称通常也很不错（<256字节）。

Bitcoin 中的 `P2SH (Pay to Script Hash)` 在 Bitcoin 系统中主要用于多重签名，但实际上它是一种通用逻辑。这里，我们把多重签名的概念提取出来，作为一种预定义的标准格式处理。

在本设计中，`P2SH` 属于定制验证的范畴（详情见后）。

> **注：**
> 本设计拥有丰富灵活的栈脚本语法环境，可用于复杂的信用逻辑编程，因此多重签名也需要独立出来。


#### 数量

一个变长的整数值，表达币金的数量。单位为「聪」（纪念Bitcoin创世者中本聪）。

数量属于输出里除了接收者和锁定脚本之外的**内容**部分，内容会在签名时有一个独立的选项可用。


#### 锁定脚本

控制当前交易输出的币金可以被谁使用。注：即作为下一笔新交易的输入，如果用户提供的解锁脚本使得锁定脚本成功执行通过，则该笔币金就花了出去。


### 凭信

信用凭据的数字化表达，代表某种特定的价值或承诺，可转让或修订。与币金信元不同，除了接收者外，还有创建者、描述和附件ID几个字段，但它们都属于**内容**部分。

凭信转移也可被视为 **花费**，与币金一样，未花费的凭信会进入 `UTXO` 集。


#### 接收者

与币金的接收者规则相同，是一个可验证的目标。


#### 创建者

用该凭信交易的交易ID（可能还有区块号）表示。创建泛指：初次创建、修订创建、转为不可修改模式。

与币金只能由区块铸造者生成不同，凭信可以由任何人创建，也可转移给任何人。需要在每一次转移中检查创建者（注：如果为非修改类转移，则保持不变）。

> **注：**<br>
> 初次创建凭信交易的创建者标识为空，因为此时尚无交易ID。<br>
> 创建者实际上可以通过回溯区块链找到，但这里明确为一条记录来提高效率（性能）。<br>


#### 描述

用 `2` 字节定义配置。之后为凭信描述，通常可阅读。

```go
// 配置位
15] 新建标记。指示当前凭信是否为新建（含修改）。
14] 可否修改。指示描述和附件ID是否可修改。
13] 修改停止。置位表示凭信由可修改转为不可修改。
12] 销毁标记。当前凭信转移能力终结（会从UTXO集内移除）。
11] 转移次数限定。置位表示后面跟随2字节转移次数递减剩余值记录。
10] 有效期限定。置位表示后面跟随4字节有效期字段。单位为秒，从交易时间戳开始计算。
09] （未用）
[9] 低9位标记描述文本长度（<512 bytes）。
```

> **注记：**
> 转移次数和有效期可同时存在，此时以先结束者为准。
> 当转移次数递减为零或有效期抵达时，可对交易的销毁标记置位。销毁标记也可提前设置。


#### 附件ID（可选）

如果**输出类型**字段中附件标记置位，表示该交易包含有一个长 `32+n` 字节的附件ID：前32字节为附件数据的哈希摘要，后n字节为附件大小（变长整数）。

附件大小值不能为零，用户应当诚实填写。这一值并不会在交易验证期间检查核实，但它们会被存储在数据网络中（`depots:archives`），如果不诚实，可能会被视为不良数据而不被存储。

较高的附件大小应当适当提高交易费，用户支付的酬劳最终会部分分配给存储系统（数据网络）。

> **关于存储：**
> 附件是否被最终存储到数据网络中并没有绝对的保证，但通常在前期没有问题。
> 如果附件是公共文档（非加密或非私有协议），且有公共的价值，这种情况是没有节点会拒绝存储的。
>
> 注：上链的公共文档必须允许公共使用（开放使用协议）。

对附件哈希的计算，可能直接针对数据本身，但对于较大的附件，也可以是分片数据的哈希校验树根，但数据大小依然是针对数据本身。


#### 锁定脚本

限定该凭信转移的一段代码。如果用户提供的解锁脚本使得锁定脚本成功执行，则转移成功。

> **注记：**
> 如果描述字段的销毁标记置位，但此处依然有脚本代码，会被视为 **识别脚本**（同下存证信元逻辑）。


#### 附：凭信的转移验证逻辑

**可修改凭信：**

> 无输入源时：表示初始新建。新建标记位置位，可修改标记位置位。<br>
> 有输入源时：表示凭信转移。保持当前可修改时，按「修订传递」验证；转为不可修改时，可修改标记清位，修改转换标记置位。<br>

**不可修改凭信：**

> 无输入源时：表示初始新建。新建标记位置位，可修改标记位置零。<br>
> 有输入源时：表示凭信转移。检查输入源新建或修改转换标记位，置位则为「引用传递」（记录源交易ID），否则为「复制传递」（复制源交易记录的值）。<br>


> #### 凭信源身份记录
>
> 引用传递：输出中记录凭信源引用：交易年度 + 交易ID + 输出项偏移。合计 `2+32+2` 字节。<br>
> 复制传递：输出中记录与输入源的记录保持一致（即记录的值不变）。<br>


> #### 修订传递逻辑
>
> 如果内容发生了变化（包括附件变化），都视为新建逻辑，新建标记位置位。<br>
> 如果内容未变，新建标记清位。凭信源记录根据输入源情况采用引用传递（新建时）或复制传递（非新建）。<br>。


##### 说明：

- 可修改凭信可以通过清位修改标记而转变为不可修改凭信，但反过来则不行。这是一个有意的限制。
- 由可修改转为不可修改后，修改转换标记置位。如果内容已修改，新建标记也需置位。
- 凭信源身份的引用/复制传递使得追溯创建者很容易，这有时很有用，比如追溯子链的创建者以实施某种验证（「侧链微支付」）。


### 存证

与币金和凭信不同，存证是用来表达存在的。存在证明仅可使用而不能转移。

借助于区块链的信用能力和网络本身，它的用途可能会有很多，简单的如 **存在性证明**（如版权声明）、**CA证书存储**（供公开检索）、**话题索引**（一条子链就是一个自由的讨论集），**基础凭证**（如选举子链的授权公钥清单），或者作为第三方应用所需的基础起源信用数据存储等。

存证可由任何参与交易的人创建。因为不可转移，所以创建者即是当前交易的主人。


#### 名称

存证的标题，类似币金和凭信中的接收者。最长256字节，首字节定义实际长度。


#### 内容

由前 `2` 字节定义配置。

```go
 15] （未定义）
 14] （未定义）
 13] （未定义）
 12] （未定义）
 11] （未定义）
[11] 低11位记录内容长度（字节数），最大支持到2KB。
```

#### 附件ID

参考前面凭信部分说明，可选。


#### 识别脚本

用于存证的程序化识别和处理。因为存证不可转移，不作为新交易的输入项（验证），所以该脚本只对识别者有意义。


## 输入项验证

在本设计中，区块链的数据存储和查询外包给了公共服务网络，因此交易的验证是每个客户端都需要执行的。

作为一个轻客户端，验证交易数据有一些前提需要保证，即：任何一个客户端都始终保有区块头链数据，其中包含了区块哈希树的树根以及区块ID自身等基本信息。


### UTXO 验证

币金和凭信的输入项是交易信用的来源，必需验证合法才能通过其关联的交易内容。

UTXO 是未花费输出（Unspent Transaction Output）的简写，每笔交易的输入项中都必需是其它交易的未花费输出项才行。验证一笔输入项是否为未花费的输出，需要查询UTXO数据库。具体过程是这样的：

> **注：**
> 交易的输入项为 `2+20+2` 结构：2字节的交易年度、20字节的交易ID片段、2字节的输出项偏移。

- 从交易年度、交易ID片段和输出项偏移值查询UTXO数据库，获得交易输出项内容、交易哈希树、UTXO哈希树。
- 根据输出项内容、交易哈希树 => 计算完整交易ID，局部核实（可选）。
- 由输出项内容、交易ID、UTXO哈希树 => 计算UTXO指纹 => 计算区块ID（或区块头内根哈希），完成源合法性验证。

已经验证了的UTXO项可以实现为一个缓存，以便提供良好的效率。


### 442 验证

这是脚本中两个跳转/引用类指令 `GOTP/JUMP` 的源交易定位格式：4字节的区块高度、4字节的交易在区块中的序位、以及2字节的输出项偏移值。

442 定位的交易输出项无需是未花费的（UTXO），它们只是跳转或嵌入目标输出项的脚本而已。但这同样也需要验证其是否为真正的目标（这些数据是由外部的公共服务器提供的）。过程如下：

- 根据交易所在区块高度和其序位 => 检索交易ID、交易时间戳、以及区块哈希树 => 计算区块ID，核实交易ID合法。
- 根据交易时间戳计算交易年度，辅以交易ID、输出项偏移 => 检索交易输出项数据、交易哈希树 => 匹配交易ID，验证数据合法。


### 交易查询

因为区块链数据由外部的公共服务存储和提供，因此用户对交易数据的查询也需要验证其结果。

此时的查询键假设与交易输入的结构类似：`2+20`，其中2字节的年度和20字节的交易ID片段。验证过程参考如下：

- 向公共服务检索交易数据、交易所在区块 => 计算交易ID，局部匹配核实（可选）。
- 由交易所在区块 => 计算区块年度，配合区块定位 => 获取区块哈希树。
- 由交易ID、区块哈希树 => 计算区块ID，验证交易数据。


## 输出脚本

交易的输出脚本包含1个字节的设置。高4位为位标记，低4位为类型值。

```go
 7] 自定义类：置位时余下7位为类ID长度计数。
 6] 包含附件：声明是否携带附件，如果自定义类置位，此位变义。
 5] （未用）
 4] （未用）
[4] 类型说明：由低4位表达。
    0) 内置预留：暂无意义。
    1) 管 理 者：声明为接收前阶脚本跳转的「管理者」脚本。
    2) 币金交易：标记当前输出为币金支付。可以作为输入源。
    3) 凭信交易：标记当前输出为凭信（新建或转移）。可以作为输入源。
    4) 存证交易：标记当前输出为存证，不能作为输入源。
```


### 多重签名

在外观上，多重签名地址与普通地址没有区别，以增强隐私性。
内置验证对多重地址的判断，由解锁数据给出提示，明确告知系统应该采用哪一种签名验证的逻辑。


#### 多重签名地址

多重签名账户的地址构造流程：

1. 每个公钥执行哈希运算得到各自的公钥地址：`PKH = Hash( pubKey )`。
2. 全部公钥地址有序串连，前置2字节的 `n/T` 配比后计算总的哈希：`MPKH = Hash( <n/T> + PKH_1 + PKH_2 + ... )`。
3. 将上面的总公钥地址编码为文本形式，即为多重签名账户地址。

这里，每一位参与者只需要提供自己的公钥地址（而不是公钥本身），这提高了安全性。另一方面，它还让参与者变得更自由，比如使用既有的地址，或是匿名参与。

公钥地址集的顺序由构造者自己决定，并不一定按字节值排序。当用户在构造交易提供解锁脚本时，公钥和公钥地址需前置**1字节的序号**标识。

> **注：**<br>
> 多重配比的 `n/T` 表示 `T` 个公钥中至少有 `n` 个签名才有效。
> `n` 和 `T` 每个值各占用 `1字节`，最多可表达 `255/255` 的多重验证逻辑。
> 多公钥地址也可能按默克尔树进行组织，待考。


#### 多重签名的验证

提供的解锁实参：

- `n/T` 中 `n` 个公钥对交易的签名数据。
- `n/T` 中 `n` 个公钥。
- 未参与签名的公钥地址集（`T-n` 个）。**注**：用于与 `n` 个公钥共同构造多重签名地址。
- 每个公钥和公钥地址的**首字节**为其所在清单中的*序位*（`0-255`）。

> **注意：**
> 公钥或公钥地址在各自集合中没有顺序要求，但其首字节序位构成的最终集合需是一个从0开始的连续数列 `[0-T)`。
> 签名集内的成员数据需与公钥集内的成员按位置一一对应。

验证过程：

0. 提取目标账户地址中的 `n/T` 配比和公钥地址。
1. 检查 `n/T` 配比是否与提供的数据量相符：`n` 个公钥和 `T-n` 个公钥地址。
2. 对 `n` 个公钥计算哈希，与 `T-n` 个公钥地址合并。**注**：用首字节序位设置所属位置。
3. 前置 `n/T` 配比计算多重签名公钥地址。检查两个地址是否相同。
4. 验证 `n` 个公钥的签名数据。


#### 附：公钥地址的文本编码

将公钥地址采用某种编码方式编码为文本可读形式，即为账户地址。

**编码：**

0. 公钥地址添加识别前缀，即“前缀 + 公钥地址”。
1. 对其执行两次哈希运算，取末尾4字节为**校验码**。
2. 在公钥地址之后附上校验码（*此时无前缀*），编码为文本地址。
3. 附上识别前缀，即“前缀 + 文本地址”即为可视的账户地址。

**校验：**

0. 提取前缀和文本地址。
1. 将文本地址解码为字节序列。截取末尾4字节校验码，前段即为公钥地址。
2. 公钥地址前置识别前缀（即“前缀 + 公钥地址”），执行两次哈希运算取末尾4字节为校验码。
3. 比较上面两个校验码，相同则地址合法。


### 定制验证

通常情况下，输出脚本会采用系统内置的验证（`SYS_CHECKS` 指令），花费者提供约定格式的解锁数据，系统提取这些数据执行对用户合法性的验证。

内置的系统验证可以省掉大量的相同锁定脚本，但有时花费者也想要有自己更灵活的控制，比如花费者想要提供一个哈希屏障，由支付者设置在锁定脚本的开头。这样，当花费者提供哈希源前段后，验证就可以通过了。

这样的脚本开头通常为：

> `SOURCE[2] FN_HASH256 DATA{<ScriptHash>} EQUAL PASS`

其中：

- `SOURCE[12]` 提取前段源脚本字节序列副本（用 `SYS_NULL` 标记起点），不含 `SOURCE` 指令本身。
- `FN_HASH256` 对提取的字节序列计算哈希摘要。
- `DATA{<ScriptHash>}` 花费者提供的哈希结果（屏障），入栈。此时栈顶有两个哈希值。
- `EQUAL` 对比栈顶两个哈希值是否相等，Bool值入栈。
- `PASS` 读取栈顶值，若为真则验证通过。

另外，因为锁定脚本可以自由定义约束，所以无需签名验证也可能是有意义的。比如结合环境条件（`IN/OUT` 指令）构造出来的约束，只要有人愿意或能够满足条件，也可以完成特定的逻辑。


### 中介管理

对交易输入的验证允许交易间跳转：从一笔交易跳转到另一笔交易继续工作。

这是本系统中一个重要的机制设计。接收跳转的输出就是管理者脚本，需要设置此标记位。这是严格的，它只能接受其它脚本的跳转进入，而不能直接作为一笔交易里的输入源。

这样的设计可以允许外部管理的介入，比如监管机构先构建一笔管理者交易，用途是接收其它交易的进入以收集传递过来的财务信息，这样就可以实现商家主动申报税务的功能。**原理**：监管机构自己实施验证，脚本跳转后，根据脚本指令可以触发链外服务监控App，进而衔接到机构内部系统，完成相关工作。

> **注：**
> 出于性能和安全的考虑，一个脚本中连续跳转的行为有次数限定。


### 自定义类

脚本中包含了第三方扩展指令时，即属于自定义类。扩展指令是私有的，由扩展所属的专用客户端理解和执行。

此类输出无法被标准客户端理解，因此不能作为标准交易的输入源。

如果一笔输出被标记为自定义类，则后续7位就是长度计数，指明后续跟随的是该扩展的标识ID（<128字节长），再后面就是该扩展的私有脚本。第三方扩展的客户端依赖此ID来识别自己的数据。



## 签名消息

### 签名消息的种类

签名消息的种类由1个字节定义，表达了花费者多种可能的条件要求。**注**：锁定脚本表达的是支付者对花费者的约束。

```go
6] SIGIN_ALL    消息包含全部输入项。
5] SIGIN_SELF   消息仅包含当前输入项（自身）。
7] （未用）
3] SIGSCRIPT    特定于输出的脚本数据。
2] SIGCONTENT   特定于输出的内容部分。即：币金交易里的“数量”或凭信交易里的“创建者/描述/附件ID”部分。
4] SIGRECEIVER  特定于输出中的接收者。
1] SIGOUT_ALL   消息包含全部输出项（接收者、金额、脚本等完整数据，串联）。
0] SIGOUT_SELF  消息包含与当前输入项同偏移的输出项（接收者、金额、脚本等完整数据）。
```

其中高位两项为输入部分，低位两项为输出部分，中间三项为输出里的特定条目。
高低位可组合设置，也可单独使用。如果同时设置了中间三项特定类型的约束，则输出部分就只包含所指定类型的数据（**注**：输出标记始终存在），这可能为某些特殊的用途提供支持。

> **注**：定制验证时没有接收者，如果取值会得到一个空值（`nil`）。

不考虑特定类型约束，共计有**6+2**种基础配置，其中2种是冗余的（与其它组合同义）：

- `SIGIN_ALL` 签名全部输入，不含任何输出（类似 Bitcoin: `SIGHASH_NONE`）。含义：我同意使用我的资金参与这样一笔交易，至于钱怎么被分配，我不是特别在意。
- `SIGIN_ALL | SIGOUT_ALL` 签名全部输入和输出（类似 Bitcoin: `SIGHASH_ALL`）。含义：我只同意以这些输入和这些输出组合为一个交易，转移我的资金。**注**：这是大多数情况的配置。
- `SIGIN_ALL | SIGOUT_SELF` 签名全部输入和当前输入的同偏移输出（类似 Bitcoin: `SIGHASH_SINGLE`）。含义：我同意参与使用所有这些输入的交易，只要这个地址收到一定数量的钱。
-
- `SIGIN_SELF`: 签名当前输入，不含任何输出（类似 Bitcoin: `SIGHASH_NONE|SIGHASH_ANYONECANPAY`）。含义：我愿意发送这笔资金，不问缘由。**注**：任何人都可以花费掉它。
- `SIGIN_SELF | SIGOUT_ALL` 签名当前输入和全部输出（类似 Bitcoin: `SIGHASH_ALL|SIGHASH_ANYONECANPAY`）。含义：我同意参与这笔交易，只要这些受益人能收到这些款项，其他参与者随意。
- `SIGOUT_ALL` 同上含义（冗余）。
- `SIGIN_SELF | SIGOUT_SELF` 签名当前输入和同偏移输出（类似 Bitcoin: `SIGHASH_SINGLE|SIGHASH_ANYONECANPAY`）。含义：我就是想移动我的资金到这个地址中，其他人是否参与无所谓。
- `SIGOUT_SELF` 同上含义（冗余）。

> **注记：**<br>
> 两种冗余配置中没有当前输入的信息，这是可行的，因为验证签名针对的就是当前输入，只要计算出来的公钥地址匹配，签名就只是验证其私钥的正确性。
> 没人能替换当前输入。如果真替换了，那就是另一个验证了，与被替换的输入无关（并无安全性问题）。


### 签名消息的构造

根据如上消息种类的配置，消息的组合只是很简单地将目标数据串联，然后执行一次哈希运算得到摘要。签名的消息就是这个哈希摘要本身。**注**：统一为固定的长度更为友好。



## 脚本指令集

从更宽泛的意义上看，脚本就是合约，而合约是自由的。

本设计中的脚本指令包含了完整的流程控制语法，如：`IF`、`ELSE`、`SWITCH`、`CASE`、`EACH`（有限循环），运算操作符如：`+`、`-`、`*`、`/`，数据类型如：`Bool`、`Int`、`Bytes`、`String`、`Float` 等，以及其它必要的栈脚本结构。


### 基本概念

#### 数据栈

脚本的执行就是脚本中指令序列的逐个运行，大多数指令都是对数据进行操作，并返回一个或多个值。提供和存储这些数据的地方就是脚本的数据栈。

数据栈是后进先出（LIFO）的逻辑，脚本指令通过实参提取的方式从栈内获取数据，需要多少个实参取决于指令的参数定义。通常，从栈内取实参是一种**取出**的逻辑（从栈中弹出），而指令执行后的返回值则会自动入栈。

准确地说，指令实际上是通过下面的「实参空间」来获取的从参数的。

> **注记：**
> 数据栈存放的是通用类型值（`any`），各个指令（或其适配壳）需要自行检查并转换。


#### 实参空间

单一的栈结构会有一种局限，即脚本指令需要从栈中取值，同时其返回的值又会压入栈顶。这会造成一种排挤效应，十分不便于指令序列的连续操作。因此这里加入了「实参空间」的环节。

实参空间是一个临时的储值区：如果指令需要实参，系统会先从实参空间里获取，如果空间内已经无值，则再从数据栈里取值。这样就为栈式脚本的连续指令序列提供了一个数据腾挪的空间，消除了单一栈结构的数据排挤问题。

逻辑上，实参空间是一种队列结构：可以持续地向该空间末端添加数据，数据被取出时保持原添加的顺序。实参空间也简称为实参区，将由取值指令（`@`, `${}` 等）来添加赋值。

从实参区取值有两种方案：

1. **多次提取**。如果指令需要实参，会从实参区提取所需数量的值。这样的话，实参区值的数量必须大于等于指令的实参需求数量。如果有多余，这些值会用于下一个指令的实参提取。这种方式灵活性大，实参区可以进行取值布局，但复杂性会很高。
2. **一次性提取**。如果指令需要实参，实参空间中的值会一次性全部取出。这样的话，实参区值的数量就需要和指令的实参需求数量相同。没有多余的剩余值。这种方式较为简单，但灵活性不足，不过可以极大减轻脚本构造的复杂性，以及编码&审查人员的思虑，不易出错。

综合考虑权衡，本设计中采用较为简单的第二种**一次性提取**方案。

> **注：**
> *多次提取*实际上可以无缝兼容*一次性提取*方式——如果未来有必要升级的话。


> #### 附：实参数量
>
> - 无需求（`0`）。不会读取实参区，因此也不影响当前实参区内的数据。
> - 固定数量（`n`）。从实参区取值，如果实参区无值，则自动从数据栈提取 `n` 条数据。**注意**：是否从数据栈取值，只取决于实参区是否为空（而非数量不足）。
> - 不定数量（`-1`）。提取出实参区全部的值，如果实参区无值则视为零数量，不会读取数据栈。


#### 附属参数

与实参不同，有时指令本身也需要描述，以说明它的某些特性，如 `IF` 指令的代码块长度。这些描述性的值就是指令的附属参数，简称「附参」。

附参紧跟在指令之后，大多数情况下，它们只有 `1~2` 个字节。这是一种基础设计，它可以有很多用途，比如指定数据的范围、子语句块的长度、指令的纵深扩展等。

附参是指令的基本属性之一，重在描述指令的**静态**属性或不应当被改变的量。


#### 局部域存储

在栈式脚本中并不方便书写变量声明和赋值。借鉴普通的编程语言，我们在这里也加入了一个局部域的设计。这是一个有限的存储空间，随着一个语法块的开始而开启，结束而结束。

与普通编程语言不同，此局部域里的数据只能按顺序添加和按下标位置读取（不像变量一样赋值），所以下层语法块并不能读取其父语法块或其它语法块内的局部存储（即当前语法块私有）。

另外，系统有一个全局域空间，可以像普通变量一样定位赋值和读取（同样按下标定位，但可赋值）。


#### 多返回值

指令可以返回一个或多个值，如果返回的是多个值，系统会将之自动展开入栈（**注**：如果被捕获到实参空间或局部域，也同样会展开）。

与指令的实参数量一样，指令的返回值数量也是指令的一个基本属性。

- 无返回值（`0`）。系统不会有任何额外的行为。
- 单返回值（`1`）。直接入栈或被捕获进入实参空间（`@`）或当前局部域（`$`）。
- 特定数量（`n`）。会被系统自动展开压入相应的存储区。
- 不定数量（`-1`）。同上会被系统自动展开，但数量可为零。实现为返回一个切片，由系统主动将切片展开。


#### 缓存区和外部监听

本设计中有包含交互逻辑的指令（如 `INPUT`、`OUTPUT` 等），这样区块链就可以与外部世界相关联，比如导出数据，由外部正在监听的中间件处理，从而完成外部事务。

脚本与外部的交互通过两个各自独立的缓存区实现，一个导出，一个导入。

中间件的驱动是由外部监听实施的，逻辑上，这些监听是私有的：只有需要外部事物的节点才需要部署。数据的导出&转出是非阻塞的，不会影响脚本的正常执行。

由于中间件的中介衔接，外部系统实际上可以是任意的。


### 指令空间规划

每个指令都有一个值，脚本就是指令的**值的**序列。用数值而不是字符串来表达指令，可以节省空间并让指令的解析和执行更为高效。

指令空间就是指这个值的范围。

本系统中使用了 `1字节` 的长度来标记该空间，也即全部指令不超过 `256` 个。如果有更多指令的需求，则通过指令附参的方式来扩展（注：这种纵深扩展理论上是无限的）。

此1字节的指令空间定义的是栈脚本语法中需要的基础结构和基本函数，可称为第一层面指令。大部分的脚本逻辑仅需要这些指令即可完成。

从大的特性上，可以划分为如下几个块段：

1. **基础指令段**：包含全部的语法相关的基础指令，如流程控制、数学运算、栈操作、对外交互和模式匹配等。占位：`[0-169]`，共 **170** 位。
2. **函数指令段**：高频和常用的功能性函数，也包含2个自扩展指令。占位：`[170-209]`，共 **40** 位。
3. **模块指令段**：定义一些基本和标准模块，以及1个自扩展指令。占位：`[210-249]`，共 **40** 位。
4. **扩展指令段**：专用于指令的扩展引用，包括2个基础扩展指令和2个私有扩展指令。占位：`[250-255]`，共 **6** 位。


### 指令命名和书写约定

根据指令的特性（是什么），划分了如下5大类别，其命名规则如下：

1. 基础功能。指令名无前缀，视觉上简洁明快。如：`PASS` 真值通过。
2. 系统调用。指令名前缀 `SYS_`，如：`SYS_TIME{}` 系统环境取值指令。
3. 功能函数。指令名前缀 `FN_`，如：`FN_CHECKSIG` 签名验证。
4. 模块引用。指令名前缀 `MO_`，如：`MO_MATH{}` 数学模块，`MO_MATH{Abs}` 调用 `math.Abs()`。
5. 扩展定制。指令名前缀 `EX_`，如：`EX_INST` 通用扩展指令。

指令的书写/显示约定：

- `{}` 花括号包围指令的关联数据，比如值指令的实际值、if语句块的子指令序列等。
- `[]` 中括号标示指令附参的值，非必需时可省略。如：`DATA[20]{...}` 表示20字节长的字节序列，可简写为 `DATA{...}`。
- `()` 除了脚本中作为表达式和优先级指令外，也用于文档说明中表达指令附参的长度（字节数）。如 `DATA{}(1)`，指示 `DATA{}` 指令包含一个1字节长的附参。
- `<>` 尖括号表达命名数据，如：`<pubKey>` 指一个公钥，`<hashSource>` 指一个哈希源（用于哈希运算的数据），`DATA{<pubKey>}` 表达实际入栈的公钥（脚本源码表达中）。

该约定用于程序员书写的脚本，也用于向普通用户展示脚本的含义。**注**：链上的脚本只是值序列而非指令文本。


### 指令的类型

从指令的功能（干什么）上看，有如下类型划分：

1. **值指令**。脚本中的一个实际的值，会自动入栈。如：`FALSE`、`TRUE`、`DATA{}` 等。
2. **截取指令**。拦截跟随指令的返回值，将它们添加到实参空间或局部域。如：`@`、`$` 等。
3. **栈操作指令**。对数据栈中的条目执行简单的操作，如：压入（`PUSH`）、弹出（`POP`）、引用（`TOP`）等。
4. **集合指令**。对数组/切片类集合的一些基础操作，如：`MAP`、`FILTER`、`MERGE` 等。
5. **交互指令**。与一个缓存区交互，执行栈数据的导出（`OUTPUT`）与导入（`INPUT`）等。中间件可与该缓存区交互，从而实现区块链外的逻辑。
6. **结果指令**。整段脚本有一个确定的结果。如：`PASS` 通行验证，失败即判为非法，`GOTO` 会跳转到另一笔交易。
7. **流程指令**。实现执行流的控制，包含：`IF{}`、`ELSE{}`、`SWITCH{}`、`CASE{}`、`EACH{}`、`BREAK` 等。
8. **转换指令**。对实参值进行类型转换，包含如：`BOOL`、`FLOAT`、`STRING` 等。
9. **运算指令**。包含加、减、乘、除、模、位移等数值运算，以及小括号的优先级分组等。
10. **比较指令**。比较2个实参值，如：等于（`EQUAL`）、大于（`GT`）、范围之内（`WITHIN`）等。返回一个布尔值。
11. **逻辑指令**。实现逻辑与（`BOTH`）和逻辑或（`EITHER`）的功能，或同时检测多个值（`EVERY`、`SOME`）。
12. **模式指令**。判断脚本是否符合预期的逻辑（模型），指令包含：`MODEL{}`、`#`、`_`、`?`、`...`、`!{}` 等。
13. **环境指令**。提供交易环境相关的一些数据，如：`IN{}`、`OUT{}`、`VAR` 等。
14. **工具指令**。实现某些实用功能的指令，如：`EVAL`、`COPY`、`MATCH`、`RANGE` 等。
15. **系统指令**。和系统级有关的一些功能指令。如：`SYS_TIME`、`SYS_NULL` 等。
16. **函数指令**。一些常用的基础或标准功能函数。如：`FN_HASH256`、`FN_CHECKSIG`、`FN_BASE32` 等。
17. **模块指令**。包含一些专项功能的特定模块，其中有它自己的指令集。如：`MO_RE`、`MO_TIME`、`MO_MATH` 等。
18. **扩展指令**。用附参引入扩展的更多指令，仅有少数几个。如：`EX_FN`、`EX_INST` 等。


### 示例

#### 通用的币金输出验证

用户构造一笔交易，输入源引用资金来源交易，提供解锁脚本。

如果解锁脚本与资金来源交易的锁定脚本串接后执行成功，则花费该笔输出成功（即用解锁脚本证明自己拥有所有权）。当前交易的输出（锁定脚本）即为这笔花费的去向，将由下一位用户解锁使用。

```go
// 解锁脚本：
// 由使用者在花费币金时提供。
DATA{<sig>}     // 签名
DATA{<pubKey>}  // 公钥

// 锁定脚本：
// 即源交易的输出脚本，已固化在区块中。
TOP FN_PUBHASH DATA{46af3fb481837fadbb421727f9959c2d32a36829} EQUAL PASS FN_CHECKSIG PASS
```

**解释：**

1. `DATA{<sig>}`：签名入栈。    **栈状态**：`[<sig>]`
2. `DATA{<pubKey>}`：公钥入栈。 **栈状态**：`[<sig> <pubKey>]`
3. `TOP`：引用栈顶项（不弹出），结果值自动入栈。注：相当于 `DUP[1]`。        **栈状态**：`[<sig> <pubKey> <pubKey>]`
4. `FN_PUBHASH`：取出栈顶1项计算公钥地址后入栈。即：`FN_PUBHASH(<pubKey>)`。**栈状态**：`[<sig> <pubKey> <pubHash>]`
5. `DATA{46af3fb481837fadbb421727f9959c2d32a36829}`：公钥地址序列直接入栈。注：非公钥本身，实为一层哈希屏障保护。**栈状态**：`[<sig> <pubKey> <pubHash> <data{...}>]`
6. `EQUAL`：取出栈顶2项作相等比较，结果 TRUE 或 FALSE 入栈。   **栈状态**：`[<sig> <pubKey> <true|false>]`
7. `PASS`：取出栈顶值检查是否为 TRUE，是则通过，否则失败。      **栈状态**：`[<sig> <pubKey>]`
8. `FN_CHECKSIG`：取出栈顶2项（即最初的 `<sig>` 和 `<pubKey>`），验证签名数据。结果 TRUE 或 FALSE 入栈。**栈状态**：`[<true|false>]`
9. `PASS`：取出栈顶1项检查是否为 TRUE，是则通过，否则失败。**栈状态**：`[]`

> **注：**
> 指令详情请参考后续「脚本基础指令集」部分。

**更多的例子请参考：**

- [链间兑换](examples/链间兑换.md)
- [存在性证明](examples/存在性证明.md)
- [链间授信](examples/链间授信.md)
- [批量付款确认](examples/批量付款确认.md)
- [网购支付流程](examples/网购支付流程.md)
- [实时税务](examples/实时税务.md)
- [版权登记](examples/版权登记.md)
- [侧链微支付](examples/侧链微支付.md)
- [选举子链](examples/选举子链.md)



## 主要特点

### 逻辑完整的执行流指令

在Bitcoin系统的脚本操作指令中，出于性能和安全的考虑，并没有循环类指令如 `OP_LOOP`，这有些缺憾。

通常，这样无约束的循环可能导致死锁攻击，但如果循环本身是天然有限的，则可以很好地缓解这一问题。本设计中的 `EACH{}` 指令即是这一有限循环，循环针对已有数据迭代，因此安全得多。

脚本的流程控制指令包括：

- `IF{}(1)`      实参为真时执行。附参明确了语句块的长度（因此也就无需**endif**了）。
- `ELSE{}(1)`    if 的可选分支。附参含义同上。
- `SWITCH{}(2)`  多分支选择指令。实参为后续条件分支的对比目标，2字节的附参明确了语句块的大小。
- `CASE{}(1,1)`  条件判断分支。两个附参分别指定了条件表达式和分支语句子块的长度，表达式的结果与 switch 的目标值比较，相等则执行子语句块。
- `DEFAULT{}(1)` 多选默认分支。所有 case 都不匹配时执行，通常放在最后，附参明确了子块长度。
- `EACH{}(1)`    数据集迭代。附参明确了语句块长度。
- `BREAK`        退出 each 迭代或 switch 语法块。
- `CONTINUE`     直接进入下一循环（each）。
- `FALLTHROUGH`  case 分支穿越。

> **附注：**<br>
> 如果一笔交易的验证需要消耗大量的资源，它可能不受欢迎而被加入黑名单，这对交易者构造交易是一种压力，或许可以促使他们构造尽量简单的交易。<br>
> 大多数语句块长度附参仅为1字节，因此子语句块长度不超过 `255字节`，这种限制可促使用户尽量扁平化代码逻辑，有利于审计。<br>


### 可与链外的数据交互

交互类指令 `INPUT` 和 `OUTPUT` 可用于从缓存区导入或向缓存区导出数据，`BUFDUMP` 实现缓存区数据的清空和对外递送（转出），触发外部预先注册的处理器，这样就实现了区块链交易驱动外部事务的逻辑。

交互行为在脚本执行时发生，它们是私有的逻辑，仅在需要事务处理的环境里存在，对于其它普通节点，导出&转出指令会无阻塞地执行，如果没有数据可导入，脚本即会终止。

因为是私有的逻辑，所以如果必要，客户端或许可以在任何时候执行脚本。


### 脚本执行环境限定

区块链是一个开放的系统，恶意的攻击者可能构建十分消耗资源的交易来拖累系统，因此这里有一些限制：

- 数据栈高度：`< 256`。栈式脚本在运行过程中，数据栈内的数据大多会被即时使用，所以高度容量并不需要太大。
- 栈数据项大小：`< 1KB`。
- 锁定脚本长度：`< 1KB`。
- 解锁脚本长度：`< 4KB`。
- 单笔交易大小：`< 16KB`，不含签名数据。
- 交易输出项数：`< 2048`，即1个字节所能表达的字节数的位数（256*8）。
- 每区块包含交易数量：`< 64k`，2字节值范围。**注**：按6分钟一个区块计，平均 `182笔/秒`。
- 区块大小：`< 100MB`。
- JUMP嵌入次数：`< 10次`（运行时，下同）。
- GOTO跳转次数：`< 4次`。参考：管理者+审计者+第三方。

另外，系统内部的一些空间有如下特点：

- 局部域大小：`< 128`。支持负数从末尾引用。
- 实参空间：没有限制，但间接受制于数据栈或缓存区大小限制。
- 导入缓存区大小不作限制（客户机自负责）。

脚本的指令序列是顺序执行的且不可回退（没有返回到前端位置的指令），因此一个固定长度的脚本执行所消耗的资源是有限的。

> #### 附：对区块大小限额的思考
>
> 影响区块大小的因素有二：1. 打包交易的数量；2. 每笔交易本身的大小。<br>
> 本区块链交易不仅是币金交易，还包含凭信和存证的类型。相较于区块中交易的数量，交易本身的数据尺寸变化更大。<br>
> 因此设计倾向于硬性限制交易的数量，而通过对交易本身大小的限制来调节区块的大小。<br>
>
> 区块链可能更应该是一种介质而非平台，现实当中应该有很多相互协作的区块链存在，所以包含巨量交易的重要性可能并没有想的那么重要。<br>
> 设计预估的每区块交易数量是64k上限，这可能是合理的。<br>


### 第三方扩展

区块链主要是创建和传递信用，功能相对稳定，发展缓慢或许是一种正常的状态。

公共的区块链是一个公共的信用数据区，它为任意的第三方提供了一种现实的“依靠”。如果第三方应用借助于主链的网络、数据、状态、交互等实现自身的业务，这本身就是一种扩展了。

第三方扩展是私有的，主链客户端不理解也无法直接支持它们，这些业务是任意的。



-------------------------------------------------------------------------------

上一篇：[激励机制](4.激励机制.md)<br>
下一篇：[脚本基础指令集](6.脚本基础指令集.md)<br>
[11] 内容的长度定义（字节数），可能与前6位合并使用，以最大支持到16KB内容。
