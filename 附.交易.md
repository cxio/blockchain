# 交易

不同于Bitcoin的交易历史只是一种存储，这里的交易历史有后期的各种需求（识别脚本应用、介管脚本引用、第三方二次开发等）。因此交易的数据结构需要便于检索和验证。

检索和验证主要采用哈希校验树的方式，类似于Bitcoin的默克尔树，但细节稍有不同。


## 交易头

类似于区块头抽象了区块数据，这里设计了交易头结构。伪代码示意：

```go
// 简化版示意：
TxHeader {
    Version    int      // 版本
    Timestamp  int64    // 交易时间戳（Unix 毫秒）
    HashInputs Hash512  // 输入项根哈希
    HashOutputs Hash512 // 输出项根哈希
    ...                 // 其它可能需要的字段（如果有）
}

// 交易头的哈希即为交易ID。
TxID: Hash512( TxHeader )
```


## 交易体

由输入项集合和输出项集合构成。下面分布阐述输入项和输出项。


### 输入项

#### 结构

输入项是交易信用的来源，由3~4个字段构成：「年度」、「交易ID」、「输出序位」和凭信转移专有的「转出序位」。

- `[n]`  交易所在年度。这是一个概略的时间约束，方便管理。
- `[64]` 交易ID的全引用。仅限首笔输入（首领输入）。
- `[20]` 交易ID的前段局部引用。用于除首笔输入之外的其余输入，短片段以节省空间。
- `[n]`  输出项下标序位（来源输出集）。大多数都只需要1字节表达（<128）。
- `[n]`  当前凭信转出到的目标输出位置，用于合法性检查。

首领输入也用于铸凭交易的属主检索，因此采用全序列 `64` 字节，便于验证。其它输入使用 `20` 字节片段，以降低数据量。

所有的币金输入项都从当前**UTXO**集里检索，凭信输入项从**UTCO**集里检索。UTXO/UTCO 的可靠性由其指纹保证，因此20字节的引用只涉及重名问题。

> **注：**
> 不支持未确认交易的输出项作为输入项。
> 首领输入必然是币金花费，因为存在「首领校验」的快速验证设计。


#### 哈希校验树

交易里的输入集被独立计算哈希树根，树结构类似于默克尔树（仅2层）。

其中首领输入单列，便于铸造者快速定位和验证凭证属主，剩余输入项作为列表串接计算哈希。

```go
// 由首领输入和其余输入项串接计算。
InputHash: Hash512(LeadHash + RestHash)

LeadHash: Hash512(
    Year      int       // 交易年度
    TxIDPart  [64]byte  // 交易ID
    OutIndex  int       // 输出项序位
)

// 剩余输入项作为列表串接计算哈希。
RestHash: Hash512( ListOf(RestInputs) )
RestInput: {
    Year      int       // 交易年度
    TxIDPart  [20]byte  // 交易ID前20字节
    OutIndex  int       // 输出项序位
    TransferIndex int   // 凭信转出序位（可选）
}
```


#### 合法性验证

一笔交易中可以包含多个输入项，每个输入项是另一笔交易未花费/转移的输出（UTXO/UTCO）。输入项需要被验证，以证明交易的构造者拥有它。

验证采用解锁脚本的方式：*解锁脚本 + 锁定脚本 => 如果整个脚本执行成功，则验证通过*。

> **注：**
> 如果有签名数据，由另外的方式载入系统，等待解锁脚本中的 `SYS_CHKPASS` 指令执行时使用。


#### 附：UTXO/UTCO 集合

所有已确认交易的未花费币金和未转移凭信输出构成了 UTXO 和 UTCO 集合，它确定于上一个区块。

在本设计中，一个未确认交易的输出不属于 UTXO/UTCO，即便它合法，因为未确认的交易可能被替换或过期失效。同时，这也是组队校验对交易独立性的要求。

试图构建一个*链式的*未确认支付序列是不可能的，只有头部第一笔交易会被验证和广播，其余被丢弃。


### 输出项

接受币金支付或凭信转移的目标（目的地）。

一笔交易中可以有多个输出项。对于币金交易来说，可能包含一个收款者和一个找零地址。对于凭信转移交易，则逻辑上只有一个接收者。

每一笔*输出*包含了特定类型「信元」的相关字段信息（详见『信用结构』中相应的信元定义）。


#### 配置

输出项包含**1**字节的配置。高4位为位标记，低4位为类型值。

```go
 7] 自定义类：置位时余下7位为类ID长度计数。
 6] 包含附件：声明是否携带附件，如果自定义类置位，此位变义。
 5] 销毁标记：主要用于币金和凭信。
 4] （未用）
[4] 类型说明：低4位值。
    0) 预留：无意义。
    1) 币金：输出为币金支付。可以作为输入源。
    2) 凭信：输出为凭信（新建或转移）。可以作为输入源。
    3) 存证：输出为存证，不能作为输入源。
    4) 介管：声明为接收前阶脚本跳转或嵌入的中间脚本。
```

如果希望销毁币金，或终止凭信的转移能力，可以设置销毁标记。此时输出的币金不再进入UTXO集，凭信也不再进入UTCO集。

如果配置为销毁，接收地址可设置为 `null`，输出脚本任意。

一个非标准的地址通常意味着自定义验证（没有 `SYS_CHKPASS` 指令）。


#### 介管脚本

脚本允许在交易间跳转。因此这创建了一个*中介*的逻辑。

接收跳转的目标交易的输出脚本就是介管脚本，这是一种特定的类型，不能作为交易里的输入项，只能在脚本中通过跳转指令（如 `GOTO`）引用。

介管的存在，使得可以插入监管逻辑，比如一笔先期建立的财务监听脚本，可以接收企业支付脚本的*途经*路过……获取必要的信息，然后……

> **注：**
> 出于性能和安全考虑，一个脚本中连续跳转的行为有次数限制。


#### 自定义类

用户可以创建专属的私有脚本，此即自定义类。

自定义类输出脚本中通常会包含私有的扩展指令，它们无法被公共的客户端理解，因此也不能作为输入源。自定义类是私有应用借助于公共网络传递信息的机制，这也是通用公共网络携带更多价值的体现之一。

最长127字节的私有标识ID，为这些专属客户端识别自己提供锚定。


#### 哈希校验树

各个输出项作为叶子节点计算哈希，按二元树结构组织成哈希校验树。哈希树根与输入项哈希一起，合并计算交易体哈希。

```go
OutputHash: Hash512( Tree<Outputs> )

// 输出项结构示意
// 详见『信用结构』中相应的信元定义。
Output: {
    Serial      int         // 输出序位（从0开始）
    Amount      int64       // 币金数量（按基本单位）
    Address     [48]byte    // 接收地址（公钥地址哈希）
    LockScript  []byte      // 锁定脚本
    ...                     // 其它可选字段
}
```

> **注：**
> 这样的二元哈希校验树便于独立验证和定位。


## 签名

对输出项的*拥有权*通常通过签名来证明。这也是系统内置验证的标准方式。

签名可以是简单的**单签名**模式，即输入项的来源输出是属于一个简单公钥哈希，因此也仅由一个私钥对应。

签名还可以是复杂的**多重签名**，即输入项的来源输出是属于一个复合公钥哈希地址，该地址实际上由多个公钥构成，因此也就对应多个私钥。

- **简单公钥哈希**：由一个私钥对应一个公钥，对公钥的哈希结果。
- **复合公钥哈希**：由多个公钥根据规则构造的序列，对该序列的哈希结果。因此对应多个私钥。

**注：**
- 简单公钥哈希与复合公钥哈希在外观上没有区别（隐私安全），但它们的验证逻辑不同。


### 单签名

交易的输入项来源于简单公钥哈希，签名仅需单一私钥。

这是大多数交易的实际情况，即便交易里有多笔输入，它们都来源于简单的公钥哈希地址。

> **注：**
> 包含多笔简单公钥哈希输入的交易，需要这些输入项的全部签名。


### 多重签名

适用于复合公钥哈希地址，需要由多个私钥共同进行签名才行。此即为*多重签名*，也即所谓的**多签**（简称）。

多签支持 `M-Of-N` 的工作机制，以增强社会化的安全性和灵活性。

- N：总共需要的私钥数量（参与方的公钥总数）。
- M：实际需要签名授权的最少私钥数量（M ≤ N）。如：`2-of-3` 多签地址表示有3个私钥，任何2个私钥签名即可。

> **注：**
> 内置验证对单签名或多重签名的判断由解锁数据指明。


#### 多重签名的地址

构造流程：

1. 对N个公钥各自执行哈希运算得到N个公钥哈希：`PKH1 = Hash( pubKey1 )`, `PKH2 = Hash( pubKey2 )`, ……
2. 各公钥哈希有序串连，再前置 `m/N` 配比，计算复合公钥哈希：`PKHs = Hash( <m/N> + PKH1 + PKH2 + ... )`。
3. 复合公钥哈希（`PKHs`）编码为文本形式，即为多重签名的账户地址。

> **说明：**
> `m/N` 配比为 `1+1` 两个字节，因此最多支持 `255/255` 的组合规模。

每一位参与者只需提供自己的公钥哈希（而非公钥），这会更安全。在外观上，多签地址与普通地址也没有区别（隐私安全）。

另外，这种安全性可能让参与者更自由，比如匿名参与会更容易。


#### 多重签名的验证

解锁数据：

- **签名集**：`m/N` 中 `m` 个私钥对交易的签名。
- **公钥集**：上面 `m` 个签名对应的公钥序列。
- **补全集**：未参与签名的公钥的哈希（`N-m` 个）。

> **注：**
> 组合配比 `m/N` 可由公钥集大小和补全集大小计算而来。

验证过程：

0. 计算 `m/N` 配比。
1. 计算公钥集里各个公钥的哈希。
2. 结果集与补全集里的哈希混合排序、串连，前置 `m/N` 配比，计算复合公钥哈希。
3. 对比接收者的公钥哈希与上面计算的结果，相同时有效。
4. 验证签名集里的各个签名。


### 签名消息

通过对签名消息的不同约束，签名授权可以有多种模式。


#### 授权种类

由**1**个字节配置签名消息的约束针对：

```go
// 独项：
7] SIGIN_ALL    全部输入项
6] SIGIN_SELF   当前输入项（自身）
// 主项：
5] SIGOUT_ALL   全部输出项：适用于币金、凭信、存证
4] SIGOUT_SELF  与当前输入项同序位的输出项
// 辅项：
// 需配合 SIGOUT_SELF | SIGOUT_ALL 使用。
0] SIGRECEIVER  输出的接收者。
1] SIGCONTENT   输出项的内容：币金「数量/附言」；凭信「创建者/配置/标题/描述/附件ID」。
2] SIGSCRIPT    输出项的脚本。
3] SIGOUTPUT    输出项完整条目（接收者+内容+脚本）。
```

**说明：**

- 「独项」逻辑自完整。可独立设置，也可与其它设置合并使用，如：`SIGIN_ALL|SIGOUT_SELF|SIGOUTPUT`，全部输入项和当前同序位输出项完整条目。
- 「主项」不能独立设置，需与辅项配合。如：`SIGOUT_ALL|SIGRECEIVER`，针对全部输出项的接收者（仅输出部分）。
- 「辅项」需与主项配合使用。如：`SIGIN_SELF|SIGOUT_SELF|SIGOUTPUT`，针对当前输入项和同序位输出项的完整条目。

> **提示：**
> 最常见的配置：`SIGIN_ALL|SIGOUT_ALL|SIGOUTPUT`，全部输入项和全部输出项完整数据。



## 附：铸币交易（Coinbase）

铸币交易是一笔特殊的交易，它没有输入源（即没有花费项来源），是币金从无到有凭空生成的创造者。

作为基础性的设计，它需要包含如下关键信息：

- 区块高度：明确Coinbase交易的位置。
- 择优凭证：区块铸造者证明，也用于分叉之后的链段竞争。
- 收益总额：铸币 + 交易费 + 兑奖截留。
- 收益分成：铸造者（校验组）、铸凭者（铸凭交易提供者）、Blockqs、Depots、STUN服务等。
- 自由数据：类似于Bitcoin，为铸造者提供一定的灵活性（<256字节）。

> **注：**
> 作为约定，铸币交易应当始终位于区块收集的交易序列的首个位置（[0]）。


### 输出项配置

铸币交易的输出项配置与普通交易不同，但依然为1字节：

```go
 7] （未用）
 6] （未用）
 5] （未用）
 4] （未用）
[4] 奖励/分成目标：低4位值。
    0) 预留：无意义。
    1) 铸凭者（10%）
    2) 校验组（40%）
    3) Blockqs（20%）
    4) Depots（20%）
    5) STUN服务（10%）
```

> **注：**
> 系统兑奖指令（`SYS_AWARD`）会针对配置核实目标的实际可用金额（减去截留）。


## 附：公钥哈希的地址编码

将公钥哈希采用某种规则编码为可读的文本形式，即为公钥地址。

> **附注：**
> 公钥哈希较长，可能采用Base58编码方式，尽可能友好人类视觉。
> 这可能不太友好听觉，但……


### 编码

0. 公钥哈希添加识别前缀，即“前缀 + 公钥哈希”。
1. 执行哈希运算，取末尾4字节为 **校验码**。
2. 在公钥哈希之后附上校验码（*此时无前缀*），编码为文本序列。
3. 附上识别前缀，即“前缀 + 文本序列”即为公钥地址。


### 校验

0. 提取前缀和文本序列。
1. 将文本序列解码为字节序列。截取末尾4字节校验码，前段即为公钥哈希。
2. 公钥哈希前置识别前缀（即“前缀 + 公钥哈希”），执行哈希运算取末尾4字节为校验码。
3. 比较两个校验码，相同则通过。



## 附：交易的存储与验证

交易数据的完整存储是由外部的第三方公共服务提供的，但原则如下：

- 数据部分：以交易年度（按交易时间戳计算）和交易ID为索引，存储交易的完整数据。由需要数据的用户使用。
- 验证部分：以区块年度和高度为索引，存储区块内交易ID清单，可提供哈希校验树的「验证路径序列」。由验证者使用。

> **注：**
> 用户拥有区块头链（及关联数据），可以按区块高度验证交易数据。

具体设计详见：[cxio/blockqs](https://github.com/cxio/blockqs) 项目。


### 交易的查询和验证

已知交易ID和交易时间戳（或年度），用户可以定位到交易数据及其元信息。

元信息中包含交易所在的区块和序位，于是可以定位并获取验证关联的部分，结合交易数据本身，即进行完整验证。

> **注：**
> 用户拥有的区块头链即为必要的关联数据，它是交易验证的总根。



--------------------------------------------------------------------------

上一篇：[脚本系统](7.脚本基础指令集.md)<br>
下一篇：[附：组队校验](附.组队校验.md)<br>
